<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · MbedTLS.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MbedTLS.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.Cipher-Tuple{Union{CipherID, CipherKind}}" href="#MbedTLS.Cipher-Tuple{Union{CipherID, CipherKind}}"><code>MbedTLS.Cipher</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Cipher(info::Union{CipherID, CipherKind}) -&gt; Cipher</code></p><p>Construct a cipher object and set it to use the specified cipher algorithm.</p><p>The algorithm can either be specific (ie, <code>CIPHER_AES_256_CBC</code>), or general (ie, <code>CIPHER_AES</code>). In the latter case, a default choice of specific cipher will be used. See <code>?CipherInfo</code> for more details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.decrypt" href="#MbedTLS.decrypt"><code>MbedTLS.decrypt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>decrypt(cipher, key, msg, [iv]) -&gt; Vector{UInt8}</code></p><p>Decrypt a message using the given cipher. The cipher can be specified as</p><ul><li>a generic cipher (like CIPHER_AES)</li><li>a specific cipher (like CIPHER<em>AES</em>256_CBC)</li><li>a Cipher object</li></ul><p><code>key</code> is the symmetric key used for cryptography, given as either a String or a <code>Vector{UInt8}</code>. It must be the right length for the chosen cipher; for example, CIPHER<em>AES</em>256_CBC requires a 32-byte (256-bit) key.</p><p><code>msg</code> is the message to be encoded. It should either be convertible to a String or be a <code>Vector{UInt8}</code>.</p><p><code>iv</code> is the initialization vector, whose size must match the block size of the cipher (eg, 16 bytes for AES) and correspond to the iv used by the encryptor. By default, it will be set to all zeros.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.digest" href="#MbedTLS.digest"><code>MbedTLS.digest</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>digest(kind::MDKind, msg::Vector{UInt8}, [key::Vector{UInt8}]) -&gt; Vector{UInt8}</code></p><p>Perform a digest of the given type on the given message (a byte array), return a byte array with the digest.</p><p>If an optional key is given, perform an HMAC digest.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.digest!" href="#MbedTLS.digest!"><code>MbedTLS.digest!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>digest!(kind::MDKind, msg::Vector{UInt8}, [key::Vector{UInt8}, ], buffer::Vector{UInt8})</code></p><p>In-place version of <code>digest</code> that stores the digest to <code>buffer</code>.</p><p>It is the user&#39;s responsibility to ensure that buffer is long enough to contain the digest. <code>get_size(kind::MDKind)</code> returns the appropriate size.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.encrypt" href="#MbedTLS.encrypt"><code>MbedTLS.encrypt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>encrypt(cipher, key, msg, [iv]) -&gt; Vector{UInt8}</code></p><p>Encrypt a message using the given cipher. The cipher can be specified as</p><ul><li>a generic cipher (like CIPHER_AES)</li><li>a specific cipher (like CIPHER<em>AES</em>256_CBC)</li><li>a Cipher object</li></ul><p><code>key</code> is the symmetric key used for cryptography, given as either a String or a <code>Vector{UInt8}</code>. It must be the right length for the chosen cipher; for example, CIPHER<em>AES</em>256_CBC requires a 32-byte (256-bit) key.</p><p><code>msg</code> is the message to be encoded. It should either be convertible to a String or be a <code>Vector{UInt8}</code>.</p><p><code>iv</code> is the initialization vector, whose size must match the block size of the cipher (eg, 16 bytes for AES). By default, it will be set to all zeros, which is not secure. For security reasons, it should be set to a different value for each encryption operation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.CipherInfo-Tuple{MbedTLS.CipherID,Any,MbedTLS.CipherMode}" href="#MbedTLS.CipherInfo-Tuple{MbedTLS.CipherID,Any,MbedTLS.CipherMode}"><code>MbedTLS.CipherInfo</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>CipherInfo(id::CipherID, key_bitlength, mode::CipherMode) -&gt; CipherInfo</code></p><p>Construct a custom cipher info object.</p><ul><li><code>id</code>: A CipherID, such as CIPHER<em>AES of CIPHER</em>BLOWFIHS</li><li><code>key_bitlength</code>: The bit length of the secret key. Available options depend</li></ul><p>on the specific cipher id.</p><ul><li><code>mode</code>: Either <code>Encrypt</code> or <code>Decrypt</code> to indicate which cipher operation will</li></ul><p>be performed with this cipher info.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.CipherInfo-Tuple{MbedTLS.CipherID}" href="#MbedTLS.CipherInfo-Tuple{MbedTLS.CipherID}"><code>MbedTLS.CipherInfo</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>CipherInfo(id::CipherID) -&gt; CipherInfo</code></p><p>Build a CipherInfo for the given cipher id using the strongest available key size and the CBC block mode.</p><p><em>Warning</em>: In CBC block mode, it is imperative that you use a unique IV (initial value) for each encryption operation to maintain security.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.close-Tuple{MbedTLS.SSLContext}" href="#Base.close-Tuple{MbedTLS.SSLContext}"><code>Base.close</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Send a TLS <code>close_notify</code> message to the peer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eof-Tuple{MbedTLS.SSLContext}" href="#Base.eof-Tuple{MbedTLS.SSLContext}"><code>Base.eof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>True if not <code>isreadable</code> and there are no more <code>bytesavailable</code> to read.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isopen-Tuple{MbedTLS.SSLContext}" href="#Base.isopen-Tuple{MbedTLS.SSLContext}"><code>Base.isopen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Same as <code>iswritable(ctx)</code>.</p><blockquote><p>&quot;...a closed stream may still have data to read in its buffer,  use eof to check for the ability to read data.&quot; [?Base.isopen]</p></blockquote></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isreadable-Tuple{MbedTLS.SSLContext}" href="#Base.isreadable-Tuple{MbedTLS.SSLContext}"><code>Base.isreadable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>True unless:</p><ul><li>TLS <code>close_notify</code> was received, or</li><li>the peer closed the connection (and the TLS buffer is empty), or</li><li>an un-handled exception occurred while reading.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.iswritable-Tuple{MbedTLS.SSLContext}" href="#Base.iswritable-Tuple{MbedTLS.SSLContext}"><code>Base.iswritable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>True unless:</p><ul><li><code>close(::SSLContext)</code> is called, or</li><li>the peer closed the connection.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readavailable-Tuple{MbedTLS.SSLContext}" href="#Base.readavailable-Tuple{MbedTLS.SSLContext}"><code>Base.readavailable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Read available decrypted data from <code>ctx</code>, but don&#39;t wait for more data to arrive.</p><p>The amount of decrypted data that can be read at once is limited by <code>MBEDTLS_SSL_MAX_CONTENT_LEN</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readbytes!" href="#Base.readbytes!"><code>Base.readbytes!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Copy at most <code>nbytes</code> of decrypted data from <code>ctx</code> into <code>buf</code>. If <code>all=true</code>: wait for sufficient decrypted data to be available. Less than <code>nbytes</code> may be copied if the peer sends TLS <code>close_notify</code> or closes the connection. Returns number of bytes copied into <code>buf</code> (<code>&lt;= nbytes</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_read-Tuple{MbedTLS.SSLContext,Ptr{UInt8},UInt64}" href="#Base.unsafe_read-Tuple{MbedTLS.SSLContext,Ptr{UInt8},UInt64}"><code>Base.unsafe_read</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Copy <code>nbytes</code> of decrypted data from <code>ctx</code> into <code>buf</code>. Wait for sufficient decrypted data to be available. Throw <code>EOFError</code> if the peer sends TLS <code>close_notify</code> or closes the connection before <code>nbytes</code> have been copied. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.f_recv-Tuple{Any,Any,Any}" href="#MbedTLS.f_recv-Tuple{Any,Any,Any}"><code>MbedTLS.f_recv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Copy at most <code>nbytes</code> of encrypted data to <code>buf</code> from the <code>bio</code> connection. If no encrypted bytes are available return:</p><ul><li><code>MBEDTLS_ERR_SSL_WANT_READ</code> if the connection is still open, or</li><li><code>MBEDTLS_ERR_NET_CONN_RESET</code> if it is closed.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.f_send-Tuple{Any,Any,Any}" href="#MbedTLS.f_send-Tuple{Any,Any,Any}"><code>MbedTLS.f_send</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Copy <code>nbytes</code> of encrypted data from <code>buf</code> to the underlying <code>bio</code> connection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.get_size-Tuple{MbedTLS.MDInfo}" href="#MbedTLS.get_size-Tuple{MbedTLS.MDInfo}"><code>MbedTLS.get_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>get_size(kind::MDKind) -&gt; Int</code></p><p>Returns the size of the digest in bytes that the given digest type requires.</p><p>For example,</p><pre><code class="language-julia">get_size(MD_SHA256) == 32</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.set_bio!-Union{Tuple{T}, Tuple{SSLContext,T}} where T&lt;:IO" href="#MbedTLS.set_bio!-Union{Tuple{T}, Tuple{SSLContext,T}} where T&lt;:IO"><code>MbedTLS.set_bio!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Connect <code>f_send</code> and <code>f_recv</code> callback functions to <code>SSLContext</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_abandon-Tuple{MbedTLS.SSLContext}" href="#MbedTLS.ssl_abandon-Tuple{MbedTLS.SSLContext}"><code>MbedTLS.ssl_abandon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The documentation for <code>ssl_read</code>, <code>ssl_write</code> and <code>ssl_close_notify</code> all say:</p><blockquote><p>If this function returns something other than 0 or MBEDTLS<em>ERR</em>SSL<em>WANT</em>READ/WRITE, you must stop using the SSL context for reading or writing, and either free it or call</p></blockquote><p>This function ensures that the <code>SSLContext</code> is won&#39;t be used again.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_check_pending-Tuple{MbedTLS.SSLContext}" href="#MbedTLS.ssl_check_pending-Tuple{MbedTLS.SSLContext}"><code>MbedTLS.ssl_check_pending</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ssl_check_pending(::SSLContext)::Bool</code></pre><p>Check if there is data already read from the underlying transport but not yet processed.</p><p>If the SSL/TLS module successfully returns from an operation - e.g. a handshake or an application record read - and you&#39;re awaiting incoming data next, you must not immediately idle on the underlying transport to have data ready, but you need to check the value of this function first.  The reason is that the desired data might already be read but not yet processed.  If, in contrast, a previous call to the SSL/TLS module returned MBEDTLS<em>ERR</em>SSL<em>WANT</em>READ, it is not necessary to call this function, as the latter error code entails that all internal data has been processed.</p><p>https://tls.mbed.org/api/ssl_8h.html#a4075f7de9877fd667bcfa2e819e33426</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_close_notify-Tuple{MbedTLS.SSLContext}" href="#MbedTLS.ssl_close_notify-Tuple{MbedTLS.SSLContext}"><code>MbedTLS.ssl_close_notify</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ssl_close_notify(::SSLContext)</code></pre><p>Notify the peer that the connection is being closed. 0 if successful, or a specific SSL error code.</p><p>If this function returns something other than 0 or MBEDTLS<em>ERR</em>SSL<em>WANT</em>READ/WRITE, you must stop using the SSL context for reading or writing, and either free it or call mbedtls<em>ssl</em>session_reset() on it before re-using it for a new connection; the current connection must be closed.</p><p>https://tls.mbed.org/api/ssl_8h.html#ac2c1b17128ead2df3082e27b603deb4c</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_conf_renegotiation!-Tuple{SSLConfig,Any}" href="#MbedTLS.ssl_conf_renegotiation!-Tuple{SSLConfig,Any}"><code>MbedTLS.ssl_conf_renegotiation!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Enable / Disable renegotiation support for connection when initiated by peer (MBEDTLS<em>SSL</em>RENEGOTIATION<em>ENABLED or MBEDTLS</em>SSL<em>RENEGOTIATION</em>DISABLED). See: https://tls.mbed.org/api/ssl_8h.html#aad4f50fc1c0a018fd5eb18fd9621d0d3</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_get_bytes_avail-Tuple{MbedTLS.SSLContext}" href="#MbedTLS.ssl_get_bytes_avail-Tuple{MbedTLS.SSLContext}"><code>MbedTLS.ssl_get_bytes_avail</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the number of application data bytes remaining to be read from the current record.</p><p>https://tls.mbed.org/api/ssl_8h.html#ad43142085f3182e9b0dc967ec582032b:</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_read-Tuple{MbedTLS.SSLContext,Any,Any}" href="#MbedTLS.ssl_read-Tuple{MbedTLS.SSLContext,Any,Any}"><code>MbedTLS.ssl_read</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ssl_read(::SSLContext, ptr, n)</code></pre><p>Returns One of the following: 0 if the read end of the underlying transport was closed, the (positive) number of bytes read, or a negative error code on failure.</p><p>If MBEDTLS<em>ERR</em>SSL<em>WANT</em>READ is returned, no application data is available from the underlying transport. In this case, the function needs to be called again at some later stage.</p><p>If this function returns something other than a positive value or MBEDTLS<em>ERR</em>SSL<em>WANT</em>READ/WRITE or MBEDTLS<em>ERR</em>SSL<em>CLIENT</em>RECONNECT, you must stop using the SSL context for reading or writing, and either free it or call mbedtls<em>ssl</em>session_reset() on it before re-using it for a new connection; the current connection must be closed.</p><p>https://tls.mbed.org/api/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_session_reset-Tuple{MbedTLS.SSLContext}" href="#MbedTLS.ssl_session_reset-Tuple{MbedTLS.SSLContext}"><code>MbedTLS.ssl_session_reset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Reset an already initialized SSL context for re-use while retaining application-set variables, function pointers and data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_unsafe_read-Tuple{MbedTLS.SSLContext,Ptr{UInt8},UInt64}" href="#MbedTLS.ssl_unsafe_read-Tuple{MbedTLS.SSLContext,Ptr{UInt8},UInt64}"><code>MbedTLS.ssl_unsafe_read</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ssl_unsafe_read(::SSLContext, buf, nbytes)</code></pre><p>Copies at most <code>nbytes</code> of decrypted data into <code>buf</code>. Never blocks to wait for more data to arrive. Returns number of bytes copied into <code>buf</code> (<code>&lt;= nbytes</code>). Updates <code>ctx.bytesavailable</code> with the number of decrypted bytes remaining in the TLS buffer.</p><p>Stops when:</p><ul><li><code>nbytes</code> have been copied, or</li><li>there are no more decrypted bytes available in the TLS buffer, or</li><li>a TLS <code>close_notify</code> message is received.</li></ul><p>When TLS <code>close_notify</code> is received:</p><ul><li><code>isreadable</code> is set to false and <code>bytesavailable</code> is set to zero. [RFC5246 7.2.1]: &quot;Any data received after a closure alert is ignored.&quot;</li><li>the number of bytes read before the <code>close_notify</code> is returned as usual.</li></ul><p>Throws a <code>MbedException</code> if <code>ssl_read</code> returns an unhandled error code.</p><p>When an unhandled exception occurs <code>isreadable</code> is set to false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_unsafe_write-Tuple{MbedTLS.SSLContext,Ptr{UInt8},UInt64}" href="#MbedTLS.ssl_unsafe_write-Tuple{MbedTLS.SSLContext,Ptr{UInt8},UInt64}"><code>MbedTLS.ssl_unsafe_write</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Copy <code>nbytes</code> from <code>buf</code> to <code>ctx</code>.</p><p>The TLS library function <code>ssl_write</code> is called as many times as needed to send all the data. The TLS library encrypts the data and passes it to the <code>f_send</code> function which sends it to the underlying connection (<code>ctx.bio</code>). See <code>f_send</code> and <code>set_bio!</code> below.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.ssl_write-Tuple{MbedTLS.SSLContext,Any,Any}" href="#MbedTLS.ssl_write-Tuple{MbedTLS.SSLContext,Any,Any}"><code>MbedTLS.ssl_write</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ssl_write(::SSLContext, ptr, n)</code></pre><p>When this function returns MBEDTLS<em>ERR</em>SSL<em>WANT</em>WRITE/READ, it must be called later with the same arguments, until it returns a value greater that or equal to 0. When the function returns MBEDTLS<em>ERR</em>SSL<em>WANT</em>WRITE there may be some partial data in the output buffer, however this is not yet sent.</p><p>If this function returns something other than 0, a positive value or MBEDTLS<em>ERR</em>SSL<em>WANT</em>READ/WRITE, you must stop using the SSL context for reading or writing, and either free it or call mbedtls<em>ssl</em>session_reset() on it before re-using it for a new connection; the current connection must be closed.</p><p>https://tls.mbed.org/api/ssl_8h.html#a5bbda87d484de82df730758b475f32e5</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.update!-Tuple{Cipher,Any,Any}" href="#MbedTLS.update!-Tuple{Cipher,Any,Any}"><code>MbedTLS.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>update!(cipher::Cipher, buf_in, buf_out::Vector{UInt8}) -&gt; Int</code></p><p>Run the given cipher on <code>buf_in</code> (a String or <code>Vector{UInt8}</code>) and store the result of the cipher in <code>buf_out</code> (a <code>Vector{UInt8}</code>).</p><p>It is your responsibility to ensure that <code>buf_out</code> is at least as large as necessary to hold the result. It should be at least as big as the size of <code>buf_in</code> plus the block size associated with <code>cipher</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MbedTLS.wait_for_decrypted_data-Tuple{Any}" href="#MbedTLS.wait_for_decrypted_data-Tuple{Any}"><code>MbedTLS.wait_for_decrypted_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>While there are no decrypted bytes available but the connection is readable:</p><ul><li>If the TLS buffer has no pending (unprocessed) data wait for more encrypted data to arrive on the underlying connection.</li><li>Run a zero-byte read to allow the library to process its internal buffer, and/or read from the underlying connection.</li><li><code>ssl_unsafe_read</code> updates the <code>isreadable</code> and <code>bytesavailable</code> state.</li></ul></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
