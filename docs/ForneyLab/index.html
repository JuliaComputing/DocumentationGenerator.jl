<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ ForneyLab.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ForneyLab.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Addition" href="#ForneyLab.Addition"><code>ForneyLab.Addition</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">An addition constraint factor node

f(out,in1,in2) = Œ¥(in1 + in2 - out)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1
3. in2</code></pre><p>Construction:</p><pre><code class="language-none">Addition(out, in1, in2, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Bernoulli" href="#ForneyLab.Bernoulli"><code>ForneyLab.Bernoulli</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Bernoulli factor node</p><pre><code class="language-none">out ‚àà {0, 1}
p ‚àà [0, 1]

f(out, p) = Ber(out|p) = p^out (1 - p)^{1 - out}</code></pre><p>Interfaces:     1. out     2. p</p><p>Construction:     Bernoulli(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Beta" href="#ForneyLab.Beta"><code>ForneyLab.Beta</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Beta factor node</p><pre><code class="language-none">Real scalars
a &gt; 0
b &gt; 0

f(out, a, b) = Beta(out|a, b) = Œì(a + b)/(Œì(a) Œì(b)) out^{a - 1} (1 - out)^{b - 1}</code></pre><p>Interfaces:     1. out     2. a     3. b</p><p>Construction:     Beta(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Categorical" href="#ForneyLab.Categorical"><code>ForneyLab.Categorical</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Categorical factor node</p><pre><code class="language-none">The categorical node defines a one-dimensional probability
distribution over the normal basis vectors of dimension d

out ‚àà {0, 1}^d where Œ£_k out_k = 1
p ‚àà [0, 1]^d, where Œ£_k p_k = 1

f(out, p) = Cat(out | p)
          = Œ†_i p_i^{out_i}</code></pre><p>Interfaces:     1. out     2. p</p><p>Construction:     Categorical(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Clamp" href="#ForneyLab.Clamp"><code>ForneyLab.Clamp</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A factor that clamps a variable to a constant value.

f(out) = Œ¥(out - value)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out</code></pre><p>Construction:</p><pre><code class="language-none">Clamp(out, value, id=:some_id)
Clamp(value, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Contingency" href="#ForneyLab.Contingency"><code>ForneyLab.Contingency</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Contingency factor node</p><pre><code class="language-none">The contingency distribution is a multivariate generalization of
the categorical distribution. As a bivariate distribution, the
contingency distribution defines the joint probability
over two unit vectors. The parameter p encodes a contingency matrix
that specifies the probability of co-occurrence.

out1 ‚àà {0, 1}^d1 where Œ£_j out1_j = 1
out2 ‚àà {0, 1}^d2 where Œ£_k out2_k = 1
p ‚àà [0, 1]^{d1 √ó d2}, where Œ£_jk p_jk = 1

f(out1, out2, p) = Con(out1, out2 | p)
                 = Œ†_jk p_jk^{out1_j * out2_k}

A Contingency distribution over more than two variables requires
higher-order tensors as parameters; these are not implemented in ForneyLab.</code></pre><p>Interfaces:     1. out1     2. out2     3. p</p><p>Construction:     Contingency(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Dirichlet" href="#ForneyLab.Dirichlet"><code>ForneyLab.Dirichlet</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Dirichlet factor node</p><pre><code class="language-none">Real vector
a .&gt; 0

Multivariate:
f(out, a) = Dir(out|a)
          = Œì(Œ£_i a_i)/(Œ†_i Œì(a_i)) Œ†_i out_i^{a_i}

Matrix variate with independent rows:
f(out, a) = Œ†_j Dir(out|a_j.)
          = Œ†_j Œì(Œ£_k a_jk)/(Œ†_k Œì(a_jk)) Œ†_k out_jk^{a_jk}</code></pre><p>Interfaces:     1. out     2. a</p><p>Construction:     Dirichlet(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.DotProduct" href="#ForneyLab.DotProduct"><code>ForneyLab.DotProduct</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">out = in1&#39;*in2

in1: d-dimensional vector
in2: d-dimensional vector
out: scalar

       in2
       |
  in1  V   out
-----&gt;[‚ãÖ]-----&gt;

f(out, in1, in2) =  Œ¥(out - in1&#39;*in2)</code></pre><p>Interfaces:</p><pre><code class="language-none">1 i[:out], 2 i[:in1], 3 i[:in2]</code></pre><p>Construction:</p><pre><code class="language-none">DotProduct(out, in1, in2, id=:my_node)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Edge" href="#ForneyLab.Edge"><code>ForneyLab.Edge</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>An Edge joins two interfaces (half-edges) <code>a</code> and <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Equality" href="#ForneyLab.Equality"><code>ForneyLab.Equality</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">An equality constraint factor node

f([1],[2],[3]) = Œ¥([1] - [2]) Œ¥([1] - [3])</code></pre><p>Interfaces:</p><pre><code class="language-none">1, 2, 3</code></pre><p>Construction:</p><pre><code class="language-none">Equality(id=:some_id)

The interfaces of an Equality node have to be connected manually.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Exponential" href="#ForneyLab.Exponential"><code>ForneyLab.Exponential</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">Maps a location to a scale parameter by exponentiation

f(out,in1) = Œ¥(out - exp(in1))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1</code></pre><p>Construction:</p><pre><code class="language-none">Exponential(out, in1, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.FactorGraph" href="#ForneyLab.FactorGraph"><code>ForneyLab.FactorGraph</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A factor graph consisting of factor nodes and edges.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Gamma" href="#ForneyLab.Gamma"><code>ForneyLab.Gamma</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A gamma node with shape-rate parameterization:

f(out,a,b) = Gam(out|a,b) = 1/Œì(a) b^a out^{a - 1} exp(-b out)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. a (shape)
3. b (rate)</code></pre><p>Construction:</p><pre><code class="language-none">Gamma(out, a, b, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.GaussianMeanPrecision" href="#ForneyLab.GaussianMeanPrecision"><code>ForneyLab.GaussianMeanPrecision</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A Gaussian with mean-precision parameterization:

f(out,m,w) = ùí©(out|m,w) = (2œÄ)^{-D/2} |w|^{1/2} exp(-1/2 (out - m)&#39; w (out - m))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. m (mean)
3. w (precision)</code></pre><p>Construction:</p><pre><code class="language-none">GaussianMeanPrecision(out, m, w, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.GaussianMeanVariance" href="#ForneyLab.GaussianMeanVariance"><code>ForneyLab.GaussianMeanVariance</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A Gaussian with mean-variance parameterization:

f(out,m,v) = ùí©(out|m,v) = (2œÄ)^{-D/2} |v|^{-1/2} exp(-1/2 (out - m)&#39; v^{-1} (out - m))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. m (mean)
3. v (covariance)</code></pre><p>Construction:</p><pre><code class="language-none">GaussianMeanVariance(out, m, v, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.GaussianMixture" href="#ForneyLab.GaussianMixture"><code>ForneyLab.GaussianMixture</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A Gaussian mixture with mean-precision parameterization:

f(out, z, m1, w1, m2, w2, ...) = ùí©(out|m1, w1)^z_1 * ùí©(out|m2, w2)^z_2 * ...</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. z (switch)
3. m1 (mean)
4. w1 (precision)
5. m2 (mean)
6. w2 (precision)
...</code></pre><p>Construction:</p><pre><code class="language-none">GaussianMixture(out, z, m1, w1, m2, w2, ..., id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Interface" href="#ForneyLab.Interface"><code>ForneyLab.Interface</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>An Interface belongs to a FactorNode and represents a half-edge. An Interface has at most one partner interface, with wich it forms an edge.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.LogNormal" href="#ForneyLab.LogNormal"><code>ForneyLab.LogNormal</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A log-normal node with location-scale parameterization:

f(out,m,s) = logN(out|m, s) = 1/out (2œÄ s)^{-1/2} exp(-1/(2s) (log(out) - m)^2))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. m (location)
3. s (squared scale)</code></pre><p>Construction:</p><pre><code class="language-none">LogNormal(out, m, s, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MarginalRule" href="#ForneyLab.MarginalRule"><code>ForneyLab.MarginalRule</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>MarginalRule{factor<em>type} specifies a joint marginal update rule with respect to a node of type `factor</em>type`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MarginalScheduleEntry" href="#ForneyLab.MarginalScheduleEntry"><code>ForneyLab.MarginalScheduleEntry</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A <code>MarginalScheduleEntry</code> defines a marginal computation. The <code>marginal_update_rule &lt;: MarginalUpdateRule</code> defines the rule that is used to calculate the (joint) marginal over <code>target</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MarginalScheduleEntry-Tuple{ForneyLab.Cluster,Dict{Interface,Type}}" href="#ForneyLab.MarginalScheduleEntry-Tuple{ForneyLab.Cluster,Dict{Interface,Type}}"><code>ForneyLab.MarginalScheduleEntry</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct a MarginalScheduleEntry for computing the marginal over <code>cluster</code> through a node-specific joint marginal update rule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MarginalScheduleEntry-Tuple{Variable}" href="#ForneyLab.MarginalScheduleEntry-Tuple{Variable}"><code>ForneyLab.MarginalScheduleEntry</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct a MarginalScheduleEntry for computing the marginal over <code>variable</code> through multiplication of colliding messages.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MarginalUpdateRule" href="#ForneyLab.MarginalUpdateRule"><code>ForneyLab.MarginalUpdateRule</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A MarginalUpdateRule specifies how a (joint) marginal is calculated from incoming messages (and a node function).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Message" href="#ForneyLab.Message"><code>ForneyLab.Message</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Encodes a message, which is a probability distribution with a scaling factor</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MessageUpdateRule" href="#ForneyLab.MessageUpdateRule"><code>ForneyLab.MessageUpdateRule</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A MessageUpdateRule specifies how a Message is calculated from the node function and the incoming messages. Use <code>subtypes(MessageUpdateRule)</code> to list the available rules.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Multiplication" href="#ForneyLab.Multiplication"><code>ForneyLab.Multiplication</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">For continuous random variables, the multiplication node acts
as a (matrix) multiplication constraint, with node function

f(out, in1, a) = Œ¥(out - a*in1)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1
3. a</code></pre><p>Construction:</p><pre><code class="language-none">Multiplication(out, in1, a, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Nonlinear" href="#ForneyLab.Nonlinear"><code>ForneyLab.Nonlinear</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">Nonlinear node modeling a nonlinear relation. Updates for
the nonlinear node are computed through local linearization.

f(out, in1) = Œ¥(out - g(in1))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1</code></pre><p>Construction:</p><pre><code class="language-none">Nonlinear(out, in1, g::Function, J_g::Function, id=:my_node)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.PointMass" href="#ForneyLab.PointMass"><code>ForneyLab.PointMass</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>PointMass is an abstract type used to describe point mass distributions. It never occurs in a FactorGraph, but it is used as a probability distribution type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.ProbabilityDistribution" href="#ForneyLab.ProbabilityDistribution"><code>ForneyLab.ProbabilityDistribution</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Encodes a probability distribution as a FactorNode of type <code>family</code> with fixed interfaces</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.RecognitionFactor" href="#ForneyLab.RecognitionFactor"><code>ForneyLab.RecognitionFactor</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A RecognitionFactor specifies the subset of variables that comprise a joint factor in the recognition factorization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.RecognitionFactorization" href="#ForneyLab.RecognitionFactorization"><code>ForneyLab.RecognitionFactorization</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A RecognitionFactorization holds a collection of (non-overlapping) recognition factors that specify the recognition factorization over a factor graph that is used for variational inference.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.RecognitionFactorization-Tuple" href="#ForneyLab.RecognitionFactorization-Tuple"><code>ForneyLab.RecognitionFactorization</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct a RecognitionFactorization consisting of one RecognitionFactor for each argument</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.ScheduleEntry" href="#ForneyLab.ScheduleEntry"><code>ForneyLab.ScheduleEntry</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A <code>ScheduleEntry</code> defines a message computation. The <code>msg_update_rule &lt;: MessageUpdateRule</code> defines the rule that is used to calculate the message coming out of <code>interface</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Sigmoid" href="#ForneyLab.Sigmoid"><code>ForneyLab.Sigmoid</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Constrains a continuous, real-valued variable with a binary (boolean) variable.</p><pre><code class="language-none">f(bin, real) = œÉ(bin‚ãÖreal)</code></pre><p>Interfaces:     1. bin     2. real</p><p>Construction:     Sigmoid(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Terminal" href="#ForneyLab.Terminal"><code>ForneyLab.Terminal</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">Terminal is a special type of node that is only used in the internal
graph of a CompositeNode. A Terminal is used to terminate an Edge in the
internal graph that is linked to an interface of the CompositeNode.

A Terminal is linked to an interface of the
CompositeNode containing the Terminal.</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out</code></pre><p>Construction:</p><pre><code class="language-none">Terminal(id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Transition" href="#ForneyLab.Transition"><code>ForneyLab.Transition</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">The transition node models a transition between discrete
random variables, with node function

f(out, in1, a) = Cat(out | a*in1)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1
3. a</code></pre><p>Construction:</p><pre><code class="language-none">Transition(out, in1, a, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Variable" href="#ForneyLab.Variable"><code>ForneyLab.Variable</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A Variable encompasses one or more edges in a FactorGraph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Wishart" href="#ForneyLab.Wishart"><code>ForneyLab.Wishart</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A Wishart node:

f(out,v,nu) = W(out|v, nu) = B(v, nu) |out|^{(nu - D - 1)/2} exp(-1/2 tr(v^{-1} out))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. v (scale matrix)
3. nu (degrees of freedom)</code></pre><p>Construction:</p><pre><code class="language-none">Wishart(out, v, nu, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.conditionalDifferentialEntropy-Tuple{ProbabilityDistribution{Multivariate,family} where family&lt;:FactorNode,Vararg{ProbabilityDistribution,N} where N}" href="#ForneyLab.conditionalDifferentialEntropy-Tuple{ProbabilityDistribution{Multivariate,family} where family&lt;:FactorNode,Vararg{ProbabilityDistribution,N} where N}"><code>ForneyLab.conditionalDifferentialEntropy</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Compute conditional differential entropy: H(Y|X) = H(Y, X) - H(X)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.constant-Tuple{Any}" href="#ForneyLab.constant-Tuple{Any}"><code>ForneyLab.constant</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p><code>constant</code> creates a <code>Variable</code> which is linked to a new <code>Clamp</code>, and returns this variable.</p><pre><code class="language-none">y = constant(3.0, id=:y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.currentGraph-Tuple{}" href="#ForneyLab.currentGraph-Tuple{}"><code>ForneyLab.currentGraph</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return currently active FactorGraph. Create one if there is none.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.currentRecognitionFactorization-Tuple{}" href="#ForneyLab.currentRecognitionFactorization-Tuple{}"><code>ForneyLab.currentRecognitionFactorization</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return currently active RecognitionFactorization. Create one if there is none.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.edges-Tuple{Variable}" href="#ForneyLab.edges-Tuple{Variable}"><code>ForneyLab.edges</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Collect all edges corresponding with variable(s)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.expectationPropagationAlgorithm-Tuple{Array{Variable,1}}" href="#ForneyLab.expectationPropagationAlgorithm-Tuple{Array{Variable,1}}"><code>ForneyLab.expectationPropagationAlgorithm</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Create a sum-product algorithm to infer marginals over <code>variables</code>, and compile it to Julia code</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.expectationPropagationSchedule-Tuple{Array{Variable,1}}" href="#ForneyLab.expectationPropagationSchedule-Tuple{Array{Variable,1}}"><code>ForneyLab.expectationPropagationSchedule</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>expectationPropagationSchedule() generates a expectation propagation message passing schedule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.handle-Tuple{Interface}" href="#ForneyLab.handle-Tuple{Interface}"><code>ForneyLab.handle</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return interface handle name</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.marginalSchedule-Tuple{Array{Variable,1}}" href="#ForneyLab.marginalSchedule-Tuple{Array{Variable,1}}"><code>ForneyLab.marginalSchedule</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>marginalSchedule() generates a marginal schedule that computes the marginals for each target entry</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.mat-Tuple{Any}" href="#ForneyLab.mat-Tuple{Any}"><code>ForneyLab.mat</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Helper function to construct 1x1 Matrix</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.placeholder-Tuple{Variable,Symbol}" href="#ForneyLab.placeholder-Tuple{Variable,Symbol}"><code>ForneyLab.placeholder</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p><code>placeholder(...)</code> creates a <code>Clamp</code> node and registers this node as a data placeholder with the current graph.</p><pre><code class="language-none"># Link variable y to buffer with id :y,
# indicate that Clamp will hold Float64 values.
placeholder(y, :y, datatype=Float64)

# Link variable y to index 3 of buffer with id :y.
# Specify the data type by passing a default value for the Clamp.
placeholder(y, :y, index=3, default=0.0)

# Indicate that the Clamp will hold an array of size `dims`,
# with Float64 elements.
placeholder(X, :X, datatype=Float64, dims=(3,2))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.sumProductAlgorithm-Tuple{Array{Variable,1}}" href="#ForneyLab.sumProductAlgorithm-Tuple{Array{Variable,1}}"><code>ForneyLab.sumProductAlgorithm</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Create a sum-product algorithm to infer marginals over <code>variables</code>, and compile it to Julia code</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.sumProductSchedule-Tuple{Array{Variable,1}}" href="#ForneyLab.sumProductSchedule-Tuple{Array{Variable,1}}"><code>ForneyLab.sumProductSchedule</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>sumProductSchedule() generates a sum-product message passing schedule that computes the marginals for each of the argument variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.ultimatePartner-Tuple{Interface}" href="#ForneyLab.ultimatePartner-Tuple{Interface}"><code>ForneyLab.ultimatePartner</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>ultimatePartner(interface) finds the &#39;ultimate partner&#39; of interface. If interface.partner does not belong to a Terminal, it simply returns interface.partner. In case of a Terminal node, it finds the first non-Terminal partner on a higher level factor graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variationalAlgorithm-Tuple{Array{RecognitionFactor,1}}" href="#ForneyLab.variationalAlgorithm-Tuple{Array{RecognitionFactor,1}}"><code>ForneyLab.variationalAlgorithm</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Create a variational algorithm to infer marginals over a recognition distribution, and compile it to Julia code</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variationalExpectationPropagationAlgorithm-Tuple{RecognitionFactor}" href="#ForneyLab.variationalExpectationPropagationAlgorithm-Tuple{RecognitionFactor}"><code>ForneyLab.variationalExpectationPropagationAlgorithm</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Create a variational EP algorithm to infer marginals over a recognition distribution, and compile it to Julia code</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variationalExpectationPropagationSchedule-Tuple{RecognitionFactor}" href="#ForneyLab.variationalExpectationPropagationSchedule-Tuple{RecognitionFactor}"><code>ForneyLab.variationalExpectationPropagationSchedule</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>variationalExpectationPropagationSchedule() generates an expectation propagation message passing schedule that is limited to the <code>recognition_factor</code>. Updates on EP sites are computed with an <code>ExpectationPropagationRule</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variationalSchedule-Tuple{Array{RecognitionFactor,1}}" href="#ForneyLab.variationalSchedule-Tuple{Array{RecognitionFactor,1}}"><code>ForneyLab.variationalSchedule</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>variationalSchedule() generates a variational message passing schedule that computes the marginals for each of the recognition distributions in the recognition factor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Cluster" href="#ForneyLab.Cluster"><code>ForneyLab.Cluster</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A Cluster specifies a collection of <code>edges</code> adjacent to <code>node</code> that belong to the same RecognitionFactor. A joint marginal can be computed over a cluster.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.DependencyGraph" href="#ForneyLab.DependencyGraph"><code>ForneyLab.DependencyGraph</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A <code>DependencyGraph</code> is a directed graph in which an edge <code>v -&gt; w</code> represents a dependency of vertex <code>v</code> on vertex <code>w</code>. Dependency graphs are used for example by message scheduling algorithms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.addNode!-Tuple{FactorGraph,FactorNode}" href="#ForneyLab.addNode!-Tuple{FactorGraph,FactorNode}"><code>ForneyLab.addNode!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Add a FactorNode to a FactorGraph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.addVariable!-Tuple{FactorGraph,Variable}" href="#ForneyLab.addVariable!-Tuple{FactorGraph,Variable}"><code>ForneyLab.addVariable!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Add a Variable to a FactorGraph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.approximate-Tuple{Union{Float64, Array{Float64,1}},Function,Function}" href="#ForneyLab.approximate-Tuple{Union{Float64, Array{Float64,1}},Function,Function}"><code>ForneyLab.approximate</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find a local linear approximation to the nonlinear vector function g at x_hat</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.associate!-Tuple{Interface,Variable}" href="#ForneyLab.associate!-Tuple{Interface,Variable}"><code>ForneyLab.associate!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p><code>associate!(interface, variable)</code> associates <code>interface</code> with <code>variable</code> by connecting <code>interface</code> to an <code>Edge</code> belonging to <code>variable</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.breakerTypes-Tuple{Array{Interface,1}}" href="#ForneyLab.breakerTypes-Tuple{Array{Interface,1}}"><code>ForneyLab.breakerTypes</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Constructs breaker types dictionary for breaker sites</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.clusterId-Tuple{FactorNode,Edge}" href="#ForneyLab.clusterId-Tuple{FactorNode,Edge}"><code>ForneyLab.clusterId</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return the id of the cluster/variable that the node-edge combination belongs to </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectEPSites-Tuple{Set{FactorNode}}" href="#ForneyLab.collectEPSites-Tuple{Set{FactorNode}}"><code>ForneyLab.collectEPSites</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find default EP sites present in <code>node_set</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInboundTypes-Tuple{ForneyLab.Cluster,Dict{Interface,Type}}" href="#ForneyLab.collectInboundTypes-Tuple{ForneyLab.Cluster,Dict{Interface,Type}}"><code>ForneyLab.collectInboundTypes</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find the inbound types that are required to compute a joint marginal over <code>target</code>. Returns a vector with inbound types that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInboundTypes-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Type}}} where T&lt;:NaiveVariationalRule" href="#ForneyLab.collectInboundTypes-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Type}}} where T&lt;:NaiveVariationalRule"><code>ForneyLab.collectInboundTypes</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find the inbound types that are required to compute the message for <code>entry</code>. Returns a vector with inbound types that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInboundTypes-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Type}}} where T&lt;:StructuredVariationalRule" href="#ForneyLab.collectInboundTypes-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Type}}} where T&lt;:StructuredVariationalRule"><code>ForneyLab.collectInboundTypes</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find the inbound types that are required to compute the message for <code>entry</code>. Returns a vector with inbound types that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInbounds-Tuple{MarginalScheduleEntry,Dict{Interface,Int64}}" href="#ForneyLab.collectInbounds-Tuple{MarginalScheduleEntry,Dict{Interface,Int64}}"><code>ForneyLab.collectInbounds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct the inbound code that computes the marginal for <code>entry</code>. Allows for overloading and for a user the define custom node-specific inbounds collection. Returns a vector with inbounds that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInbounds-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Int64}}} where T&lt;:ExpectationPropagationRule" href="#ForneyLab.collectInbounds-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Int64}}} where T&lt;:ExpectationPropagationRule"><code>ForneyLab.collectInbounds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find the inbound types that are required to compute the message for <code>entry</code>. Returns a vector with inbound types that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInbounds-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Int64}}} where T&lt;:NaiveVariationalRule" href="#ForneyLab.collectInbounds-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Int64}}} where T&lt;:NaiveVariationalRule"><code>ForneyLab.collectInbounds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct argument code for naive VB updates</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInbounds-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Int64}}} where T&lt;:StructuredVariationalRule" href="#ForneyLab.collectInbounds-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Int64}}} where T&lt;:StructuredVariationalRule"><code>ForneyLab.collectInbounds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct argument code for structured VB updates</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInbounds-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Int64}}} where T&lt;:SumProductRule" href="#ForneyLab.collectInbounds-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Int64}}} where T&lt;:SumProductRule"><code>ForneyLab.collectInbounds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Collect and construct SP update code for each inbound.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectNaiveVariationalNodeInbounds-Tuple{FactorNode,ScheduleEntry,Dict{Interface,Int64}}" href="#ForneyLab.collectNaiveVariationalNodeInbounds-Tuple{FactorNode,ScheduleEntry,Dict{Interface,Int64}}"><code>ForneyLab.collectNaiveVariationalNodeInbounds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct the inbound code that computes the message for <code>entry</code>. Allows for overloading and for a user the define custom node-specific inbounds collection. Returns a vector with inbounds that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectStructuredVariationalNodeInbounds-Tuple{FactorNode,ScheduleEntry,Dict{Interface,Int64}}" href="#ForneyLab.collectStructuredVariationalNodeInbounds-Tuple{FactorNode,ScheduleEntry,Dict{Interface,Int64}}"><code>ForneyLab.collectStructuredVariationalNodeInbounds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct the inbound code that computes the message for <code>entry</code>. Allows for overloading and for a user the define custom node-specific inbounds collection. Returns a vector with inbounds that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectSumProductNodeInbounds-Tuple{FactorNode,ScheduleEntry,Dict{Interface,Int64}}" href="#ForneyLab.collectSumProductNodeInbounds-Tuple{FactorNode,ScheduleEntry,Dict{Interface,Int64}}"><code>ForneyLab.collectSumProductNodeInbounds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Construct the inbound code that computes the message for <code>entry</code>. Allows for overloading and for a user the define custom node-specific inbounds collection. Returns a vector with inbounds that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.condense-Tuple{Array{ScheduleEntry,1}}" href="#ForneyLab.condense-Tuple{Array{ScheduleEntry,1}}"><code>ForneyLab.condense</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Contruct a condensed schedule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.connect!-Tuple{Edge,Interface}" href="#ForneyLab.connect!-Tuple{Edge,Interface}"><code>ForneyLab.connect!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Connect loose end of edge to interface b.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.disconnect!-Tuple{Edge,Interface}" href="#ForneyLab.disconnect!-Tuple{Edge,Interface}"><code>ForneyLab.disconnect!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Disconnect edge from interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.ensureMatrix-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Number" href="#ForneyLab.ensureMatrix-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Number"><code>ForneyLab.ensureMatrix</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>ensureMatrix: cast input to a Matrix if necessary</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.extend-Tuple{Set{Edge}}" href="#ForneyLab.extend-Tuple{Set{Edge}}"><code>ForneyLab.extend</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find the smallest legal subgraph that includes the argument edges. Default setting terminates the search at soft factors and does not constrain the search to a limiting set (as specified by an empty limit_set argument).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.find_vertex_indexes-Union{Tuple{V}, Tuple{V,DependencyGraph{V}}} where V" href="#ForneyLab.find_vertex_indexes-Union{Tuple{V}, Tuple{V,DependencyGraph{V}}} where V"><code>ForneyLab.find_vertex_indexes</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>children(vertices, graph; allow<em>cycles=false, breaker</em>sites=[], restrict_to=[])</p><p>Return a vector consisting of <code>vertices</code> and all their children in <code>graph</code>. <code>v</code> is a child of <code>u</code> iff there exists a path from <code>u</code> to <code>v</code>. The resulting array is sorted in reverse topological order, i.e. for each directed edge <code>u -&gt; v</code>, <code>v</code> (child of <code>u</code>) appears before <code>u</code>.</p><p>Optional keyword arguments:</p><ul><li><code>allow_cycles</code>: set to true to accept cycles.</li><li><code>breaker_sites</code>: a Set of vertices on which the search will terminate.</li><li><code>restrict_to</code>: a Set of vertices to restrict the search to.</li></ul><p>This function can be used to generate message passing schedules if <code>graph</code> is a dependency graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.flatten-Tuple{Array{ScheduleEntry,1}}" href="#ForneyLab.flatten-Tuple{Array{ScheduleEntry,1}}"><code>ForneyLab.flatten</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Flatten a schedule by inlining all internal message passing schedules. This yields a simple, linear schedule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.generateId-Tuple{Type}" href="#ForneyLab.generateId-Tuple{Type}"><code>ForneyLab.generateId</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Automatically generate a unique id based on the current counter value for the element type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.hasCollider-Tuple{RecognitionFactor}" href="#ForneyLab.hasCollider-Tuple{RecognitionFactor}"><code>ForneyLab.hasCollider</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return whether the subgraph contains a collider. If a collider is found, this will lead to conditional dependencies in the recognition distribution (posterior).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.hasCollider-Tuple{Set{Edge}}" href="#ForneyLab.hasCollider-Tuple{Set{Edge}}"><code>ForneyLab.hasCollider</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return whether connected<em>cluster contains a collider. This function assumes the graph for connected</em>cluster is a connected tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.hasNode-Tuple{FactorGraph,FactorNode}" href="#ForneyLab.hasNode-Tuple{FactorGraph,FactorNode}"><code>ForneyLab.hasNode</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p><code>hasNode(graph, node)</code> checks if <code>node</code> is part of <code>graph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.hasVariable-Tuple{FactorGraph,Variable}" href="#ForneyLab.hasVariable-Tuple{FactorGraph,Variable}"><code>ForneyLab.hasVariable</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p><code>hasVariable(graph, var)</code> checks if <code>var</code> is part of <code>graph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.inferMarginalRule-Tuple{ForneyLab.Cluster,Array{#s35,1} where #s35&lt;:Type}" href="#ForneyLab.inferMarginalRule-Tuple{ForneyLab.Cluster,Array{#s35,1} where #s35&lt;:Type}"><code>ForneyLab.inferMarginalRule</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Infer the rule that computes the joint marginal over <code>cluster</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.inferUpdateRule!-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Type}}} where T&lt;:NaiveVariationalRule" href="#ForneyLab.inferUpdateRule!-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Type}}} where T&lt;:NaiveVariationalRule"><code>ForneyLab.inferUpdateRule!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Infer the update rule that computes the message for <code>entry</code>, as dependent on the inbound types</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.inferUpdateRule!-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Type}}} where T&lt;:StructuredVariationalRule" href="#ForneyLab.inferUpdateRule!-Union{Tuple{T}, Tuple{ScheduleEntry,Type{T},Dict{Interface,Type}}} where T&lt;:StructuredVariationalRule"><code>ForneyLab.inferUpdateRule!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Infer the update rule that computes the message for <code>entry</code>, as dependent on the inbound types</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.inferUpdateRules!-Tuple{Array{ScheduleEntry,1}}" href="#ForneyLab.inferUpdateRules!-Tuple{Array{ScheduleEntry,1}}"><code>ForneyLab.inferUpdateRules!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>inferUpdateRules!(schedule) infers specific message update rules for all schedule entries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.interfaceToScheduleEntryIdx-Tuple{Array{ScheduleEntry,1}}" href="#ForneyLab.interfaceToScheduleEntryIdx-Tuple{Array{ScheduleEntry,1}}"><code>ForneyLab.interfaceToScheduleEntryIdx</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Generate a mapping from interface to schedule entry index. Multiple interfaces can map to the same schedule entry if the graph contains composite nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.internalSumProductSchedule-Tuple{CompositeNode,Interface,Dict{Interface,#s33} where #s33&lt;:Type}" href="#ForneyLab.internalSumProductSchedule-Tuple{CompositeNode,Interface,Dict{Interface,#s33} where #s33&lt;:Type}"><code>ForneyLab.internalSumProductSchedule</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>internalSumProductSchedule() generates a sum-product message passing schedule for the inner graph of a CompositeNode. This schedule produces the sum-product message out of the specified outbound_interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.isApproxEqual-Tuple{Any,Any}" href="#ForneyLab.isApproxEqual-Tuple{Any,Any}"><code>ForneyLab.isApproxEqual</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>isApproxEqual: check approximate equality</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.isRoundedPosDef-Tuple{AbstractArray{Float64,2}}" href="#ForneyLab.isRoundedPosDef-Tuple{AbstractArray{Float64,2}}"><code>ForneyLab.isRoundedPosDef</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>isRoundedPosDef: is input matrix positive definite? Round to prevent fp precision problems that isposdef() suffers from.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.isValid-Tuple{ProbabilityDistribution,Symbol}" href="#ForneyLab.isValid-Tuple{ProbabilityDistribution,Symbol}"><code>ForneyLab.isValid</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>isValid: return true if the parameter field exists and (the first element of) the parameter is not NaN</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.laplace-Tuple{Type{Gamma},ProbabilityDistribution{Univariate,LogNormal}}" href="#ForneyLab.laplace-Tuple{Type{Gamma},ProbabilityDistribution{Univariate,LogNormal}}"><code>ForneyLab.laplace</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Gamma approximation to the log-normal distribution using Laplace&#39;s method</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.leaftypes-Tuple{Type}" href="#ForneyLab.leaftypes-Tuple{Type}"><code>ForneyLab.leaftypes</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p><code>leaftypes(datatype)</code> returns all subtypes of <code>datatype</code> that are leafs in the type tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.localClusterIds-Tuple{FactorNode}" href="#ForneyLab.localClusterIds-Tuple{FactorNode}"><code>ForneyLab.localClusterIds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return the ids of the clusters/variables to which edges connected to <code>node</code> belong</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.localRecognitionFactorIds-Tuple{FactorNode}" href="#ForneyLab.localRecognitionFactorIds-Tuple{FactorNode}"><code>ForneyLab.localRecognitionFactorIds</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return the ids of the recognition factors to which edges connected to <code>node</code> belong</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.localRecognitionFactorization-Tuple{FactorNode}" href="#ForneyLab.localRecognitionFactorization-Tuple{FactorNode}"><code>ForneyLab.localRecognitionFactorization</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return a dictionary from recognition factor-id to variable/cluster-ids local to node</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.mapToBernoulliParameterRange-Tuple{Any}" href="#ForneyLab.mapToBernoulliParameterRange-Tuple{Any}"><code>ForneyLab.mapToBernoulliParameterRange</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Map <code>m</code> to range of Bernoulli parameter <code>p</code> ‚àà [0, 1]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.marginalString-Union{Tuple{Clamp{T}}, Tuple{T}} where T&lt;:ForneyLab.VariateType" href="#ForneyLab.marginalString-Union{Tuple{Clamp{T}}, Tuple{T}} where T&lt;:ForneyLab.VariateType"><code>ForneyLab.marginalString</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Depending on the origin of the Clamp node message, contruct the marginal code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.matches-Union{Tuple{T}, Tuple{Type{T},Type{T}}} where T&lt;:Message" href="#ForneyLab.matches-Union{Tuple{T}, Tuple{Type{T},Type{T}}} where T&lt;:Message"><code>ForneyLab.matches</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Special inheritance rules for parametric Message types</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.messageString-Union{Tuple{Clamp{T}}, Tuple{T}} where T&lt;:ForneyLab.VariateType" href="#ForneyLab.messageString-Union{Tuple{Clamp{T}}, Tuple{T}} where T&lt;:ForneyLab.VariateType"><code>ForneyLab.messageString</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Depending on the origin of the Clamp node message, contruct the outbound message code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.nodesConnectedToExternalEdges-Tuple{RecognitionFactor}" href="#ForneyLab.nodesConnectedToExternalEdges-Tuple{RecognitionFactor}"><code>ForneyLab.nodesConnectedToExternalEdges</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find the nodes in <code>recognition_factor</code> that are connected to external edges</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.nodesConnectedToExternalEdges-Tuple{Set{Edge}}" href="#ForneyLab.nodesConnectedToExternalEdges-Tuple{Set{Edge}}"><code>ForneyLab.nodesConnectedToExternalEdges</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Find the nodes connected to <code>internal_edges</code> that are also connected to external edges</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.pack-Tuple{Any}" href="#ForneyLab.pack-Tuple{Any}"><code>ForneyLab.pack</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>This function ensures the argument expression is evaluated at runtime, allowing access to local variables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.recognitionFactorId-Tuple{Edge}" href="#ForneyLab.recognitionFactorId-Tuple{Edge}"><code>ForneyLab.recognitionFactorId</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Return the id of the RecognitionFactor that <code>edge</code> belongs to</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.summaryDependencyGraph-Tuple{Set{Edge}}" href="#ForneyLab.summaryDependencyGraph-Tuple{Set{Edge}}"><code>ForneyLab.summaryDependencyGraph</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>summaryDependencyGraph(edgeset)</p><p>Returns a DependencyGraph (directed graph) that encodes the dependencies among summary messages (such as sum-product messages) in <code>edgeset</code>. All Interfaces in <code>edgeset</code> are vertices in the dependency graph. The dependency graph can be used for loop detection, scheduling, etc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.summaryPropagationSchedule-Tuple{Array{Variable,1}}" href="#ForneyLab.summaryPropagationSchedule-Tuple{Array{Variable,1}}"><code>ForneyLab.summaryPropagationSchedule</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p><code>summaryPropagationSchedule(variables)</code> builds a generic summary propagation <code>Schedule</code> for calculating the marginal distributions of every variable in <code>variables</code>. The message update rule in each schedule entry is set to <code>Nothing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.trigammaInverse-Tuple{Float64}" href="#ForneyLab.trigammaInverse-Tuple{Float64}"><code>ForneyLab.trigammaInverse</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>trigammaInverse(x): solve <code>trigamma(y) = x</code> for <code>y</code>.</p><p>Uses Newton&#39;s method on the convex function 1/trigramma(y). Iterations converge monotonically. Based on trigammaInverse implementation in R package &quot;limma&quot; by Gordon Smyth: https://github.com/Bioconductor-mirror/limma/blob/master/R/fitFDist.R</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variateType-Union{Tuple{ProbabilityDistribution{V,F}}, Tuple{F}, Tuple{V}} where F&lt;:FactorNode where V&lt;:ForneyLab.VariateType" href="#ForneyLab.variateType-Union{Tuple{ProbabilityDistribution{V,F}}, Tuple{F}, Tuple{V}} where F&lt;:FactorNode where V&lt;:ForneyLab.VariateType"><code>ForneyLab.variateType</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Extract VariateType from dist</p></div></div></section><footer><hr/></footer></article></body></html>
