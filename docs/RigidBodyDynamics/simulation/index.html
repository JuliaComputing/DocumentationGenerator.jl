<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulation · RigidBodyDynamics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RigidBodyDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../quickstart/">Quick start guide</a></li><li><a class="toctext" href="../spatial/">Spatial vector algebra</a></li><li><a class="toctext" href="../joints/">Joints</a></li><li><a class="toctext" href="../rigidbody/">Rigid bodies</a></li><li><a class="toctext" href="../mechanism/">Mechanism</a></li><li><a class="toctext" href="../mechanismstate/">MechanismState</a></li><li><a class="toctext" href="../algorithms/">Kinematics/dynamics algorithms</a></li><li><a class="toctext" href="../customcollections/">Custom collection types</a></li><li><a class="toctext" href="../caches/">Cache types</a></li><li class="current"><a class="toctext" href>Simulation</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Basic-simulation-1">Basic simulation</a></li><li><a class="toctext" href="#Lower-level-ODE-integration-interface-1">Lower level ODE integration interface</a></li></ul></li><li><a class="toctext" href="../urdf/">URDF parsing and writing</a></li><li><a class="toctext" href="../benchmarks/">Benchmarks</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Simulation</a></li></ul></nav><hr/><div id="topbar"><span>Simulation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Simulation-1" href="#Simulation-1">Simulation</a></h1><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#RigidBodyDynamics.OdeIntegrators.ButcherTableau"><code>RigidBodyDynamics.OdeIntegrators.ButcherTableau</code></a></li><li><a href="#RigidBodyDynamics.OdeIntegrators.ExpandingStorage"><code>RigidBodyDynamics.OdeIntegrators.ExpandingStorage</code></a></li><li><a href="#RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator"><code>RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator</code></a></li><li><a href="#RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator-Union{Tuple{L}, Tuple{X}, Tuple{S}, Tuple{F}, Tuple{T}, Tuple{N}, Tuple{X,F,ButcherTableau{N,T,L},S}} where L where X where S&lt;:OdeResultsSink where F where T where N"><code>RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator</code></a></li><li><a href="#RigidBodyDynamics.OdeIntegrators.OdeResultsSink"><code>RigidBodyDynamics.OdeIntegrators.OdeResultsSink</code></a></li><li><a href="#RigidBodyDynamics.OdeIntegrators.RingBufferStorage"><code>RigidBodyDynamics.OdeIntegrators.RingBufferStorage</code></a></li><li><a href="#RigidBodyDynamics.OdeIntegrators.integrate-Tuple{MuntheKaasIntegrator,Any,Any}"><code>RigidBodyDynamics.OdeIntegrators.integrate</code></a></li><li><a href="#RigidBodyDynamics.OdeIntegrators.runge_kutta_4-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>RigidBodyDynamics.OdeIntegrators.runge_kutta_4</code></a></li><li><a href="#RigidBodyDynamics.OdeIntegrators.step-Tuple{MuntheKaasIntegrator,Real,Real}"><code>RigidBodyDynamics.OdeIntegrators.step</code></a></li><li><a href="#RigidBodyDynamics.simulate"><code>RigidBodyDynamics.simulate</code></a></li></ul><h2><a class="nav-anchor" id="Basic-simulation-1" href="#Basic-simulation-1">Basic simulation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.simulate" href="#RigidBodyDynamics.simulate"><code>RigidBodyDynamics.simulate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate(state0, final_time)
simulate(state0, final_time, control!; Δt, stabilization_gains)
</code></pre><p>Basic <code>Mechanism</code> simulation: integrate the state from time <span>$0$</span> to <code>final_time</code> starting from the initial state <code>state0</code>. Return a <code>Vector</code> of times, as well as <code>Vector</code>s of configuration vectors and velocity vectors at these times.</p><p>Optionally, a function (or other callable) can be passed in as the third argument (<code>control!</code>). <code>control!</code> will be called at each time step of the simulation and allows you to specify joint torques given the time and the state of the <code>Mechanism</code>. It should look like this:</p><pre><code class="language-julia">function control!(torques::AbstractVector, t, state::MechanismState)
    rand!(torques) # for example
end</code></pre><p>The integration time step can be specified using the <code>Δt</code> keyword argument (defaults to <code>1e-4</code>).</p><p>The <code>stabilization_gains</code> keyword argument can be used to set PD gains for Baumgarte stabilization, which can be used to prevent separation of non-tree (loop) joints. See Featherstone (2008), section 8.3 for more information. There are several options for specifying gains:</p><ul><li><code>nothing</code> can be used to completely disable Baumgarte stabilization.</li><li>Gains can be specifed on a per-joint basis using any <code>AbstractDict{JointID, &lt;:RigidBodyDynamics.PDControl.SE3PDGains}</code>, which maps the <code>JointID</code> for the non-tree joints of the mechanism to the gains for that joint.</li><li>As a special case of the second option, the same gains can be used for all joints by passing in a <code>RigidBodyDynamics.CustomCollections.ConstDict{JointID}</code>.</li></ul><p>The <a href="../algorithms/#RigidBodyDynamics.default_constraint_stabilization_gains-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>default_constraint_stabilization_gains</code></a> function is called to produce the default gains, which use the last option.</p><p>Uses <code>MuntheKaasIntegrator</code>. See <a href="#RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator"><code>RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator</code></a> for a lower level interface with more options.</p></div></div></section><h2><a class="nav-anchor" id="Lower-level-ODE-integration-interface-1" href="#Lower-level-ODE-integration-interface-1">Lower level ODE integration interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator" href="#RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator"><code>RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct MuntheKaasIntegrator{N, T, F, S&lt;:OdeResultsSink, X, L, M&lt;:(RigidBodyDynamics.OdeIntegrators.MuntheKaasStageCache{N,T,Q,V,S} where S&lt;:(AbstractArray{T,1} where T) where V&lt;:(AbstractArray{T,1} where T) where Q&lt;:(AbstractArray{T,1} where T))}</code></pre><p>A Lie-group-aware ODE integrator.</p><p><code>MuntheKaasIntegrator</code> is used to properly integrate the dynamics of globally parameterized rigid joints (Duindam, Port-Based Modeling and Control for Efficient Bipedal Walking Robots, 2006, Definition 2.9). Global parameterizations of e.g. <span>$SO(3)$</span> are needed to avoid singularities, but this leads to the problem that the tangent space no longer has the same dimension as the ambient space of the global parameterization. A Munthe-Kaas integrator solves this problem by converting back and forth between local and global coordinates at every integration time step.</p><p>The idea is to do the dynamics and compute the stages of the integration scheme in terms of local coordinates centered around the global parameterization of the configuration at the end of the previous time step (e.g. exponential coordinates), combine the stages into a new set of local coordinates as usual for Runge-Kutta methods, and then convert the local coordinates back to global coordinates.</p><p>From <a href="https://hal.archives-ouvertes.fr/hal-01328729">Iserles et al., &#39;Lie-group methods&#39; (2000)</a>.</p><p>Another useful reference is <a href="http://www.ent.mrt.ac.lk/iml/paperbase/TRO%20Collection/TRO/2005/october/7.pdf">Park and Chung, &#39;Geometric Integration on Euclidean Group with Application to Articulated Multibody Systems&#39; (2005)</a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator-Union{Tuple{L}, Tuple{X}, Tuple{S}, Tuple{F}, Tuple{T}, Tuple{N}, Tuple{X,F,ButcherTableau{N,T,L},S}} where L where X where S&lt;:OdeResultsSink where F where T where N" href="#RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator-Union{Tuple{L}, Tuple{X}, Tuple{S}, Tuple{F}, Tuple{T}, Tuple{N}, Tuple{X,F,ButcherTableau{N,T,L},S}} where L where X where S&lt;:OdeResultsSink where F where T where N"><code>RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MuntheKaasIntegrator(state, dynamics!, tableau, sink)
</code></pre><p>Create a <code>MuntheKaasIntegrator</code> given:</p><ul><li>a callable <code>dynamics!(vd, t, state)</code> that updates the joint acceleration vector <code>vd</code> at time <code>t</code> and in state <code>state</code>;</li><li>a <a href="#RigidBodyDynamics.OdeIntegrators.ButcherTableau"><code>ButcherTableau</code></a> <code>tableau</code>, specifying the integrator coefficients;</li><li>an <a href="#RigidBodyDynamics.OdeIntegrators.OdeResultsSink"><code>OdeResultsSink</code></a> <code>sink</code> which processes the results of the integration procedure at each time step.</li></ul><p><code>state</code> must be of a type for which the following functions are defined:</p><ul><li><code>configuration(state)</code>, returns the configuration vector in global coordinates;</li><li><code>velocity(state)</code>, returns the velocity vector;</li><li><code>additional_state(state)</code>, returns the vector of additional states;</li><li><code>set_velocity!(state, v)</code>, sets velocity vector to <code>v</code>;</li><li><code>set_additional_state!(state, s)</code>, sets vector of additional states to <code>s</code>;</li><li><code>global_coordinates!(state, q0, ϕ)</code>, sets global coordinates in state based on local coordinates <code>ϕ</code> centered around global coordinates <code>q0</code>;</li><li><code>local_coordinates!(ϕ, ϕd, state, q0)</code>, converts state&#39;s global configuration <code>q</code> and velocity <code>v</code> to local coordinates centered around global coordinates <code>q0</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.ButcherTableau" href="#RigidBodyDynamics.OdeIntegrators.ButcherTableau"><code>RigidBodyDynamics.OdeIntegrators.ButcherTableau</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ButcherTableau{N, T, L}</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods">Butcher tableau</a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.OdeResultsSink" href="#RigidBodyDynamics.OdeIntegrators.OdeResultsSink"><code>RigidBodyDynamics.OdeIntegrators.OdeResultsSink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type OdeResultsSink</code></pre><p>Does &#39;something&#39; with the results of an ODE integration (e.g. storing results, visualizing, etc.). Subtypes must implement:</p><ul><li><code>initialize(sink, state)</code>: called with the initial state when integration begins.</li><li><code>process(sink, t, state)</code>: called at every integration time step with the current state and time.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.RingBufferStorage" href="#RigidBodyDynamics.OdeIntegrators.RingBufferStorage"><code>RigidBodyDynamics.OdeIntegrators.RingBufferStorage</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct RingBufferStorage{T, Q&lt;:(AbstractArray{T,1} where T), V&lt;:(AbstractArray{T,1} where T)} &lt;: OdeResultsSink</code></pre><p>An <code>OdeResultsSink</code> that stores the state at each integration time step in a ring buffer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.ExpandingStorage" href="#RigidBodyDynamics.OdeIntegrators.ExpandingStorage"><code>RigidBodyDynamics.OdeIntegrators.ExpandingStorage</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct ExpandingStorage{T, Q&lt;:(AbstractArray{T,1} where T), V&lt;:(AbstractArray{T,1} where T)} &lt;: OdeResultsSink</code></pre><p>An <code>OdeResultsSink</code> that stores the state at each integration time step in <code>Vectors</code> that may expand.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.integrate-Tuple{MuntheKaasIntegrator,Any,Any}" href="#RigidBodyDynamics.OdeIntegrators.integrate-Tuple{MuntheKaasIntegrator,Any,Any}"><code>RigidBodyDynamics.OdeIntegrators.integrate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">integrate(integrator, final_time, Δt; max_realtime_rate)
</code></pre><p>Integrate dynamics from the initial state at time <span>$0$</span> to <code>final_time</code> using step size <code>Δt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.runge_kutta_4-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#RigidBodyDynamics.OdeIntegrators.runge_kutta_4-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>RigidBodyDynamics.OdeIntegrators.runge_kutta_4</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the Butcher tableau for the standard fourth order Runge-Kutta integrator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.OdeIntegrators.step-Tuple{MuntheKaasIntegrator,Real,Real}" href="#RigidBodyDynamics.OdeIntegrators.step-Tuple{MuntheKaasIntegrator,Real,Real}"><code>RigidBodyDynamics.OdeIntegrators.step</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">step(integrator, t, Δt)
</code></pre><p>Take a single integration step.</p></div></div></section><footer><hr/><a class="previous" href="../caches/"><span class="direction">Previous</span><span class="title">Cache types</span></a><a class="next" href="../urdf/"><span class="direction">Next</span><span class="title">URDF parsing and writing</span></a></footer></article></body></html>
