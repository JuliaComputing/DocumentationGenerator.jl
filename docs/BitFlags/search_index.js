var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#BitFlags.jl-1",
    "page": "Readme",
    "title": "BitFlags.jl",
    "category": "section",
    "text": "(Image: Build Status)BitFlag.jl provides an Enum-like type for bit flag option values. The main motivations are:Members have implicit numbering with incrementing powers of 2.\nBinary OR (|) and AND (&) operations are supported among members.\nValues are pretty-printed by name, with OR chains when multiple bits are set.This implementation is a relatively minor modification of Julia\'s Enum type implementation."
},

{
    "location": "#Basic-usage-1",
    "page": "Readme",
    "title": "Basic usage",
    "category": "section",
    "text": "To create a new BitFlag type, use the @bitflag macro, provide a name, an optional integer type, and a list of the member options (and optional values). A new definition can be given in inline form:@bitflag BitFlagName[::BaseType] value1[=x] value2[=y]or as a block definition:@bitflag BitFlagName[::BaseType] begin\n    value1[=x]\n    value2[=y]\nendAutomatic numbering starts at 1, but an initial flag value may be explicitly set to the value of zero. If no explicit zero-valued member is given, then 0 is not a valid value for the BitFlag. In the following example, we build an 8-bit BitFlag with no value for bit 3 (value of 4).julia> @bitflag MyStyle::UInt8 S_NONE=0 S_BOLD S_ITALIC S_LARGE=8Combinations can be made using standard binary operations:julia> S_BOLD | S_LARGE\n(S_BOLD | S_LARGE)::MyStyle = 0x09\n\njulia> ans & S_ITALIC\nS_NONE::MyStyle = 0x00Conversion to and from integers is permitted, but only for valid combinations of values:julia> Int(S_BOLD)\n1\n\njulia> Integer(S_ITALIC)    # Abstract Integer uses native UInt8 type\n0x02\n\njulia> MyStyle(9)\n(S_BOLD | S_LARGE)::MyStyle = 0x09\n\njulia> MyStyle(4)    # MyStyle does not have a flag at 4\nERROR: ArgumentError: invalid value for BitFlag MyStyle: 4\nStacktrace:\n..."
},

{
    "location": "#Printing-1",
    "page": "Readme",
    "title": "Printing",
    "category": "section",
    "text": "Each flag value is then printed with contextual information which is more user-friendly than a raw integer:julia> S_BOLD\nS_BOLD::MyStyle = 0x00000001\n\njulia> S_BOLD | S_LARGE\n(S_BOLD | S_LARGE)::MyStyle = 0x00000005In a compact context (such as in multi-dimensional arrays), the pretty-printing takes on a shorter form:julia> [S_NONE (S_BOLD | S_LARGE)]\n1Ã—2 Array{MyStyle,2}:\n S_NONE  S_BOLD|S_LARGE\n\njulia> show(IOContext(stdout, :compact => true), S_BOLD | S_LARGE)\nS_BOLD|S_LARGE"
},

{
    "location": "#Input/Output-1",
    "page": "Readme",
    "title": "Input/Output",
    "category": "section",
    "text": "BitFlags support writing to and reading from streams as integers:julia> io = IOBuffer();\n\njulia> write(io, UInt8(9));\n\njulia> seekstart(io);\n\njulia> read(io, MyStyle)\n(S_BOLD | S_LARGE)::MyStyle = 0x09"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [BitFlags]\nOrder = [:type, :function]"
},

]}
