<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · DataValues.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataValues.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataValues.DataValueArray" href="#DataValues.DataValueArray"><code>DataValues.DataValueArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DataValueArray{T, N}</code> is an efficient alternative to <code>Array{DataValue{T}, N}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataValues.dropna!-Tuple{DataValueArray{T,1} where T}" href="#DataValues.dropna!-Tuple{DataValueArray{T,1} where T}"><code>DataValues.dropna!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dropna!(X::DataValueVector)</code></pre><p>Remove missing entries of <code>X</code> in-place and return a <code>Vector</code> view of the unwrapped <code>DataValue</code> entries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataValues.dropna!-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T" href="#DataValues.dropna!-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T"><code>DataValues.dropna!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dropna!(X::AbstractVector)</code></pre><p>Remove missing entries of <code>X</code> in-place and return a <code>Vector</code> view of the unwrapped <code>DataValue</code> entries. If no missing values are present, this is a no-op and <code>X</code> is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataValues.dropna-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T" href="#DataValues.dropna-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T"><code>DataValues.dropna</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dropna(X::AbstractVector)</code></pre><p>Return a vector containing only the non-missing entries of <code>X</code>, unwrapping <code>DataValue</code> entries. A copy is always returned, even when <code>X</code> does not contain any missing values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataValues.padna!-Union{Tuple{T}, Tuple{DataValueArray{T,1},Integer,Integer}} where T" href="#DataValues.padna!-Union{Tuple{T}, Tuple{DataValueArray{T,1},Integer,Integer}} where T"><code>DataValues.padna!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">padna!(X::DataValueVector, front::Integer, back::Integer)</code></pre><p>Insert <code>front</code> null entries at the beginning of <code>X</code> and add <code>back</code> null entries at the end of <code>X</code>. Returns <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataValues.padna-Tuple{DataValueArray{T,1} where T,Integer,Integer}" href="#DataValues.padna-Tuple{DataValueArray{T,1} where T,Integer,Integer}"><code>DataValues.padna</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">padna(X::DataValueVector, front::Integer, back::Integer)</code></pre><p>return a copy of <code>X</code> with <code>front</code> null entries inserted at the beginning of the copy and <code>back</code> null entries inserted at the end.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!-Tuple{DataValueArray{T,1} where T,AbstractArray{T,1} where T}" href="#Base.append!-Tuple{DataValueArray{T,1} where T,AbstractArray{T,1} where T}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">append!(X::DataValueVector, items::AbstractVector)</code></pre><p>Add the elements of <code>items</code> to the end of <code>X</code>.</p><p>Note that <code>append!(X, [1, 2, 3])</code> is equivalent to <code>push!(X, 1, 2, 3)</code>, where the items to be added to <code>X</code> are passed individually to <code>push!</code> and as a collection to <code>append!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{Type{Array{S,N}},DataValueArray{T,N}}} where N where T where S" href="#Base.convert-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{Type{Array{S,N}},DataValueArray{T,N}}} where N where T where S"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert(T, X::DataValueArray)</code></pre><p>Convert <code>X</code> to an <code>AbstractArray</code> of type <code>T</code>. Note that if <code>X</code> contains any null entries then calling <code>convert</code> without supplying a replacement value for null entries will result in an error.</p><p>Currently supported return type arguments include: <code>Array</code>, <code>Array{T}</code>, <code>Vector</code>, <code>Matrix</code>.</p><pre><code class="language-none">convert(T, X::DataValueArray, replacement)</code></pre><p>Convert <code>X</code> to an <code>AbstractArray</code> of type <code>T</code> and replace all null entries of <code>X</code> with <code>replacement</code> in the result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Union{Tuple{DataValueArray{T,N} where N}, Tuple{T}} where T" href="#Base.copy-Union{Tuple{DataValueArray{T,N} where N}, Tuple{T}} where T"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">copy(X::DataValueArray)</code></pre><p>Return a shallow copy of <code>X</code>; the outer structure of <code>X</code> will be copied, but all elements will be identical to those of <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copyto!-Tuple{DataValueArray,DataValueArray}" href="#Base.copyto!-Tuple{DataValueArray,DataValueArray}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">copyto!(dest::DataValueArray, src::DataValueArray)</code></pre><p>Copy the initialized values of a source DataValueArray into the respective indices of the destination DataValueArray. If an entry in <code>src</code> is null, then this method nullifies the respective entry in <code>dest</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.deepcopy-Tuple{DataValueArray}" href="#Base.deepcopy-Tuple{DataValueArray}"><code>Base.deepcopy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Base.deepcopy(X::DataValueArray)</code></pre><p>Return a <code>DataValueArray</code> object whose internal <code>values</code> and <code>isna</code> fields are deep copies of <code>X.values</code> and <code>X.isna</code> respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.deleteat!-Tuple{DataValueArray{T,1} where T,Any}" href="#Base.deleteat!-Tuple{DataValueArray{T,1} where T,Any}"><code>Base.deleteat!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deleteat!(X::DataValueVector, inds)</code></pre><p>Delete the entry at <code>inds</code> from <code>X</code> and then return <code>X</code>. Note that <code>inds</code> may be either a single scalar index or a collection of sorted, pairwise unique indices. Subsequent items after deleted entries are shifted down to fill the resulting gaps.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.empty!-Tuple{DataValueArray{T,1} where T}" href="#Base.empty!-Tuple{DataValueArray{T,1} where T}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">empty!(X::DataValueVector) -&gt; DataValueVector</code></pre><p>Remove all elements from a <code>DataValueVector</code>. Returns <code>DataValueVector{T}()</code>, where <code>T</code> is the <code>eltype</code> of <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fill!-Tuple{DataValueArray,Any}" href="#Base.fill!-Tuple{DataValueArray,Any}"><code>Base.fill!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fill!(X::DataValueArray, x::DataValue)</code></pre><p>Fill <code>X</code> with the value <code>x</code> and designate each entry as present. If <code>x</code> is an object reference, all elements will refer to the same object. Note that <code>fill!(X, Foo())</code> will return <code>X</code> filled with the result of evaluating <code>Foo()</code> once.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fill!-Tuple{DataValueArray,DataValue}" href="#Base.fill!-Tuple{DataValueArray,DataValue}"><code>Base.fill!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fill!(X::DataValueArray, x::DataValue)</code></pre><p>Fill <code>X</code> with the value <code>x</code>. If <code>x</code> is empty, then <code>fill!(X, x)</code> nullifies each entry of <code>X</code>. Otherwise, <code>fill!(X, x)</code> fills <code>X.values</code> with the value of <code>x</code> and designates each entry of <code>X</code> as present.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{DataValue}" href="#Base.getindex-Tuple{DataValue}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getindex(x::DataValue)</code></pre><p>Attempt to access the value of <code>x</code>. Throw a <code>DataValueException</code> if the value is not present. Usually, this is written as <code>x[]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Union{Tuple{N}, Tuple{T}, Tuple{DataValueArray{T,N},Vararg{DataValue{Int64},N} where N}} where N where T" href="#Base.getindex-Union{Tuple{N}, Tuple{T}, Tuple{DataValueArray{T,N},Vararg{DataValue{Int64},N} where N}} where N where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getindex{T,N}(X::DataValueArray{T,N}, I::DataValue{Int}...)</code></pre><p>Just as above, with the additional behavior that this method throws an error if any component of the index <code>I</code> is missing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Union{Tuple{N}, Tuple{T}, Tuple{DataValueArray{T,N},Vararg{Int64,N} where N}} where N where T" href="#Base.getindex-Union{Tuple{N}, Tuple{T}, Tuple{DataValueArray{T,N},Vararg{Int64,N} where N}} where N where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getindex{T,N}(X::DataValueArray{T,N}, I::Int...)</code></pre><p>Retrieve a single entry from a <code>DataValueArray</code>. If the value in the entry designated by <code>I</code> is present, then it will be returned wrapped in a <code>DataValue{T}</code> container. If the value is missing, then this method returns <code>DataValue{T}()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lastindex-Tuple{DataValueArray}" href="#Base.lastindex-Tuple{DataValueArray}"><code>Base.lastindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lastindex(X::DataValueArray)</code></pre><p>Returns the last entry of <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{DataValueArray}" href="#Base.length-Tuple{DataValueArray}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">length(X::DataValueArray)</code></pre><p>Returns the maximum index <code>i</code> for which <code>getindex(X, i)</code> is valid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mapreduce-Union{Tuple{T}, Tuple{S}, Tuple{N}, Tuple{Any,Function,T}} where T&lt;:AbstractArray{S,N} where S&lt;:DataValue where N" href="#Base.mapreduce-Union{Tuple{T}, Tuple{S}, Tuple{N}, Tuple{Any,Function,T}} where T&lt;:AbstractArray{S,N} where S&lt;:DataValue where N"><code>Base.mapreduce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mapreduce(f, op::Function, X::DataValueArray; [skipna::Bool=false])</code></pre><p>Map a function <code>f</code> over the elements of <code>X</code> and reduce the result under the operation <code>op</code>. One can set the behavior of this method to skip the null entries of <code>X</code> by setting the keyword argument <code>skipna</code> equal to true. If <code>skipna</code> behavior is enabled, <code>f</code> will be automatically lifted over the elements of <code>X</code>. Note that, in general, mapreducing over a <code>DataValueArray</code> will return a <code>DataValue</code> object regardless of whether <code>skipna</code> is set to <code>true</code> or <code>false</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ndims-Tuple{DataValueArray}" href="#Base.ndims-Tuple{DataValueArray}"><code>Base.ndims</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ndims(X::DataValueArray)</code></pre><p>Returns the number of dimensions of <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!-Union{Tuple{DataValueArray{T,1}}, Tuple{T}} where T" href="#Base.pop!-Union{Tuple{DataValueArray{T,1}}, Tuple{T}} where T"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pop!{T}(X::DataValueVector{T})</code></pre><p>Remove the last entry from <code>X</code> and return it. If the value in that entry is missing, then this method returns <code>DataValue{T}()</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.popfirst!-Union{Tuple{DataValueArray{T,1}}, Tuple{T}} where T" href="#Base.popfirst!-Union{Tuple{DataValueArray{T,1}}, Tuple{T}} where T"><code>Base.popfirst!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">popfirst!{T}(X::DataValueVector{T})</code></pre><p>Remove the first entry from <code>X</code> and return it as a <code>DataValue</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.prepend!-Tuple{DataValueArray{T,1} where T,AbstractArray{T,1} where T}" href="#Base.prepend!-Tuple{DataValueArray{T,1} where T,AbstractArray{T,1} where T}"><code>Base.prepend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prepend!(X::DataValueVector, items::AbstractVector)</code></pre><p>Add the elements of <code>items</code> to the beginning of <code>X</code>.</p><p>Note that <code>prepend!(X, [1, 2, 3])</code> is equivalent to <code>pushfirst!(X, 1, 2, 3)</code>, where the items to be added to <code>X</code> are passed individually to <code>pushfirst!</code> and as a collection to <code>prepend!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Union{Tuple{V}, Tuple{T}, Tuple{DataValueArray{T,1},DataValue{V}}} where V where T" href="#Base.push!-Union{Tuple{V}, Tuple{T}, Tuple{DataValueArray{T,1},DataValue{V}}} where V where T"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!{T,V}(X::DataValueVector{T}, v::DataValue{V})</code></pre><p>Insert a value at the end of <code>X</code> from a <code>DataValue</code> value <code>v</code>. If <code>v</code> is null then this method adds a null entry at the end of <code>X</code>. Returns <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Union{Tuple{V}, Tuple{T}, Tuple{DataValueArray{T,1},V}} where V where T" href="#Base.push!-Union{Tuple{V}, Tuple{T}, Tuple{DataValueArray{T,1},V}} where V where T"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!{T,V}(X::DataValueVector{T}, v::V)</code></pre><p>Insert <code>v</code> at the end of <code>X</code>, which registers <code>v</code> as a present value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pushfirst!-Tuple{DataValueArray{T,1} where T,Any}" href="#Base.pushfirst!-Tuple{DataValueArray{T,1} where T,Any}"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pushfirst!(X::DataValueVector, v)</code></pre><p>Insert a value <code>v</code> at the beginning of <code>X</code> and return <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pushfirst!-Tuple{DataValueArray{T,1} where T,DataValue}" href="#Base.pushfirst!-Tuple{DataValueArray{T,1} where T,DataValue}"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pushfirst!(X::DataValueVector, v::DataValue)</code></pre><p>Insert a value at the beginning of <code>X</code> from a <code>DataValue</code> value <code>v</code>. If <code>v</code> is null then this method inserts a null entry at the beginning of <code>X</code>. Returns <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reduce-Union{Tuple{T}, Tuple{S}, Tuple{N}, Tuple{Any,T}} where T&lt;:AbstractArray{S,N} where S&lt;:DataValue where N" href="#Base.reduce-Union{Tuple{T}, Tuple{S}, Tuple{N}, Tuple{Any,T}} where T&lt;:AbstractArray{S,N} where S&lt;:DataValue where N"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reduce(f, op::Function, X::DataValueArray; [skipna::Bool=false])</code></pre><p>Reduce <code>X</code>under the operation <code>op</code>. One can set the behavior of this method to skip the null entries of <code>X</code> by setting the keyword argument <code>skipna</code> equal to true. If <code>skipna</code> behavior is enabled, <code>f</code> will be automatically lifted over the elements of <code>X</code>. Note that, in general, mapreducing over a <code>DataValueArray</code> will return a <code>DataValue</code> object regardless of whether <code>skipna</code> is set to <code>true</code> or <code>false</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.resize!-Union{Tuple{T}, Tuple{DataValueArray{T,1},Int64}} where T" href="#Base.resize!-Union{Tuple{T}, Tuple{DataValueArray{T,1},Int64}} where T"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">resize!(X::DataValueVector, n::Int)</code></pre><p>Resize a one-dimensional <code>DataValueArray</code> <code>X</code> to contain precisely <code>n</code> elements. If <code>n</code> is greater than the current length of <code>X</code>, then each new entry will be designated as null.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reverse(X::DataValueVector, [s], [n])</code></pre><p>Return a copy of <code>X</code> with the first <code>n</code> elements starting at index <code>s</code> (inclusive) reversed. If unspecified, <code>s</code> and <code>n</code> will default to <code>1</code> and <code>length(X)</code>, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reverse!(X::DataValueVector, [s], [n])</code></pre><p>Modify <code>X</code> by reversing the first <code>n</code> elements starting at index <code>s</code> (inclusive). If unspecified, <code>s</code> and <code>n</code> will default to <code>1</code> and <code>length(X)</code>, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Tuple{DataValueArray,Any,Vararg{Int64,N} where N}" href="#Base.setindex!-Tuple{DataValueArray,Any,Vararg{Int64,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setindex!(X::DataValueArray, v::Any, I::Int...)</code></pre><p>Set the entry of <code>X</code> at position <code>I</code> equal to <code>v</code>. This method always updates <code>X.isna</code> to indicate that the entry at index <code>I</code> is present and <code>X.values</code> to store <code>v</code> at <code>I</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Tuple{DataValueArray,DataValue,Vararg{Int64,N} where N}" href="#Base.setindex!-Tuple{DataValueArray,DataValue,Vararg{Int64,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setindex!(X::DataValueArray, v::DataValue, I::Int...)</code></pre><p>Set the entry of <code>X</code> at position <code>I</code> equal to a <code>DataValue</code> value <code>v</code>. If <code>v</code> is missing, then only <code>X.isna</code> is updated to indicate that the entry at index <code>I</code> is null. If <code>v</code> is not null, then <code>X.isna</code> is updated to indicate that the entry at index <code>I</code> is present and <code>X.values</code> is updated to store the value wrapped in <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.size-Tuple{DataValueArray}" href="#Base.size-Tuple{DataValueArray}"><code>Base.size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">size(X::DataValueArray, [d::Real])</code></pre><p>Return a tuple containing the lengths of each dimension of <code>X</code>, or if <code>d</code> is specific, the length of <code>X</code> along dimension <code>d</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sizehint!-Tuple{DataValueArray{T,1} where T,Integer}" href="#Base.sizehint!-Tuple{DataValueArray{T,1} where T,Integer}"><code>Base.sizehint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sizehint!(X::DataValueVector, newsz::Integer)</code></pre><p>Suggest that collection <code>X</code> reserve capacity for at least <code>newsz</code> elements. This can improve performance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.splice!" href="#Base.splice!"><code>Base.splice!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">splice!(X::DataValueVector, i::Integer, [ins])</code></pre><p>Remove the item at index <code>i</code> and return the removed item. Subsequent items are shifted down to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.splice!-Union{Tuple{T}, Tuple{DataValueArray{T,1} where T,UnitRange{T}}, Tuple{DataValueArray{T,1} where T,UnitRange{T},Any}} where T&lt;:Integer" href="#Base.splice!-Union{Tuple{T}, Tuple{DataValueArray{T,1} where T,UnitRange{T}}, Tuple{DataValueArray{T,1} where T,UnitRange{T},Any}} where T&lt;:Integer"><code>Base.splice!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">splice!{T&lt;:Integer}(X::DataValueVector, rng::UnitRange{T}, [ins])</code></pre><p>Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted down to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.</p><p>To insert <code>ins</code> before an index <code>n</code> without removing any items, use <code>splice!(X, n:n-1, ins)</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
