<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Poltergeist.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Poltergeist.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.MarkovMap" href="#Poltergeist.MarkovMap"><code>Poltergeist.MarkovMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MarkovMap(fs::Vector, ds::Vector, ran = coveringinterval(ds); dir=Forward, diff=autodiff(...)))</code></pre><p>Generate a MarkovMap with branches given by elements of <code>fs</code><code>defined on subdomains given by</code>ds<code>, onto a vector</code>ran`.</p><p>The keyword argument <code>dir</code> stipulates whether the elements of <code>fs</code> are the branches (<code>Forward</code>) or the branches&#39; inverses (<code>Reverse</code>).</p><p>The keyword argument <code>diff</code> provides the derivatives of the <code>fs</code>. By default it is the automatic derivatives of <code>fs</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.MarkovMap" href="#Poltergeist.MarkovMap"><code>Poltergeist.MarkovMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MarkovMap(branches::Vector, domain, rangedomain)</code></pre><p>Generate a computer representation of a full-branch uniformly-expanding interval map <code>domain</code> → <code>rangedomain</code> using a vector describing the branches of the map.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.AR_process-Tuple{Any,Fun}" href="#Poltergeist.AR_process-Tuple{Any,Fun}"><code>Poltergeist.AR_process</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>AR_process(f,A::Fun)</p><p>Calculate coefficients of Gaussian AR process with the same autocorrelation function as A under the map f.</p><p>See Appendix A.2 of Wormell, C.L. &amp; Gottwald, G.A. &#39;On the Validity of Linear Response Theory in High-Dimensional Deterministic Dynamical Systems&#39; (2018).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.MA_process-Tuple{Any,Fun}" href="#Poltergeist.MA_process-Tuple{Any,Fun}"><code>Poltergeist.MA_process</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">MA_process(f,A::Fun)</code></pre><p>Calculate coefficients of Gaussian MA process with the same autocorrelation function as A under the map f.</p><p>See Appendix A.2 of Wormell, C.L. &amp; Gottwald, G.A. &#39;On the Validity of Linear Response Theory in High-Dimensional Deterministic Dynamical Systems&#39; (2018).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.Transfer-Tuple" href="#Poltergeist.Transfer-Tuple"><code>Poltergeist.Transfer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Transfer(m::AbstractMarkovMap)</code></pre><p>Create a <code>CachedOperator</code> of a <code>ConcreteTransfer</code> operator encoding the transfer operator of <code>m</code>.</p><p>Caching is used for speed, as entries of the transfer operator are most efficiently calculated whole columns at a time.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.acim-Tuple{Poltergeist.SolutionInvWrapper}" href="#Poltergeist.acim-Tuple{Poltergeist.SolutionInvWrapper}"><code>Poltergeist.acim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">acim(L)</code></pre><p>Output a Fun object giving the acim of the associated map</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.birkhoffcov-Tuple{Poltergeist.SolutionInvWrapper,Fun,Fun}" href="#Poltergeist.birkhoffcov-Tuple{Poltergeist.SolutionInvWrapper,Fun,Fun}"><code>Poltergeist.birkhoffcov</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">birkhoffcov(L, A::Fun, B::Fun)</code></pre><p>Output covariance of CLT-normalised Birkhoff sums of A and B under the map</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.birkhoffvar-Tuple{Poltergeist.SolutionInvWrapper,Fun}" href="#Poltergeist.birkhoffvar-Tuple{Poltergeist.SolutionInvWrapper,Fun}"><code>Poltergeist.birkhoffvar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">birkhoffvar(L, A::Fun)</code></pre><p>Output diffusion coefficient of A under the map using Green-Kubo formula</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.correlationsum" href="#Poltergeist.correlationsum"><code>Poltergeist.correlationsum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">correlationsum(L, A::Fun, ρ=acim(L))</code></pre><p>Output resolvent of transfer operator applied to ρ*(A - ∫A dρ)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.covariancefunction-Tuple{ApproxFun.Operator,Fun,Fun,Int64}" href="#Poltergeist.covariancefunction-Tuple{ApproxFun.Operator,Fun,Fun,Int64}"><code>Poltergeist.covariancefunction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cfA, cfB = covariancefunction(L, A, B, n)</code></pre><p>Compute the lag-covariance function against transfer operator L between observables A and B for n time steps in each direction. Specifically, the (k+1)th entry of cfA is the expectation of B A∘f^(k) and vice versa for cfB.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.covariancefunction-Tuple{ApproxFun.Operator,Fun,Fun}" href="#Poltergeist.covariancefunction-Tuple{ApproxFun.Operator,Fun,Fun}"><code>Poltergeist.covariancefunction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cfA, cfB = covariancefunction(L, A, B; tol=eps(A*B))</code></pre><p>Chooses n so that the covariance declines to a given tolerance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.covariancefunction-Tuple{ApproxFun.Operator,Fun,Int64}" href="#Poltergeist.covariancefunction-Tuple{ApproxFun.Operator,Fun,Int64}"><code>Poltergeist.covariancefunction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cfA = covariancefunction(L, A, n)</code></pre><p>Compute the lag-covariance function against transfer operator L for observable A for n time steps in each direction. Specifically, the (k+1)th entry is the expectation of A A∘f^(k).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.covariancefunction-Tuple{ApproxFun.Operator,Fun}" href="#Poltergeist.covariancefunction-Tuple{ApproxFun.Operator,Fun}"><code>Poltergeist.covariancefunction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cf = covariancefunction(L, A; tol = eps(A))</code></pre><p>Choose n so that the covariance declines to a given tolerance</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.doubling" href="#Poltergeist.doubling"><code>Poltergeist.doubling</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">doubling(d = Interval(0,1.))</code></pre><p>Returns the full-branch interval map on domain d with 2 equally-sized branches.</p><p>See also: <a href="#Poltergeist.tupling"><code>tupling</code></a>, <a href="#Poltergeist.lanford"><code>lanford</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.hofbauerextension" href="#Poltergeist.hofbauerextension"><code>Poltergeist.hofbauerextension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hofbauerextension(m,basedomains;maxdepth=100,forcereturn=trues(length(basedomains)))</code></pre><p>Generates a Hofbauer extension of <code>m</code> starting from <code>basedomains</code>, which may be a single domain.</p><p>The keyword <code>maxdepth</code> says how deep the Hofbauer extension should go, and <code>forcereturn</code> sets whether a return to given members of <code>basedomains</code> should  forced if possible.</p><p>For example, in the case of <code>f(x) = mod(2x,1)</code>, if <code>basedomains</code> is set to <code>Interval(0.,0.3)</code> then <code>Interval(0.,0.5)</code> might map to <code>Interval(0.,1.)</code><code>for a given map if</code>forcereturn=false<code>but would map to Interval(0,0.3)</code> and <code>Interval(0.3,1)</code> if <code>forcereturn=true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.lanford" href="#Poltergeist.lanford"><code>Poltergeist.lanford</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lanford(T=Float64)</code></pre><p>Return the Lanford map, with type encoding T.</p><p>See also: <a href="#Poltergeist.tupling"><code>tupling</code></a>, <a href="#Poltergeist.doubling"><code>doubling</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.linearresponse-Tuple{Poltergeist.SolutionInvWrapper,Fun}" href="#Poltergeist.linearresponse-Tuple{Poltergeist.SolutionInvWrapper,Fun}"><code>Poltergeist.linearresponse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">linearresponse(L, X::Fun)</code></pre><p>Output a Fun object giving the first-order change in the acim of the map under perturbation X</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.lyapunov" href="#Poltergeist.lyapunov"><code>Poltergeist.lyapunov</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lyapunov(f, r=acim(f), sp=Space(rangedomain(f)))</code></pre><p>Calculate Lyapunov exponent associated with f</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.modulomap" href="#Poltergeist.modulomap"><code>Poltergeist.modulomap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">modulomap(f, D, R=dom; diff= autodiff(f,dom))</code></pre><p>Output MarkovMap or CircleMap m: D → R such that m(x) = f(x) mod R.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.nbranches-Tuple{Union{IntervalMap{D,R,B}, MarkovMap{D,R,B}} where B&lt;:Poltergeist.AbstractBranch where R&lt;:Domain where D&lt;:Domain}" href="#Poltergeist.nbranches-Tuple{Union{IntervalMap{D,R,B}, MarkovMap{D,R,B}} where B&lt;:Poltergeist.AbstractBranch where R&lt;:Domain where D&lt;:Domain}"><code>Poltergeist.nbranches</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nbranches(m)</code></pre><p>Return the number of branches of <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.perturb-Tuple{Any,Any,Any}" href="#Poltergeist.perturb-Tuple{Any,Any,Any}"><code>Poltergeist.perturb</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">perturb(d, X, ϵ)</code></pre><p>Construct a self-map on domain d: x ↦ x + ϵ X(x)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.perturb-Tuple{Poltergeist.AbstractMarkovMap,Any,Any}" href="#Poltergeist.perturb-Tuple{Poltergeist.AbstractMarkovMap,Any,Any}"><code>Poltergeist.perturb</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">perturb(m::AbstractMarkovMap, X, ϵ)</code></pre><p>Output perturbation of m: x ↦ m(x) + ϵ X(m(x))</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.tupling" href="#Poltergeist.tupling"><code>Poltergeist.tupling</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tupling(k::Int, d = Interval(0,1.))</code></pre><p>Returns the full-branch interval map on domain d with k equally-sized branches.</p><p>See also: <a href="#Poltergeist.doubling"><code>doubling</code></a>, <a href="#Poltergeist.lanford"><code>lanford</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.HofbauerDomain" href="#Poltergeist.HofbauerDomain"><code>Poltergeist.HofbauerDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HofbauerDomain</code></pre><p>A <code>Domain</code> object annotated with a depth index for <code>HofbauerExtensions</code>. It is not a <code>Domain</code> subtype itself as it should only be used in the context of Hofbauer extensions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.HofbauerPoint" href="#Poltergeist.HofbauerPoint"><code>Poltergeist.HofbauerPoint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HofbauerPoint(x, graphind)</code></pre><p>Constructs a <code>HofbauerPoint</code>, representing point <code>x</code> on the <code>graphind</code>th domain of a Hofbauer extension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigvals-Tuple{Poltergeist.AbstractMarkovMap,Int64}" href="#LinearAlgebra.eigvals-Tuple{Poltergeist.AbstractMarkovMap,Int64}"><code>LinearAlgebra.eigvals</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eigvals(m::AbstractMarkovMap, n)</code></pre><p>Output eigenvalues of Transfer(m) using n×n Galerkin discretisation.</p><p>Calls directly to ApproxFun: you can also call eigvals(Transfer(m), n)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigvecs-Tuple{Poltergeist.AbstractMarkovMap,Int64}" href="#LinearAlgebra.eigvecs-Tuple{Poltergeist.AbstractMarkovMap,Int64}"><code>LinearAlgebra.eigvecs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eigvecs(m::AbstractMarkovMap, n)</code></pre><p>Output eigenfunctions of Transfer(m) using n×n Galerkin discretisation.</p><p>Calls directly to ApproxFun: you can also call eigvecs(Transfer(m), n)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.branches-Tuple{Union{IntervalMap{D,R,B}, MarkovMap{D,R,B}} where B&lt;:Poltergeist.AbstractBranch where R&lt;:Domain where D&lt;:Domain}" href="#Poltergeist.branches-Tuple{Union{IntervalMap{D,R,B}, MarkovMap{D,R,B}} where B&lt;:Poltergeist.AbstractBranch where R&lt;:Domain where D&lt;:Domain}"><code>Poltergeist.branches</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">branches(m)</code></pre><p>Return the branches of the map <code>m</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.eachbranchindex-Tuple{Union{IntervalMap{D,R,B}, MarkovMap{D,R,B}} where B&lt;:Poltergeist.AbstractBranch where R&lt;:Domain where D&lt;:Domain}" href="#Poltergeist.eachbranchindex-Tuple{Union{IntervalMap{D,R,B}, MarkovMap{D,R,B}} where B&lt;:Poltergeist.AbstractBranch where R&lt;:Domain where D&lt;:Domain}"><code>Poltergeist.eachbranchindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eachbranchindex(m)</code></pre><p>Return an iterator giving the indices of the branches of <code>m</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.maphb-Tuple{Poltergeist.AbstractBranch,Any}" href="#Poltergeist.maphb-Tuple{Poltergeist.AbstractBranch,Any}"><code>Poltergeist.maphb</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">maphb(b::AbstractBranch, x)</code></pre><p>Maps point <code>x</code> according to <code>b</code>. For <code>NeutralBranches</code> calculates the return map out of <code>domain(b)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Poltergeist.zero_to" href="#Poltergeist.zero_to"><code>Poltergeist.zero_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">zero_to(A::Fun, ρ::Fun=uniform(space(A)))</code></pre><p>Output ρ*(A - ∫A dρ)</p></div></div></section><footer><hr/></footer></article></body></html>
