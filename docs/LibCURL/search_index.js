var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#LibCURL.jl-1",
    "page": "Readme",
    "title": "LibCURL.jl",
    "category": "section",
    "text": "Julia wrapper for libCURL(Image: Build Status) (Image: Appveyor) (Image: codecov.io)(Image: LibCURL) (Image: LibCURL) (Image: LibCURL)This is a simple Julia wrapper around http://curl.haxx.se/libcurl/ generated using Clang.jl."
},

{
    "location": "#Example-(fetch-a-URL)-1",
    "page": "Readme",
    "title": "Example (fetch a URL)",
    "category": "section",
    "text": "using LibCURL\n\n# init a curl handle\ncurl = curl_easy_init()\n\n# set the URL and request to follow redirects\ncurl_easy_setopt(curl, CURLOPT_URL, \"http://example.com\")\ncurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1)\n\n\n# setup the callback function to recv data\nfunction curl_write_cb(curlbuf::Ptr{Void}, s::Csize_t, n::Csize_t, p_ctxt::Ptr{Void})\n    sz = s * n\n    data = Array{UInt8}(sz)\n    \n    ccall(:memcpy, Ptr{Void}, (Ptr{Void}, Ptr{Void}, UInt64), data, curlbuf, sz)\n    println(\"recd: \", String(data))\n    \n    sz::Csize_t\nend\n\nc_curl_write_cb = cfunction(curl_write_cb, Csize_t, (Ptr{Void}, Csize_t, Csize_t, Ptr{Void}))\ncurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, c_curl_write_cb)\n\n\n# execute the query\nres = curl_easy_perform(curl)\nprintln(\"curl url exec response : \", res)\n\n# retrieve HTTP code\nhttp_code = Array{Clong}(1)\ncurl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, http_code)\nprintln(\"httpcode : \", http_code)\n\n# release handle\ncurl_easy_cleanup(curl)\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [LibCURL]\nOrder = [:type, :function]"
},

]}
