var documenterSearchIndex = {"docs": [

{
    "location": "#AxisAlgorithms.A_ldiv_B_md!-Tuple{Any,Any,Any,Integer}",
    "page": "Home",
    "title": "AxisAlgorithms.A_ldiv_B_md!",
    "category": "method",
    "text": "A_ldiv_B_md!(dest, F, src, dim) solves a tridiagonal system along dimension dim of src, storing the result in dest. Currently, F must be an LU-factorized tridiagonal matrix. If desired, you may safely use the same array for both src and dest, so that this becomes an in-place algorithm.\n\n\n\n\n\n"
},

{
    "location": "#AxisAlgorithms.A_ldiv_B_md-Tuple{Any,Any,Integer}",
    "page": "Home",
    "title": "AxisAlgorithms.A_ldiv_B_md",
    "category": "method",
    "text": "A_ldiv_B_md(F, src, dim) solves F for slices b of src along dimension dim, storing the result along the same dimension of the output. Currently, F must be an LU-factorized tridiagonal matrix or a Woodbury matrix.\n\n\n\n\n\n"
},

{
    "location": "#AxisAlgorithms.A_mul_B_md!-Tuple{Any,AbstractArray{T,2} where T,Any,Integer}",
    "page": "Home",
    "title": "AxisAlgorithms.A_mul_B_md!",
    "category": "method",
    "text": "A_mul_B_md!(dest, M, src, dim) computes M*x for slices x of src along dimension dim, storing the result in dest. M must be an AbstractMatrix. This uses an in-place naive algorithm.\n\n\n\n\n\n"
},

{
    "location": "#AxisAlgorithms.A_mul_B_md-Tuple{AbstractArray{T,2} where T,Any,Integer}",
    "page": "Home",
    "title": "AxisAlgorithms.A_mul_B_md",
    "category": "method",
    "text": "A_mul_B_md(M, src, dim) computes M*x for slices x of src along dimension dim, storing the resulting vector along the same dimension of the output. M must be an AbstractMatrix. This uses an in-place naive algorithm.\n\n\n\n\n\n"
},

{
    "location": "#AxisAlgorithms.A_mul_B_perm!-Tuple{Any,AbstractArray{T,2} where T,Any,Integer}",
    "page": "Home",
    "title": "AxisAlgorithms.A_mul_B_perm!",
    "category": "method",
    "text": "A_mul_B_perm!(dest, M, src, dim) computes M*x for slices x of src along dimension dim, storing the result in dest. M must be an AbstractMatrix. This uses permutedims to make dimension dim into the first dimension, performs a standard matrix multiplication, and restores the original dimension ordering. In many cases, this algorithm exhibits the best cache behavior.\n\n\n\n\n\n"
},

{
    "location": "#AxisAlgorithms.A_mul_B_perm-Tuple{AbstractArray{T,2} where T,Any,Integer}",
    "page": "Home",
    "title": "AxisAlgorithms.A_mul_B_perm",
    "category": "method",
    "text": "A_mul_B_perm(M, src, dim) computes M*x for slices x of src along dimension dim, storing the resulting vector along the same dimension of the output. M must be an AbstractMatrix. This uses permutedims to make dimension dim into the first dimension, performs a standard matrix multiplication, and restores the original dimension ordering. In many cases, this algorithm exhibits the best cache behavior.\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [AxisAlgorithms]\nOrder = [:type, :function]"
},

]}
