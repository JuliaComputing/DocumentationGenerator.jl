var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#Einsum.jl-1",
    "page": "Readme",
    "title": "Einsum.jl",
    "category": "section",
    "text": "Einstein summation notation similar to numpy\'s einsum function (but more flexible!).PackageEvaluator Package Build Package Status\n(Image: Einsum) (Image: Build Status) (Image: License)\n(Image: Einsum)  (Image: Project Status: Inactive - The project has reached a stable, usable state but is no longer being actively developed; support/maintenance will be provided as time allows.) - help wanted!To install: Pkg.add(\"Einsum\")."
},

{
    "location": "#Documentation-1",
    "page": "Readme",
    "title": "Documentation",
    "category": "section",
    "text": ""
},

{
    "location": "#Basics-1",
    "page": "Readme",
    "title": "Basics",
    "category": "section",
    "text": "If the destination array is preallocated, then use =:A = zeros(5,6,7) # need to preallocate destination\nX = randn(5,2)\nY = randn(6,2)\nZ = randn(7,2)\n@einsum A[i,j,k] = X[i,r]*Y[j,r]*Z[k,r]If destination is not preallocated, then use := to automatically create a new array A with appropriate dimensions:using Einsum\nX = randn(5,2)\nY = randn(6,2)\nZ = randn(7,2)\n@einsum A[i,j,k] := X[i,r]*Y[j,r]*Z[k,r]"
},

{
    "location": "#What-happens-under-the-hood-1",
    "page": "Readme",
    "title": "What happens under the hood",
    "category": "section",
    "text": "To see exactly what is generated, use @macroexpand:@macroexpand @einsum A[i,j,k] = X[i,r]*Y[j,r]*Z[k,r]The @einsum macro automatically generates code that looks much like the following (note that we \"sum out\" over the index r, since it only occurs on the right hand side of the equation):for k = 1:size(A,3)\n    for j = 1:size(A,2)\n        for i = 1:size(A,1)\n            s = 0\n            for r = 1:size(X,2)\n                s += X[i,r] * Y[j,r] * Z[k,r]\n            end\n            A[i,j,k] = s\n        end\n    end\nendIn reality, this code will be preceded by the the neccessary bounds checks and allocations, and take care to use the right types and keep hygenic.You can also use updating assignment operators for preallocated arrays.  E.g., @einsum A[i,j,k] *= X[i,r]*Y[j,r]*Z[k,r] will produce something likefor k = 1:size(A,3)\n    for j = 1:size(A,2)\n        for i = 1:size(A,1)\n            s = 0\n            for r = 1:size(X,2)\n                s += X[i,r] * Y[j,r] * Z[k,r]\n            end\n            A[i,j,k] *= s\n        end\n    end\nend"
},

{
    "location": "#@einsimd-1",
    "page": "Readme",
    "title": "@einsimd",
    "category": "section",
    "text": "This is a variant of @einsum which will put @simd in front of the innermost loop; e.g., @einsum A[i,j,k] = X[i,r]*Y[j,r]*Z[k,r] will result approximately infor k = 1:size(A,3)\n    for j = 1:size(A,2)\n        for i = 1:size(A,1)\n            s = 0\n            @simd for r = 1:size(X,2)\n                s += X[i,r] * Y[j,r] * Z[k,r]\n            end\n            A[i,j,k] = s\n        end\n    end\nendWhether this is a good idea or not you have to decide and benchmark for yourself in every specific case.  @simd makes sense for certain kinds of operations; make yourself familiar with its documentation and the inner workings of it in general."
},

{
    "location": "#Other-functionality-1",
    "page": "Readme",
    "title": "Other functionality",
    "category": "section",
    "text": "In principle, the @einsum macro can flexibly implement function calls within the nested for loop structure. For example, consider transposing a block matrix:z = Any[rand(2,2) for i=1:2, j=1:2]\n@einsum t[i,j] := transpose(z[j,i])This produces a for loop structure with a transpose function call in the middle. Approximately:for j = 1:size(z,1)\n    for i = 1:size(z,2)\n        t[i,j] = transpose(z[j,i])\n    end\nendThis will work as long the function calls are outside the array names.  Again, you can use @macroexpand to see the exact code that is generated."
},

{
    "location": "#Related-Packages:-1",
    "page": "Readme",
    "title": "Related Packages:",
    "category": "section",
    "text": "TensorOperations.jl has less flexible syntax (and does not allow certain contractions), but can produce much more efficient code.  Instead of generating “naive” loops, it transforms the expressions into optimized contraction functions and takes care to use a good (cache-friendly) order for the looping."
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [Einsum]\nOrder = [:type, :function]"
},

]}
