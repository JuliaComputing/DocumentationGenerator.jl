<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · AbstractPlotting.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractPlotting.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Billboard" href="#AbstractPlotting.Billboard"><code>AbstractPlotting.Billboard</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Billboard attribute to always have a primitive face the camera. Can be used for rotation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.PlotList" href="#AbstractPlotting.PlotList"><code>AbstractPlotting.PlotList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Plotlist(plots...)</code></p><p>Experimental feature. Create an object that can encode multiple series.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.PlotSpec" href="#AbstractPlotting.PlotSpec"><code>AbstractPlotting.PlotSpec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>PlotSpec{P&lt;:AbstractPlot}(args...; kwargs...)</code></p><p>Object encoding positional arguments (<code>args</code>), a <code>NamedTuple</code> of attributes (<code>kwargs</code>) as well as plot type <code>P</code> of a basic plot.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Reverse" href="#AbstractPlotting.Reverse"><code>AbstractPlotting.Reverse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Reverses the attribute T uppon conversion</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.VideoStream-Tuple{Scene}" href="#AbstractPlotting.VideoStream-Tuple{Scene}"><code>AbstractPlotting.VideoStream</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">VideoStream(scene::Scene, dir = mktempdir(), name = &quot;video&quot;)</code></pre><p>returns a stream and a buffer that you can use to not allocate for new frames. Use <code>add_frame!(stream, window, buffer)</code> to add new video frames to the stream. Use <code>save(stream)</code> to save the video to &#39;dir/name.mkv&#39;. You can also call <code>save(stream, &quot;mkv&quot;)</code>, <code>save(stream, &quot;mp4&quot;)</code>, <code>save(stream, &quot;gif&quot;)</code> or <code>save(stream, &quot;webm&quot;)</code> to convert the stream to those formats.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations" href="#AbstractPlotting.annotations"><code>AbstractPlotting.annotations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`annotations(strings::Vector{String}, positions::Vector{Point})`</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations!-Tuple" href="#AbstractPlotting.annotations!-Tuple"><code>AbstractPlotting.annotations!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.annotations!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.annotations!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.annotations!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.annotations!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.annotations!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.annotations!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.annotations!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.annotations!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.annotations!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.annotations!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.annotations!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.annotations!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations-Tuple" href="#AbstractPlotting.annotations-Tuple"><code>AbstractPlotting.annotations</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.annotations(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.annotations-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.annotations</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.annotations(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.annotations(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc!-Tuple" href="#AbstractPlotting.arc!-Tuple"><code>AbstractPlotting.arc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arc!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.arc!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.arc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arc!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arc!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.arc!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.arc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arc!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arc!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.arc!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.arc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arc!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc-Tuple" href="#AbstractPlotting.arc-Tuple"><code>AbstractPlotting.arc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arc(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.arc-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.arc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arc(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arc(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows!-Tuple" href="#AbstractPlotting.arrows!-Tuple"><code>AbstractPlotting.arrows!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.arrows!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.arrows!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.arrows!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.arrows!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.arrows!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.arrows!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows-Tuple" href="#AbstractPlotting.arrows-Tuple"><code>AbstractPlotting.arrows</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.arrows-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.arrows</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.arrows(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.arrows(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis2d!-Tuple" href="#AbstractPlotting.axis2d!-Tuple"><code>AbstractPlotting.axis2d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis2d!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis2d!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.axis2d!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.axis2d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis2d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis2d!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis2d!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.axis2d!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.axis2d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis2d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis2d!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis2d!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.axis2d!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.axis2d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis2d!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis2d-Tuple" href="#AbstractPlotting.axis2d-Tuple"><code>AbstractPlotting.axis2d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis2d(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis2d-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.axis2d-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.axis2d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis2d(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis2d(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis3d!-Tuple" href="#AbstractPlotting.axis3d!-Tuple"><code>AbstractPlotting.axis3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis3d!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis3d!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.axis3d!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.axis3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis3d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis3d!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis3d!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.axis3d!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.axis3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis3d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis3d!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis3d!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.axis3d!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.axis3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis3d!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis3d-Tuple" href="#AbstractPlotting.axis3d-Tuple"><code>AbstractPlotting.axis3d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis3d(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.axis3d-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.axis3d-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.axis3d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.axis3d(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.axis3d(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band!-Tuple" href="#AbstractPlotting.band!-Tuple"><code>AbstractPlotting.band!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.band!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.band!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.band!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.band!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.band!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.band!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.band!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.band!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.band!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.band!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.band!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.band!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band-Tuple" href="#AbstractPlotting.band-Tuple"><code>AbstractPlotting.band</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.band(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.band-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.band</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.band(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.band(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot!-Tuple" href="#AbstractPlotting.barplot!-Tuple"><code>AbstractPlotting.barplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.barplot!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.barplot!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.barplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.barplot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.barplot!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.barplot!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.barplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.barplot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.barplot!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.barplot!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.barplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.barplot!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot-Tuple" href="#AbstractPlotting.barplot-Tuple"><code>AbstractPlotting.barplot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.barplot(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.barplot-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.barplot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.barplot(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.barplot(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.broadcast_foreach-Tuple{Any,Vararg{Any,N} where N}" href="#AbstractPlotting.broadcast_foreach-Tuple{Any,Vararg{Any,N} where N}"><code>AbstractPlotting.broadcast_foreach</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Like broadcast but for foreach. Doesn&#39;t care about shape and treats Tuples &amp;&amp; StaticVectors as scalars.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button!-Tuple" href="#AbstractPlotting.button!-Tuple"><code>AbstractPlotting.button!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.button!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.button!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.button!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.button!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.button!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.button!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.button!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.button!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.button!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.button!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.button!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.button!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button-Tuple" href="#AbstractPlotting.button-Tuple"><code>AbstractPlotting.button</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.button(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.button-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.button</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.button(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.button(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.cam2d-Tuple{Scene}" href="#AbstractPlotting.cam2d-Tuple{Scene}"><code>AbstractPlotting.cam2d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Creates a subscene with a pixel camera</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend" href="#AbstractPlotting.colorlegend"><code>AbstractPlotting.colorlegend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">colorlegend(scene, colormap, range)</code></pre><p>creates a legend from a colormap</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend!-Tuple" href="#AbstractPlotting.colorlegend!-Tuple"><code>AbstractPlotting.colorlegend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.colorlegend!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.colorlegend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.colorlegend!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.colorlegend!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.colorlegend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.colorlegend!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.colorlegend!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.colorlegend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend-Tuple" href="#AbstractPlotting.colorlegend-Tuple"><code>AbstractPlotting.colorlegend</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.colorlegend-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.colorlegend</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.colorlegend(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.colorlegend(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour" href="#AbstractPlotting.contour"><code>AbstractPlotting.contour</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contour(x, y, z)</code></pre><p>Creates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour!-Tuple" href="#AbstractPlotting.contour!-Tuple"><code>AbstractPlotting.contour!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.contour!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.contour!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.contour!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.contour!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.contour!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.contour!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour-Tuple" href="#AbstractPlotting.contour-Tuple"><code>AbstractPlotting.contour</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.contour-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.contour</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d" href="#AbstractPlotting.contour3d"><code>AbstractPlotting.contour3d</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d!-Tuple" href="#AbstractPlotting.contour3d!-Tuple"><code>AbstractPlotting.contour3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour3d!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.contour3d!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.contour3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour3d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour3d!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.contour3d!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.contour3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour3d!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour3d!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.contour3d!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.contour3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour3d!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d-Tuple" href="#AbstractPlotting.contour3d-Tuple"><code>AbstractPlotting.contour3d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour3d(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.contour3d-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.contour3d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.contour3d(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.contour3d(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Any,IntervalSets.Interval{:closed,:closed,T} where T,IntervalSets.Interval{:closed,:closed,T} where T,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Any,IntervalSets.Interval{:closed,:closed,T} where T,IntervalSets.Interval{:closed,:closed,T} where T,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x, y, z)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes 2 ClosedIntervals&#39;s <code>x</code>, <code>y</code>, and an AbstractMatrix <code>z</code>, and converts the closed range to linspaces with size(z, 1/2) <code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s828} where #s828&lt;:(Volume{...}),AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Function}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s828} where #s828&lt;:(Volume{...}),AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Function}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes <code>AbstractVector</code> <code>x</code>, <code>y</code>, and <code>z</code> and the function <code>f</code>, evaluates <code>f</code> on the volume spanned by <code>x</code>, <code>y</code> and <code>z</code>, and puts <code>x</code>, <code>y</code>, <code>z</code> and <code>f(x,y,z)</code> in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s828} where #s828&lt;:Union{Surface{...}, Heatmap{...}, Image{...}},AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s828} where #s828&lt;:Union{Surface{...}, Heatmap{...}, Image{...}},AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an <code>AbstractMatrix</code>, converts the dimesions <code>n</code> and <code>m</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code> and <code>m</code>, plus the original matrix in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:(Mesh{...}),AbstractArray,AbstractArray}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:(Mesh{...}),AbstractArray,AbstractArray}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(Mesh, vertices, indices)::GLNormalMesh</code></pre><p>Takes <code>vertices</code> and <code>indices</code>, and creates a triangle mesh out of those. See <a href="@ref">to_vertices</a> and <a href="@ref">to_triangles</a> for more informations about accepted types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:(Mesh{...}),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:(Mesh{...}),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(Mesh, x, y, z, indices)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in <code>indices</code>, which can be integers (every 3 -&gt; one triangle), or GeometryTypes.Face{N, &lt;: Integer}.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:(Mesh{...}),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:(Mesh{...}),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(Mesh, x, y, z)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:(Mesh{...}),AbstractArray{T,1} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:(Mesh{...}),AbstractArray{T,1} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh</code></pre><p>Takes an input mesh and a vector <code>xyz</code> representing the vertices of the mesh, and creates indices under the assumption, that each triplet in <code>xyz</code> forms a triangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x, y, z)::(Vector)</code></pre><p>Takes vectors <code>x</code>, <code>y</code>, and <code>z</code> and turns it into a vector of 3D points of the values from <code>x</code>, <code>y</code>, and <code>z</code>. <code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x, y)::(Vector)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and turns it into a vector of 2D points of the values from <code>x</code> and <code>y</code>.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, y)::Vector</code></pre><p>Takes vector <code>y</code> and generates a range from 1 to the length of <code>y</code>, for plotting on an arbitrary <code>x</code> axis.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},GeometryTypes.GeometryPrimitive}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},GeometryTypes.GeometryPrimitive}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input GeometryPrimitive <code>x</code> and decomposes it to points. <code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},GeometryTypes.HyperRectangle{2,T} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{MeshScatter{...}, Scatter{...}, Lines{...}, LineSegments{...}},GeometryTypes.HyperRectangle{2,T} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input <code>HyperRectangle</code> <code>x</code> and decomposes it to points.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{Surface{...}, Heatmap{...}, Image{...}},Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s829} where #s829&lt;:Union{Surface{...}, Heatmap{...}, Image{...}},Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x::VecOrMat, y::VecOrMat, z::Matrix)</code></pre><p>Takes 3 <code>AbstractMatrix</code> <code>x</code>, <code>y</code>, and <code>z</code>, converts them to <code>Float32</code> and outputs them in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{Text{...}},AbstractString}" href="#AbstractPlotting.convert_arguments-Tuple{Type{Text{...}},AbstractString}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(x)::(String)</code></pre><p>Takes an input <code>AbstractString</code> <code>x</code> and converts it to a string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{E}, Tuple{A}, Tuple{T}, Tuple{N}, Tuple{Type{#s829} where #s829&lt;:(LineSegments{...}),AbstractArray{E,1}}} where E&lt;:Union{Pair{A,A}, Tuple{A,A}} where A&lt;:Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N" href="#AbstractPlotting.convert_arguments-Union{Tuple{E}, Tuple{A}, Tuple{T}, Tuple{N}, Tuple{Type{#s829} where #s829&lt;:(LineSegments{...}),AbstractArray{E,1}}} where E&lt;:Union{Pair{A,A}, Tuple{A,A}} where A&lt;:Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Accepts a Vector of Pair of Points (e.g. <code>[Point(0, 0) =&gt; Point(1, 1), ...]</code>) to encode e.g. linesegments or directions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{#s829} where #s829&lt;:Union{Surface{...}, Heatmap{...}, Image{...}},AbstractArray{T1,1},AbstractArray{T2,1},Function}} where T2 where T1" href="#AbstractPlotting.convert_arguments-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{#s829} where #s829&lt;:Union{Surface{...}, Heatmap{...}, Image{...}},AbstractArray{T1,1},AbstractArray{T2,1},Function}} where T2 where T1"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x, y, f)::(Vector, Vector, Matrix)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and the function <code>f</code>, and applies <code>f</code> on the grid that <code>x</code> and <code>y</code> span. This is equivalent to <code>f.(x, y&#39;)</code>. <code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{Type{#s828} where #s828&lt;:(Volume{...}),Array{T,3}}} where T" href="#AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{Type{#s828} where #s828&lt;:(Volume{...}),Array{T,3}}} where T"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an array of <code>{T, 3} where T</code>, converts the dimesions <code>n</code>, <code>m</code> and <code>k</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code>, <code>m</code> and <code>k</code>, plus the original array in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{Type{#s829} where #s829&lt;:(Volume{...}),AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,3}}} where T" href="#AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{Type{#s829} where #s829&lt;:(Volume{...}),AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,3}}} where T"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes 3 <code>AbstractVector</code> <code>x</code>, <code>y</code>, and <code>z</code> and the <code>AbstractMatrix</code> <code>i</code>, and puts everything in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute" href="#AbstractPlotting.convert_attribute"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A Symbol/String naming the gradient. For more on what names are available please see: `available_gradients()</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:colormap}}" href="#AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:colormap}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_colormap(b, x)</code></pre><p>An <code>AbstractVector{T}</code> with any object that <a href="#AbstractPlotting.to_color-Tuple{Any}"><code>to_color</code></a> accepts.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:linestyle}}" href="#AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:linestyle}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">`AbstractVector{&lt;:AbstractFloat}` for denoting sequences of fill/nofill. e.g.</code></pre><p>[0.5, 0.8, 1.2] will result in 0.5 filled, 0.3 unfilled, 0.4 filled. 1.0 unit is one linewidth!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Any,AbstractPlotting.Key{:algorithm}}" href="#AbstractPlotting.convert_attribute-Tuple{Any,AbstractPlotting.Key{:algorithm}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_volume_algorithm(b, x)</code></pre><p>Enum values: <code>IsoValue</code> <code>Absorption</code> <code>MaximumIntensityProjection</code> <code>AbsorptionRGBA</code> <code>IndexedAbsorptionRGBA</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Quaternion,AbstractPlotting.Key{:rotation}}" href="#AbstractPlotting.convert_attribute-Tuple{Quaternion,AbstractPlotting.Key{:rotation}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rotation accepts:
to_rotation(b, quaternion)
to_rotation(b, tuple_float)
to_rotation(b, vec4)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Symbol,AbstractPlotting.Key{:linestyle}}" href="#AbstractPlotting.convert_attribute-Tuple{Symbol,AbstractPlotting.Key{:linestyle}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">A `Symbol` equal to `:dash`, `:dot`, `:dashdot`, `:dashdotdot`</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Tuple{Symbol,Symbol},AbstractPlotting.Key{:align}}" href="#AbstractPlotting.convert_attribute-Tuple{Tuple{Symbol,Symbol},AbstractPlotting.Key{:align}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Text align, e.g.:</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:algorithm}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:algorithm}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Symbol/String: iso, absorption, mip, absorptionrgba, indexedabsorption</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:font}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:font}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">font conversion</code></pre><p>a string naming a font, e.g. helvetica</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{Tuple, Pair},AbstractPlotting.Key{:colormap}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{Tuple, Pair},AbstractPlotting.Key{:colormap}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Tuple(A, B) or Pair{A, B} with any object that <a href="#AbstractPlotting.to_color-Tuple{Any}"><code>to_color</code></a> accepts</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fill_between!-Tuple{Any,Any,Any}" href="#AbstractPlotting.fill_between!-Tuple{Any,Any,Any}"><code>AbstractPlotting.fill_between!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fill_between!(x, y1, y2; where = nothing, scene = current_scene(), kw_args...)</code></pre><p>fill the section between 2 lines with the condition <code>where</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.force_update!-Tuple{}" href="#AbstractPlotting.force_update!-Tuple{}"><code>AbstractPlotting.force_update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Forces to rerender the scnee</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap" href="#AbstractPlotting.heatmap"><code>AbstractPlotting.heatmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`heatmap(x, y, values)` or `heatmap(values)`</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap!-Tuple" href="#AbstractPlotting.heatmap!-Tuple"><code>AbstractPlotting.heatmap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.heatmap!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.heatmap!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.heatmap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.heatmap!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.heatmap!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.heatmap!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.heatmap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.heatmap!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.heatmap!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.heatmap!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.heatmap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.heatmap!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap-Tuple" href="#AbstractPlotting.heatmap-Tuple"><code>AbstractPlotting.heatmap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.heatmap(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.heatmap-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.heatmap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.heatmap(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.heatmap(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help-Tuple{Any}" href="#AbstractPlotting.help-Tuple{Any}"><code>AbstractPlotting.help</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">help(func[; extended = false])</code></pre><p>Welcome to the main help function of <code>Makie.jl</code> / <code>AbstractPlotting.jl</code>.</p><p>For help on a specific function&#39;s arguments, type <code>help_arguments(function_name)</code>.</p><p>For help on a specific function&#39;s attributes, type <code>help_attributes(plot_Type)</code>.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help_arguments-Tuple{Any}" href="#AbstractPlotting.help_arguments-Tuple{Any}"><code>AbstractPlotting.help_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">help_arguments([io], func)</code></pre><p>Returns a list of signatures for function <code>func</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help_attributes-Tuple{Any}" href="#AbstractPlotting.help_attributes-Tuple{Any}"><code>AbstractPlotting.help_attributes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">help_attributes([io], Union{PlotType, PlotFunction}; extended = false)</code></pre><p>Returns a list of attributes for the plot type <code>Typ</code>. The attributes returned extend those attributes found in the <code>default_theme</code>.</p><p>Use the optional keyword argument <code>extended</code> (default = <code>false</code>) to show in addition the default values of each attribute. usage:</p><pre><code class="language-example">&gt;help_attributes(scatter)
	alpha
	color
	colormap
	colorrange
	distancefield
	glowcolor
	glowwidth
	linewidth
	marker
	marker_offset
	markersize
	overdraw
	rotations
	strokecolor
	strokewidth
	transform_marker
	transparency
	uv_offset_width
	visible</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.hovered_scene-Tuple{}" href="#AbstractPlotting.hovered_scene-Tuple{}"><code>AbstractPlotting.hovered_scene</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hovered_scene()</code></pre><p>Return the <code>scene</code> that the mouse is currently hovering over.</p><p>Properly identifies the scene for a plot with multiple sub-plots.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image" href="#AbstractPlotting.image"><code>AbstractPlotting.image</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`image(x, y, image)` / `image(image)`</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image!-Tuple" href="#AbstractPlotting.image!-Tuple"><code>AbstractPlotting.image!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.image!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.image!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.image!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.image!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.image!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.image!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.image!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.image!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.image!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.image!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.image!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.image!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image-Tuple" href="#AbstractPlotting.image-Tuple"><code>AbstractPlotting.image</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.image(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.image-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.image</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.image(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.image(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.ispressed-Tuple{Union{AbstractScene, ScenePlot},Union{Tuple, Array{T,1} where T}}" href="#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, ScenePlot},Union{Tuple, Array{T,1} where T}}"><code>AbstractPlotting.ispressed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>returns true if <code>button</code> is pressed in scene[:mousebuttons or :keyboardbuttons] You can use nothing, to indicate it should always return true</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend!-Tuple" href="#AbstractPlotting.legend!-Tuple"><code>AbstractPlotting.legend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.legend!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.legend!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.legend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.legend!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.legend!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.legend!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.legend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.legend!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.legend!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.legend!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.legend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.legend!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend-Tuple" href="#AbstractPlotting.legend-Tuple"><code>AbstractPlotting.legend</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.legend(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.legend-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.legend</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.legend(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.legend(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines" href="#AbstractPlotting.lines"><code>AbstractPlotting.lines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`lines(x, y, z)` / `lines(x, y)` / or `lines(positions)`</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines!-Tuple" href="#AbstractPlotting.lines!-Tuple"><code>AbstractPlotting.lines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.lines!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.lines!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.lines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.lines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.lines!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.lines!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.lines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.lines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.lines!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.lines!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.lines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.lines!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines-Tuple" href="#AbstractPlotting.lines-Tuple"><code>AbstractPlotting.lines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.lines(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.lines-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.lines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.lines(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.lines(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments" href="#AbstractPlotting.linesegments"><code>AbstractPlotting.linesegments</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`linesegments(x, y, z)` / `linesegments(x, y)` / `linesegments(positions)`</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><p><strong>Attributes</strong>: The same as for <a href="#AbstractPlotting.lines"><code>lines</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments!-Tuple" href="#AbstractPlotting.linesegments!-Tuple"><code>AbstractPlotting.linesegments!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.linesegments!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.linesegments!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.linesegments!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.linesegments!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.linesegments!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.linesegments!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.linesegments!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.linesegments!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.linesegments!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.linesegments!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.linesegments!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.linesegments!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments-Tuple" href="#AbstractPlotting.linesegments-Tuple"><code>AbstractPlotting.linesegments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.linesegments(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.linesegments-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.linesegments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.linesegments(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.linesegments(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.map_once-Tuple{Any,Observables.Observable,Vararg{Observables.Observable,N} where N}" href="#AbstractPlotting.map_once-Tuple{Any,Observables.Observable,Vararg{Observables.Observable,N} where N}"><code>AbstractPlotting.map_once</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map_once(closure, inputs::Node....)::Node</code></pre><p>Like Reactive.foreach, in the sense that it will be preserved even if no reference is kept. The difference is, that you can call map once multiple times with the same closure and it will close the old result Node and register a new one instead.</p><p>``` function test(s1::Node)     s3 = map<em>once(x-&gt; (println(&quot;1 &quot;, x); x), s1)     s3 = map</em>once(x-&gt; (println(&quot;2 &quot;, x); x), s1)</p><p>end test(Node(1), Node(2))</p><blockquote></blockquote></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh" href="#AbstractPlotting.mesh"><code>AbstractPlotting.mesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`mesh(x, y, z)`, `mesh(mesh_object)`, `mesh(x, y, z, faces)`, or `mesh(xyz, faces)`</code></pre><p>Plots a 3D mesh.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh!-Tuple" href="#AbstractPlotting.mesh!-Tuple"><code>AbstractPlotting.mesh!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.mesh!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.mesh!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.mesh!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.mesh!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.mesh!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.mesh!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.mesh!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.mesh!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.mesh!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.mesh!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.mesh!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.mesh!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh-Tuple" href="#AbstractPlotting.mesh-Tuple"><code>AbstractPlotting.mesh</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.mesh(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.mesh-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.mesh</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.mesh(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.mesh(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter" href="#AbstractPlotting.meshscatter"><code>AbstractPlotting.meshscatter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`meshscatter(x, y, z)` / `meshscatter(x, y)` / `meshscatter(positions)`</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter!-Tuple" href="#AbstractPlotting.meshscatter!-Tuple"><code>AbstractPlotting.meshscatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.meshscatter!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.meshscatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.meshscatter!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.meshscatter!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.meshscatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.meshscatter!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.meshscatter!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.meshscatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter-Tuple" href="#AbstractPlotting.meshscatter-Tuple"><code>AbstractPlotting.meshscatter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.meshscatter-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.meshscatter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.meshscatter(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.meshscatter(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mouseposition" href="#AbstractPlotting.mouseposition"><code>AbstractPlotting.mouseposition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mouseposition(scene = hovered_scene()) -&gt; pos</code></pre><p>Return the current position of the mouse <code>pos</code> in <em>data points</em> of the given <code>scene</code>.</p><p>By default uses the <code>scene</code> that the mouse is currently hovering over.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.multipleplot!-Tuple" href="#AbstractPlotting.multipleplot!-Tuple"><code>AbstractPlotting.multipleplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.multipleplot!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.multipleplot!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.multipleplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.multipleplot!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.multipleplot!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.multipleplot!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.multipleplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.multipleplot!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.multipleplot!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.multipleplot!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.multipleplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.multipleplot-Tuple" href="#AbstractPlotting.multipleplot-Tuple"><code>AbstractPlotting.multipleplot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.multipleplot-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.multipleplot-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.multipleplot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.multipleplot(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.multipleplot(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.must_update-Tuple{}" href="#AbstractPlotting.must_update-Tuple{}"><code>AbstractPlotting.must_update</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns wether a scene needs updating</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.onpick" href="#AbstractPlotting.onpick"><code>AbstractPlotting.onpick</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">onpick(func, plot)</code></pre><p>Calls <code>func</code> if one clicks on <code>plot</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.pick" href="#AbstractPlotting.pick"><code>AbstractPlotting.pick</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Picks a mouse position</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple" href="#AbstractPlotting.plot!-Tuple"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.plot!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.plot!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.plot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.plot!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.plot!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.plot!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.plot!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple{Union{AbstractScene, ScenePlot},Union{Type{Any}, Type{#s830} where #s830&lt;:AbstractPlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.plot!-Tuple{Union{AbstractScene, ScenePlot},Union{Type{Any}, Type{#s830} where #s830&lt;:AbstractPlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Main plotting signatures that plot/plot! route to if no Plot Type is given</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.plot!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.plot!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple{Wireframe{...}}" href="#AbstractPlotting.plot!-Tuple{Wireframe{...}}"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">`wireframe(x, y, z)`, `wireframe(positions)`, or `wireframe(mesh)`</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot-Tuple" href="#AbstractPlotting.plot-Tuple"><code>AbstractPlotting.plot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.plot(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.plot-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.plot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.plot(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.plot(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly!-Tuple" href="#AbstractPlotting.poly!-Tuple"><code>AbstractPlotting.poly!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.poly!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.poly!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.poly!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.poly!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.poly!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.poly!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.poly!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.poly!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.poly!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.poly!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.poly!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.poly!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly-Tuple" href="#AbstractPlotting.poly-Tuple"><code>AbstractPlotting.poly</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.poly(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.poly-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.poly</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.poly(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.poly(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.record-NTuple{4,Any}" href="#AbstractPlotting.record-NTuple{4,Any}"><code>AbstractPlotting.record</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">record(func, scene, path, iter)</code></pre><p>usage:</p><pre><code class="language-example">    record(scene, &quot;test.gif&quot;, 1:100) do i
        scene.plots[:color] = ...# animate scene
    end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.record-Tuple{Any,Any,Any}" href="#AbstractPlotting.record-Tuple{Any,Any,Any}"><code>AbstractPlotting.record</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">record(func, scene, path)</code></pre><p>usage:</p><pre><code class="language-example">    record(scene, &quot;test.gif&quot;) do io
        for i = 1:100
            scene.plots[:color] = ...# animate scene
            recordframe!(io) # record a new frame
        end
    end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.record_events-Tuple{Any,Scene,String}" href="#AbstractPlotting.record_events-Tuple{Any,Scene,String}"><code>AbstractPlotting.record_events</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Record all window events that happen while executing function <code>f</code> for <code>scene</code> and serializes them to <code>path</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.recordframe!-Tuple{VideoStream}" href="#AbstractPlotting.recordframe!-Tuple{VideoStream}"><code>AbstractPlotting.recordframe!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Adds a video frame to the VideoStream</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.replace_automatic!-Tuple{Any,Any,Any}" href="#AbstractPlotting.replace_automatic!-Tuple{Any,Any,Any}"><code>AbstractPlotting.replace_automatic!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Like <code>get!(f, dict, key)</code> but also calls <code>f</code> and replaces <code>key</code> when the corresponding value is nothing</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.replay_events-Tuple{Scene,String}" href="#AbstractPlotting.replay_events-Tuple{Scene,String}"><code>AbstractPlotting.replay_events</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Replays the serialized events recorded with <code>record_events</code> in <code>path</code> in <code>scene</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter" href="#AbstractPlotting.scatter"><code>AbstractPlotting.scatter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`scatter(x, y, z)` / `scatter(x, y)` / `scatter(positions)`</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter!-Tuple" href="#AbstractPlotting.scatter!-Tuple"><code>AbstractPlotting.scatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatter!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.scatter!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.scatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatter!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatter!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.scatter!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.scatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatter!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatter!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.scatter!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.scatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatter!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter-Tuple" href="#AbstractPlotting.scatter-Tuple"><code>AbstractPlotting.scatter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatter(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.scatter-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.scatter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatter(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatter(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines!-Tuple" href="#AbstractPlotting.scatterlines!-Tuple"><code>AbstractPlotting.scatterlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.scatterlines!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.scatterlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatterlines!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.scatterlines!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.scatterlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatterlines!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.scatterlines!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.scatterlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines-Tuple" href="#AbstractPlotting.scatterlines-Tuple"><code>AbstractPlotting.scatterlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.scatterlines-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.scatterlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.scatterlines(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.scatterlines(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.select_rectangle-Tuple{Any}" href="#AbstractPlotting.select_rectangle-Tuple{Any}"><code>AbstractPlotting.select_rectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">select_rectangle(scene; kwargs...) -&gt; rect</code></pre><p>Interactively select a rectangle on a <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. The function returns an <strong>observable</strong> <code>rect</code> whose value corresponds to the selected rectangle on the scene. In addition the function <em>plots</em> the selected rectangle on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted rectangle disappears.</p><p>The value of the returned observable is updated <strong>only</strong> when the user un-clicks (i.e. when the final value of the rectangle has been decided) and only if the rectangle has area &gt; 0.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected rectangle.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series!-Tuple" href="#AbstractPlotting.series!-Tuple"><code>AbstractPlotting.series!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.series!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.series!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.series!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.series!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.series!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.series!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.series!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.series!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.series!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.series!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.series!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.series!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series-Tuple" href="#AbstractPlotting.series-Tuple"><code>AbstractPlotting.series</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.series(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.series-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.series</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.series(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.series(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider!-Tuple" href="#AbstractPlotting.slider!-Tuple"><code>AbstractPlotting.slider!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.slider!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.slider!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.slider!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.slider!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.slider!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.slider!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.slider!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.slider!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.slider!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.slider!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.slider!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.slider!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider-Tuple" href="#AbstractPlotting.slider-Tuple"><code>AbstractPlotting.slider</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.slider(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.slider-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.slider</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.slider(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.slider(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.step!-Tuple{Stepper}" href="#AbstractPlotting.step!-Tuple{Stepper}"><code>AbstractPlotting.step!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step!(s::Stepper)</code></pre><p>steps through a <code>Makie.Stepper</code> and outputs a file with filename <code>filename-step.jpg</code>. This is useful for generating progressive plot examples.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines!-Tuple" href="#AbstractPlotting.streamlines!-Tuple"><code>AbstractPlotting.streamlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.streamlines!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.streamlines!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.streamlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.streamlines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.streamlines!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.streamlines!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.streamlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.streamlines!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.streamlines!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.streamlines!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.streamlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.streamlines!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines-Tuple" href="#AbstractPlotting.streamlines-Tuple"><code>AbstractPlotting.streamlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.streamlines(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.streamlines-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.streamlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.streamlines(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.streamlines(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface" href="#AbstractPlotting.surface"><code>AbstractPlotting.surface</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`surface(x, y, z)`</code></pre><p>Plots a surface, where <code>(x, y, z)</code> are supposed to lie on a grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface!-Tuple" href="#AbstractPlotting.surface!-Tuple"><code>AbstractPlotting.surface!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.surface!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.surface!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.surface!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.surface!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.surface!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.surface!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.surface!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.surface!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.surface!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.surface!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.surface!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.surface!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface-Tuple" href="#AbstractPlotting.surface-Tuple"><code>AbstractPlotting.surface</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.surface(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.surface-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.surface</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.surface(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.surface(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text" href="#AbstractPlotting.text"><code>AbstractPlotting.text</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`text(string)`</code></pre><p>Plots a text.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text!-Tuple" href="#AbstractPlotting.text!-Tuple"><code>AbstractPlotting.text!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.text!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.text!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.text!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.text!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.text!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.text!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.text!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.text!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.text!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.text!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.text!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.text!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text-Tuple" href="#AbstractPlotting.text-Tuple"><code>AbstractPlotting.text</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.text(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.text-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.text</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.text(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.text(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_color-Tuple{Any}" href="#AbstractPlotting.to_color-Tuple{Any}"><code>AbstractPlotting.to_color</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_color(color)</code></pre><p>Converts a <code>color</code> symbol (e.g. <code>:blue</code>) to a color RGBA.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_colormap-Tuple{Any}" href="#AbstractPlotting.to_colormap-Tuple{Any}"><code>AbstractPlotting.to_colormap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_colormap(cm[, N = 20])</code></pre><p>Converts a colormap <code>cm</code> symbol (e.g. <code>:Spectral</code>) to a colormap RGB array, where <code>N</code> specifies the number of color points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume" href="#AbstractPlotting.volume"><code>AbstractPlotting.volume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">`volume(volume_data)`</code></pre><p>Plots a volume. Available algorithms are:</p><ul><li><code>:iso</code> =&gt; IsoValue</li><li><code>:absorption</code> =&gt; Absorption</li><li><code>:mip</code> =&gt; MaximumIntensityProjection</li><li><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</li><li><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume!-Tuple" href="#AbstractPlotting.volume!-Tuple"><code>AbstractPlotting.volume!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volume!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.volume!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.volume!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volume!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volume!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.volume!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.volume!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volume!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volume!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.volume!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.volume!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volume!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume-Tuple" href="#AbstractPlotting.volume-Tuple"><code>AbstractPlotting.volume</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volume(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.volume-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.volume</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volume(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volume(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices!-Tuple" href="#AbstractPlotting.volumeslices!-Tuple"><code>AbstractPlotting.volumeslices!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.volumeslices!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.volumeslices!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volumeslices!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.volumeslices!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.volumeslices!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volumeslices!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.volumeslices!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.volumeslices!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices-Tuple" href="#AbstractPlotting.volumeslices-Tuple"><code>AbstractPlotting.volumeslices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.volumeslices-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.volumeslices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.volumeslices(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.volumeslices(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe!-Tuple" href="#AbstractPlotting.wireframe!-Tuple"><code>AbstractPlotting.wireframe!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.wireframe!(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>current_scene()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe!-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.wireframe!-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.wireframe!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.wireframe!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.wireframe!(args...; attributes...) but accepts a theme as first argument. Adds new plot to <code>current_scene()</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.wireframe!-Tuple{Union{AbstractScene, ScenePlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.wireframe!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.wireframe!(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.wireframe!(scene, args...; attributes...) but accepts a theme as second argument. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}" href="#AbstractPlotting.wireframe!-Tuple{Union{AbstractScene, ScenePlot},Vararg{Any,N} where N}"><code>AbstractPlotting.wireframe!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.wireframe!(scene::SceneLike, args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Adds new plot to <code>scene</code>!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe-Tuple" href="#AbstractPlotting.wireframe-Tuple"><code>AbstractPlotting.wireframe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.wireframe(args...; attributes...)</code></pre><p>Command works on plot args 1:N and accepts keyword arguments to style the plot. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe-Tuple{Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.wireframe-Tuple{Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.wireframe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">AbstractPlotting.wireframe(attributes::Attributes, args...; attributes...)</code></pre><p>Like AbstractPlotting.wireframe(args...; attributes...) but accepts a theme as first argument. Creates a new scene!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.on-Tuple{Any,Camera,Vararg{Observables.Observable,N} where N}" href="#Observables.on-Tuple{Any,Camera,Vararg{Observables.Observable,N} where N}"><code>Observables.on</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>When mapping over nodes for the camera, we store them in the steering_node vector, to make it easier to disconnect the camera steering signals later!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Automatic" href="#AbstractPlotting.Automatic"><code>AbstractPlotting.Automatic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type to indicate that an attribute will get calculated automatically</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Plot-Union{Tuple{Vararg{Any,N}}, Tuple{N}} where N" href="#AbstractPlotting.Plot-Union{Tuple{Vararg{Any,N}}, Tuple{N}} where N"><code>AbstractPlotting.Plot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the Combined type that represents the signature of <code>args</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.apply_convert!-Tuple{Any,Attributes,Tuple}" href="#AbstractPlotting.apply_convert!-Tuple{Any,Attributes,Tuple}"><code>AbstractPlotting.apply_convert!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>apply for return type     (args...,)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.apply_convert!-Union{Tuple{S}, Tuple{Any,Attributes,PlotSpec{S}}} where S" href="#AbstractPlotting.apply_convert!-Union{Tuple{S}, Tuple{Any,Attributes,PlotSpec{S}}} where S"><code>AbstractPlotting.apply_convert!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>apply for return type PlotSpec</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.argument_names-Union{Tuple{P}, Tuple{P}} where P&lt;:AbstractPlot" href="#AbstractPlotting.argument_names-Union{Tuple{P}, Tuple{P}} where P&lt;:AbstractPlot"><code>AbstractPlotting.argument_names</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Each argument can be named for a certain plot type <code>P</code>. Falls back to <code>arg1</code>, <code>arg2</code>, etc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.atomic_limits-Union{Tuple{Union{Text{...}, MeshScatter{...}, Scatter{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Image{...}} where #s829&lt;:Tuple{Arg1}}, Tuple{Arg1}} where Arg1" href="#AbstractPlotting.atomic_limits-Union{Tuple{Union{Text{...}, MeshScatter{...}, Scatter{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Image{...}} where #s829&lt;:Tuple{Arg1}}, Tuple{Arg1}} where Arg1"><code>AbstractPlotting.atomic_limits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Data limits calculate a minimal boundingbox from the data points in a plot. This doesn&#39;t include any transformations, markers etc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.available_gradients-Tuple{}" href="#AbstractPlotting.available_gradients-Tuple{}"><code>AbstractPlotting.available_gradients</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">available_gradients()</code></pre><p>Prints all available gradient names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.available_marker_symbols-Tuple{}" href="#AbstractPlotting.available_marker_symbols-Tuple{}"><code>AbstractPlotting.available_marker_symbols</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">available_marker_symbols()</code></pre><p>Displays all available marker symbols.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.calculated_attributes!-Tuple{Any,Any}" href="#AbstractPlotting.calculated_attributes!-Tuple{Any,Any}"><code>AbstractPlotting.calculated_attributes!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">`calculated_attributes!(trait::Type{&lt;: AbstractPlot}, plot)`</code></pre><p>trait version of calculated_attributes</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.calculated_attributes!-Union{Tuple{T}, Tuple{T}} where T" href="#AbstractPlotting.calculated_attributes!-Union{Tuple{T}, Tuple{T}} where T"><code>AbstractPlotting.calculated_attributes!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">`calculated_attributes!(plot::AbstractPlot)`</code></pre><p>Fill in values that can only be calculated when we have all other attributes filled</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.close2square-Tuple{Real}" href="#AbstractPlotting.close2square-Tuple{Real}"><code>AbstractPlotting.close2square</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns (N1, N2) with <code>N1 x N2 == n</code>. N2 might become 1</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.current_scene-Tuple{}" href="#AbstractPlotting.current_scene-Tuple{}"><code>AbstractPlotting.current_scene</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the current active scene (the last scene that got created)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.default_plot_signatures-Tuple{Any,Any,Any}" href="#AbstractPlotting.default_plot_signatures-Tuple{Any,Any,Any}"><code>AbstractPlotting.default_plot_signatures</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none"> default_plot_signatures(funcname, PlotType)</code></pre><p>Creates all the different overloads for <code>funcname</code> that need to be supported for the plotting frontend! Since we add all these signatures to different functions, we make it reusable with this function</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.detach!-Tuple{Combined}" href="#AbstractPlotting.detach!-Tuple{Combined}"><code>AbstractPlotting.detach!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Remove <code>combined</code> from the current parent, and add it to a new subscene of the parent scene. Returns the new parent.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.dont_touch-Union{Tuple{N}, Tuple{GeometryPrimitive{N,T} where T,GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where N" href="#AbstractPlotting.dont_touch-Union{Tuple{N}, Tuple{GeometryPrimitive{N,T} where T,GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where N"><code>AbstractPlotting.dont_touch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Moves <code>child</code> so that it doesn&#39;t touch parent. Leaves a gap to parent defined by <code>pad</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.elconvert-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{Type{T1},AbstractArray{T2,N}}} where N where T2 where T1" href="#AbstractPlotting.elconvert-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{Type{T1},AbstractArray{T2,N}}} where N where T2 where T1"><code>AbstractPlotting.elconvert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Converts the elemen array type to <code>T1</code> without making a copy if the element type matches</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_factor-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N" href="#AbstractPlotting.fit_factor-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N"><code>AbstractPlotting.fit_factor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fit_factor(rect, lims::NTuple{N}) where N</code></pre><p>Calculates the scaling one needs to apply to lims to fit <code>rect</code> without changing aspect ratio. Returns float scaling and the full strech as given by <a href="#AbstractPlotting.fit_factor_stretch-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N"><code>fit_factor_stretch</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_factor_stretch-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N" href="#AbstractPlotting.fit_factor_stretch-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N"><code>AbstractPlotting.fit_factor_stretch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fit_factor_stretch(rect, lims::NTuple{N}) where N</code></pre><p>Calculates the stretch factor to fill <code>rect</code> in all dimension. Returns a stretch <code>N</code> dimensional fit factor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_ratio-Tuple{Any,Any}" href="#AbstractPlotting.fit_ratio-Tuple{Any,Any}"><code>AbstractPlotting.fit_ratio</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fit_ratio(rect, lims)</code></pre><p>Calculates the ratio one needs to stretch <code>lims</code> in order to get the same aspect ratio</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.flatten_combined" href="#AbstractPlotting.flatten_combined"><code>AbstractPlotting.flatten_combined</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Flattens all the combined plots and returns a Vector of Atomic plots</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.from_dict-Union{Tuple{T}, Tuple{Type{T},Any}} where T" href="#AbstractPlotting.from_dict-Union{Tuple{T}, Tuple{Type{T},Any}} where T"><code>AbstractPlotting.from_dict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">from_dict(::Type{T}, dict)</code></pre><p>Creates the type <code>T</code> from the fields in dict. Automatically converts to the correct node types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.frustum-Union{Tuple{T}, NTuple{6,T}} where T" href="#AbstractPlotting.frustum-Union{Tuple{T}, NTuple{6,T}} where T"><code>AbstractPlotting.frustum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Create view frustum

Parameters
----------
    left : float
     Left coordinate of the field of view.
    right : float
     Left coordinate of the field of view.
    bottom : float
     Bottom coordinate of the field of view.
    top : float
     Top coordinate of the field of view.
    znear : float
     Near coordinate of the field of view.
    zfar : float
     Far coordinate of the field of view.

Returns
-------
    M : array
     View frustum matrix (4x4).</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.interpolated_getindex-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractFloat}, Tuple{AbstractArray{T,N} where N,AbstractFloat,Any}} where T" href="#AbstractPlotting.interpolated_getindex-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractFloat}, Tuple{AbstractArray{T,N} where N,AbstractFloat,Any}} where T"><code>AbstractPlotting.interpolated_getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interpolated_getindex(cmap::AbstractArray, value::AbstractFloat, norm = (0.0, 1.0))</code></pre><p>Like getindex, but accepts values between 0..1 and interpolates those to the full range. You can use <code>norm</code>, to change the range of 0..1 to whatever you want.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lookat-Union{Tuple{T}, Tuple{Vec{3,T},Vec{3,T},Vec{3,T}}} where T" href="#AbstractPlotting.lookat-Union{Tuple{T}, Tuple{Vec{3,T},Vec{3,T},Vec{3,T}}} where T"><code>AbstractPlotting.lookat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>view = lookat(eyeposition, lookat, up)</code> creates a view matrix with the eye located at <code>eyeposition</code> and looking at position <code>lookat</code>, with the top of the window corresponding to the direction <code>up</code>. Only the component of <code>up</code> that is perpendicular to the vector pointing from <code>eyeposition</code> to <code>lookat</code> will be used.  All inputs must be supplied as 3-vectors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mergekeys!-Union{Tuple{N}, Tuple{Tuple{Vararg{Symbol,N}},Attributes,Attributes}} where N" href="#AbstractPlotting.mergekeys!-Union{Tuple{N}, Tuple{Tuple{Vararg{Symbol,N}},Attributes,Attributes}} where N"><code>AbstractPlotting.mergekeys!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mergekeys!(keys::NTuple{N, Symbol}, target::Attributes, source::Attributes)</code></pre><p>Merges only <code>keys</code> from <code>source</code> into <code>target</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mergekeys-Union{Tuple{N}, Tuple{Tuple{Vararg{Symbol,N}},Attributes,Attributes}} where N" href="#AbstractPlotting.mergekeys-Union{Tuple{N}, Tuple{Tuple{Vararg{Symbol,N}},Attributes,Attributes}} where N"><code>AbstractPlotting.mergekeys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mergekeys(keys::NTuple{N, Symbol}, target::Attributes, source::Attributes)</code></pre><p>Merges only <code>keys</code> from <code>source</code> into <code>target</code>. Creates a copy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.move_from_touch-Union{Tuple{T}, Tuple{N}, Tuple{GeometryPrimitive{N,T},GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where T where N" href="#AbstractPlotting.move_from_touch-Union{Tuple{T}, Tuple{N}, Tuple{GeometryPrimitive{N,T},GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where T where N"><code>AbstractPlotting.move_from_touch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>calculates how much <code>child</code> rectangle needs to move to not touch the <code>parent</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.notify!-Tuple{Observables.Observable}" href="#AbstractPlotting.notify!-Tuple{Observables.Observable}"><code>AbstractPlotting.notify!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Pushes an updates to all listeners of <code>node</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.perspectiveprojection-Union{Tuple{T}, NTuple{4,T}} where T" href="#AbstractPlotting.perspectiveprojection-Union{Tuple{T}, NTuple{4,T}} where T"><code>AbstractPlotting.perspectiveprojection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>proj = perspectiveprojection([T], fovy, aspect, znear, zfar)</code> defines a projection matrix with a given angular field-of-view <code>fovy</code> along the y-axis (measured in degrees), the specified <code>aspect</code> ratio, and near and far clipping planes <code>znear</code>, <code>zfar</code>. Optionally specify the element type <code>T</code> of the matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.perspectiveprojection-Union{Tuple{T}, Tuple{SimpleRectangle,T,T,T}} where T" href="#AbstractPlotting.perspectiveprojection-Union{Tuple{T}, Tuple{SimpleRectangle,T,T,T}} where T"><code>AbstractPlotting.perspectiveprojection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>proj = perspectiveprojection([T], rect, fov, near, far)</code> defines the projection ratio in terms of the rectangular view size <code>rect</code> rather than the aspect ratio.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plots_from_camera-Tuple{Scene}" href="#AbstractPlotting.plots_from_camera-Tuple{Scene}"><code>AbstractPlotting.plots_from_camera</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Fetches all plots sharing the same camera</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plottype-Tuple" href="#AbstractPlotting.plottype-Tuple"><code>AbstractPlotting.plottype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">`plot_type(plot_args...)`</code></pre><p>The default plot type for any argument is <code>lines</code>. Any custom argument combination that has only one meaningful way to be plotted should overload this. e.g.:</p><pre><code class="language-example">    # make plot(rand(5, 5, 5)) plot as a volume
    plottype(x::Array{&lt;: AbstractFlot, 3}) = Volume</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plottype-Union{Tuple{T}, Tuple{Type{#s828} where #s828&lt;:(Combined{Any,T} where T),Type{#s827} where #s827&lt;:(Combined{T,T1} where T1)}} where T" href="#AbstractPlotting.plottype-Union{Tuple{T}, Tuple{Type{#s828} where #s828&lt;:(Combined{Any,T} where T),Type{#s827} where #s827&lt;:(Combined{T,T1} where T1)}} where T"><code>AbstractPlotting.plottype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plottype(P1::Type{&lt;: Combined{T1}}, P2::Type{&lt;: Combined{T2}})</code></pre><p>Chooses the more concrete plot type ```example function convert_arguments(P::PlotFunc, args...)     ptype = plottype(P, Lines)     ... end</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.primary_resolution-Tuple{}" href="#AbstractPlotting.primary_resolution-Tuple{}"><code>AbstractPlotting.primary_resolution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the resolution of the primary monitor. If the primary monitor can&#39;t be accessed, returns (1920, 1080) (full hd)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.print_rec" href="#AbstractPlotting.print_rec"><code>AbstractPlotting.print_rec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">print_rec(io::IO, dict, indent::Int = 1[; extended = false])</code></pre><p>Traverses a dictionary <code>dict</code> and recursively print out its keys and values in a nicely-indented format.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.raw_boundingbox-Tuple{Union{Text{...}, MeshScatter{...}, Scatter{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Image{...}} where Arg}" href="#AbstractPlotting.raw_boundingbox-Tuple{Union{Text{...}, MeshScatter{...}, Scatter{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Image{...}} where Arg}"><code>AbstractPlotting.raw_boundingbox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Calculates the exact boundingbox of a Scene/Plot, without considering any transformation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.reasonable_resolution-Tuple{}" href="#AbstractPlotting.reasonable_resolution-Tuple{}"><code>AbstractPlotting.reasonable_resolution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns a reasonable resolution for the main monitor. (right now just half the resolution of the main monitor)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.resample-Tuple{AbstractArray{T,1} where T,Integer}" href="#AbstractPlotting.resample-Tuple{AbstractArray{T,1} where T,Integer}"><code>AbstractPlotting.resample</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">resample(A::AbstractVector, len::Integer)</code></pre><p>Resample a vector with linear interpolation to have length <code>len</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.resampled_colors-Tuple{Any,Integer}" href="#AbstractPlotting.resampled_colors-Tuple{Any,Integer}"><code>AbstractPlotting.resampled_colors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">resampled_colors(attributes::Attributes, levels::Integer)</code></pre><p>Resample the color attribute from <code>attributes</code>. Resamples <code>:colormap</code> if present, or repeats <code>:color</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.safe_off-Tuple{Observables.AbstractObservable,Any}" href="#AbstractPlotting.safe_off-Tuple{Observables.AbstractObservable,Any}"><code>AbstractPlotting.safe_off</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Observables.off but without throwing an error</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.save-Tuple{String,VideoStream}" href="#AbstractPlotting.save-Tuple{String,VideoStream}"><code>AbstractPlotting.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">save(path::String, io::VideoStream)</code></pre><p>Flushes the video stream and converts the file to the extension found in <code>path</code> which can be <code>mkv</code> is default and doesn&#39;t need convert, <code>gif</code>, <code>mp4</code> and <code>webm</code>. <code>mp4</code> is recommended for the internet, since it&#39;s the most supported format. <code>webm</code> yields the smallest file size, <code>mp4</code> and <code>mk4</code> are marginally bigger and <code>gif</code>s are up to 6 times bigger with same quality!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_func-Union{Tuple{Type{#s829} where #s829&lt;:AbstractPlot{F}}, Tuple{F}} where F" href="#AbstractPlotting.to_func-Union{Tuple{Type{#s829} where #s829&lt;:AbstractPlot{F}}, Tuple{F}} where F"><code>AbstractPlotting.to_func</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_func(Typ)</code></pre><p>Maps the input of a Type name to its cooresponding function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{AbstractArray{#s829,2} where #s829&lt;:ColorTypes.Colorant}" href="#AbstractPlotting.to_spritemarker-Tuple{AbstractArray{#s829,2} where #s829&lt;:ColorTypes.Colorant}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Any AbstractMatrix{&lt;: Colorant} or other image type</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{AbstractArray{T,1} where T}" href="#AbstractPlotting.to_spritemarker-Tuple{AbstractArray{T,1} where T}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Vector of anything that is accepted as a single marker will give each point it&#39;s own marker. Note that it needs to be a uniform vector with the same element type!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Array{#s829,2} where #s829&lt;:AbstractFloat}" href="#AbstractPlotting.to_spritemarker-Tuple{Array{#s829,2} where #s829&lt;:AbstractFloat}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Matrix of AbstractFloat will be interpreted as a distancefield (negative numbers outside shape, positive inside)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Char}" href="#AbstractPlotting.to_spritemarker-Tuple{Char}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_spritemarker(b, marker::Char)</code></pre><p>Any <code>Char</code>, including unicode</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{GeometryTypes.HyperSphere{2,T} where T}" href="#AbstractPlotting.to_spritemarker-Tuple{GeometryTypes.HyperSphere{2,T} where T}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_spritemarker(b, x::Circle)</code></pre><p><code>GeometryTypes.Circle(Point2(...), radius)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Symbol}" href="#AbstractPlotting.to_spritemarker-Tuple{Symbol}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>A <code>Symbol</code> - Available options can be printed with <code>available_marker_symbols()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Type{#s829} where #s829&lt;:(GeometryTypes.HyperSphere{2,T} where T)}" href="#AbstractPlotting.to_spritemarker-Tuple{Type{#s829} where #s829&lt;:(GeometryTypes.HyperSphere{2,T} where T)}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_spritemarker(b, ::Type{Circle})</code></pre><p><code>Type{GeometryTypes.Circle}</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Type{#s829} where #s829&lt;:GeometryTypes.SimpleRectangle}" href="#AbstractPlotting.to_spritemarker-Tuple{Type{#s829} where #s829&lt;:GeometryTypes.SimpleRectangle}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_spritemarker(b, ::Type{Rectangle})</code></pre><p><code>Type{GeometryTypes.Rectangle}</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_string-Tuple{Function}" href="#AbstractPlotting.to_string-Tuple{Function}"><code>AbstractPlotting.to_string</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_string(func)</code></pre><p>Turns the input of a function name or plot Type into a string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_type-Tuple{Function}" href="#AbstractPlotting.to_type-Tuple{Function}"><code>AbstractPlotting.to_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_type(func)</code></pre><p>Maps the input of a function name to its cooresponding Type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.used_attributes-Tuple{Any,Vararg{Any,N} where N}" href="#AbstractPlotting.used_attributes-Tuple{Any,Vararg{Any,N} where N}"><code>AbstractPlotting.used_attributes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">used_attributes(args...) = ()</code></pre><p>function used to indicate what keyword args one wants to get passed in <code>convert_arguments</code>. Usage:</p><pre><code class="language-example">    struct MyType end
    used_attributes(::MyType) = (:attribute,)
    function convert_arguments(x::MyType; attribute = 1)
        ...
    end
    # attribute will get passed to convert_arguments
    # without keyword_verload, this wouldn&#39;t happen
    plot(MyType, attribute = 2)
    #You can also use the convenience macro, to overload convert_arguments in one step:
    @keywords convert_argumetns(x::MyType; attribute = 1)
        ...
    end</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
