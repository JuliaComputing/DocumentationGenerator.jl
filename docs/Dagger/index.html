<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Dagger.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dagger.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.Context" href="#Dagger.Context"><code>Dagger.Context</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A context represents a set of processors to use for a papply operation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.OSProc" href="#Dagger.OSProc"><code>Dagger.OSProc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>OS process - contains pid returned by <code>addprocs</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.UnitDomain" href="#Dagger.UnitDomain"><code>Dagger.UnitDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Default domain – has no information about the value</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.alignfirst-Tuple{ArrayDomain}" href="#Dagger.alignfirst-Tuple{ArrayDomain}"><code>Dagger.alignfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">alignfirst(a)</code></pre><p>Make a subdomain a standalone domain. For example,</p><pre><code class="language-none">alignfirst(ArrayDomain(11:25, 21:100))
# =&gt; ArrayDomain((1:15), (1:80))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.cached_stage-Tuple{Any,Any}" href="#Dagger.cached_stage-Tuple{Any,Any}"><code>Dagger.cached_stage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>A memoized version of stage. It is important that the tasks generated for the same DArray have the same identity, for example:</p><pre><code class="language-none">A = rand(Blocks(100,100), Float64, 1000, 1000)
compute(A+A&#39;)</code></pre><p>must not result in computation of A twice.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.compute-Tuple{Any,Dagger.DArray}" href="#Dagger.compute-Tuple{Any,Dagger.DArray}"><code>Dagger.compute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>A DArray object may contain a thunk in it, in which case we first turn it into a Thunk object and then compute it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.compute-Tuple{Any,Thunk}" href="#Dagger.compute-Tuple{Any,Thunk}"><code>Dagger.compute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Compute a Thunk - creates the DAG, assigns ranks to nodes for tie breaking and runs the scheduler.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.domain" href="#Dagger.domain"><code>Dagger.domain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">domain(x::T)</code></pre><p>Returns metadata about <code>x</code>. This metadata will be in the <code>domain</code> field of a Chunk object when an object of type <code>T</code> is created as the result of evaluating a Thunk.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.domain-Tuple{AbstractArray}" href="#Dagger.domain-Tuple{AbstractArray}"><code>Dagger.domain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The domain of an array is a ArrayDomain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.domain-Tuple{Any}" href="#Dagger.domain-Tuple{Any}"><code>Dagger.domain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If no <code>domain</code> method is defined on an object, then we use the <code>UnitDomain</code> on it. A <code>UnitDomain</code> is indivisible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.load-Tuple{Any,AbstractString}" href="#Dagger.load-Tuple{Any,AbstractString}"><code>Dagger.load</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">load(ctx, file_path)</code></pre><p>Load an Union{Chunk, Thunk} from a file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.load-Tuple{Any,Type{Dagger.Chunk},Any,Any,Any}" href="#Dagger.load-Tuple{Any,Type{Dagger.Chunk},Any,Any,Any}"><code>Dagger.load</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">load(ctx, ::Type{Chunk}, fpath, io)</code></pre><p>Load a Chunk object from a file, the file path is required for creating a FileReader object</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.save-Tuple{Any,IO,Any}" href="#Dagger.save-Tuple{Any,IO,Any}"><code>Dagger.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">save(io::IO, val)</code></pre><p>Save a value into the IO buffer. In the case of arrays and sparse matrices, this will save it in a memory-mappable way.</p><p><code>load(io::IO, t::Type, domain)</code> will load the object given its domain</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.save-Tuple{Any,Union{Thunk, Chunk},AbstractString}" href="#Dagger.save-Tuple{Any,Union{Thunk, Chunk},AbstractString}"><code>Dagger.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">save(ctx, chunk::Union{Chunk, Thunk}, file_path::AbsractString)</code></pre><p>Save a chunk to a file at <code>file_path</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.save-Union{Tuple{X}, Tuple{Any,Chunk{X,DRef},AbstractString}} where X" href="#Dagger.save-Union{Tuple{X}, Tuple{Any,Chunk{X,DRef},AbstractString}} where X"><code>Dagger.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>special case distmem writing - write to disk on the process with the chunk.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.Chunk" href="#Dagger.Chunk"><code>Dagger.Chunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A chunk with some data</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.DArray" href="#Dagger.DArray"><code>Dagger.DArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>DArray{T,N,F}(domain, subdomains, chunks, concat)</code></p><p>An N-dimensional distributed array of element type T.</p><ul><li><code>domain</code>: the whole ArrayDomain of the array</li><li><code>subdomains</code>: a <code>DomainBlocks</code> of the same dimensions as the array</li><li><code>chunks</code>: an array of chunks of dimension N</li><li><code>concat</code>: a function of type <code>F</code>. <code>concat(x, y; dims=d)</code> takes two chunks <code>x</code> and <code>y</code>           and concatenates them along dimension <code>d</code>. <code>cat</code> is used by default.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.DArray-Union{Tuple{N}, Tuple{Any,ArrayDomain{N},AbstractArray{ArrayDomain{N},N},AbstractArray{#s17,N} where #s17}, Tuple{Any,ArrayDomain{N},AbstractArray{ArrayDomain{N},N},AbstractArray{#s16,N} where #s16,Any}} where N" href="#Dagger.DArray-Union{Tuple{N}, Tuple{Any,ArrayDomain{N},AbstractArray{ArrayDomain{N},N},AbstractArray{#s17,N} where #s17}, Tuple{Any,ArrayDomain{N},AbstractArray{ArrayDomain{N},N},AbstractArray{#s16,N} where #s16,Any}} where N"><code>Dagger.DArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>DArray(T, domain, subdomains, chunks, [concat=cat])</code></p><p>Creates a distributed array of element type T.</p><ul><li><code>T</code>: element type</li></ul><p>rest of the arguments are the same as the DArray constructor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.LocalEventLog" href="#Dagger.LocalEventLog"><code>Dagger.LocalEventLog</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>represents a process local events array.</p><p>A context with log_sink set to LocalEventLog() will cause events to be recorded into the </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.NoOpLog" href="#Dagger.NoOpLog"><code>Dagger.NoOpLog</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Various means of writing an event to something.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.PromotePartition" href="#Dagger.PromotePartition"><code>Dagger.PromotePartition</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This is a way of suggesting that stage should call stage_operand with the operation and other arguments</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.State" href="#Dagger.State"><code>Dagger.State</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Overall state used during visualization</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.Timespan" href="#Dagger.Timespan"><code>Dagger.Timespan</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>identifies</p><p>space (category, id) time (timeline, start, finish)</p><p>also tracks gc_num during this and profiling samples.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.view-Tuple{Dagger.DArray,Any}" href="#Base.view-Tuple{Dagger.DArray,Any}"><code>Base.view</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>view</code> of a <code>DArray</code> chunk returns a <code>DArray</code> of thunks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.add_span-NTuple{4,Any}" href="#Dagger.add_span-NTuple{4,Any}"><code>Dagger.add_span</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add a Timespan to a given State under <code>tl</code> (timeline) and <code>category</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.dependents" href="#Dagger.dependents"><code>Dagger.dependents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>find the set of direct dependents for each task</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.dsort_chunks" href="#Dagger.dsort_chunks"><code>Dagger.dsort_chunks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dsort_chunks(cs, [nchunks, nsamples]; options...)</code></p><p>Sort contents of chunks (<code>cs</code>) and return a new set of chunks such that the chunks when concatenated return a sorted collection. Each chunk in turn is sorted.</p><p>Args:</p><ul><li><code>nchunks</code> – the number of chunks to produce, regardless of how many chunks were given as input</li><li><code>nsamples</code> – the number of elements to sample from each chunk to guess the splitters (<code>nchunks-1</code> splitters) each chunk will be delimited by the splitter.</li><li><code>merge</code> – a function to merge two sorted collections.</li><li><code>sub</code> – a function to get a subset of the collection takes (collection, range) (defaults to <code>getindex</code>)</li><li><code>order</code> – <code>Base.Sort.Ordering</code> to be used for sorting</li><li><code>batchsize</code> – number of chunks to split and merge at a time (e.g. if there are 128 input chunks and 128 output chunks, and batchsize is 8, then we first sort among batches of 8 chunks – giving 16 batches. Then we sort among the first chunk of the first 8 batches (all elements less than the first splitter), then go on to the first 8 chunks of the second 8 batches, and so on...</li><li><code>chunks_presorted</code> – is each chunk in the input already sorted?</li><li><code>sortandsample</code> – a function to sort a chunk, then sample N elements to infer the splitters. It takes 3 arguments: (collection, N, presorted). presorted is a boolean which is true if the chunk is already sorted.</li></ul><p>Returns a tuple of <code>(chunk, samples)</code> where <code>chunk</code> is the <code>Dagger.Chunk</code> object. <code>chunk</code> can be nothing if no change to the initial array was made (e.g. it was already sorted)</p><ul><li><code>affinities</code> – a list of processes where the output chunks should go. If the length is not equal to <code>nchunks</code> then affinities array is cycled through.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.get_logs!-Tuple{Dagger.LocalEventLog}" href="#Dagger.get_logs!-Tuple{Dagger.LocalEventLog}"><code>Dagger.get_logs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the logs from each process, clear it too</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.make_timespan-Tuple{Dagger.Event,Dagger.Event}" href="#Dagger.make_timespan-Tuple{Dagger.Event,Dagger.Event}"><code>Dagger.make_timespan</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>create a timespan given the strt and finish events</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.next_state-Tuple{Dagger.State,Dagger.Event{:start}}" href="#Dagger.next_state-Tuple{Dagger.State,Dagger.Event{:start}}"><code>Dagger.next_state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>When building state for real-time visualization, use next_state to progress gantt state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.noffspring-Tuple{Dict}" href="#Dagger.noffspring-Tuple{Dict}"><code>Dagger.noffspring</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>recursively find the number of taks dependent on each task in the DAG. Input: dependents dict</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.order-Tuple{Thunk,Any}" href="#Dagger.order-Tuple{Thunk,Any}"><code>Dagger.order</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Given a root node of the DAG, calculates a total order for tie-braking</p><ul><li>Root node gets score 1,</li><li>rest of the nodes are explored in DFS fashion but chunks of each node are explored in order of <code>noffspring</code>, i.e. total number of tasks depending on the result of the said node.</li></ul><p>Args:     - node: root node     - ndeps: result of <code>noffspring</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.recursive_splitters-NTuple{4,Any}" href="#Dagger.recursive_splitters-NTuple{4,Any}"><code>Dagger.recursive_splitters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>split the splitters themselves into batches.</p><p>Args:</p><ul><li><code>ord</code> – <code>Sorting.Ordering</code> object</li><li><code>splitters</code> – the <code>nchunks-1</code> splitters</li><li><code>batchsize</code> – batch size</li></ul><p>Returns: A Tuple{Vector, Vector{Vector}} – the coarse splitters which create <code>batchsize</code> splits, finer splitters within those batches which create a total of <code>nchunks</code> splits.</p><pre><code class="language-julia">julia&gt; Dagger.recursive_splitters(Dagger.default_ord,
            [10,20,30,40,50,60], 5,3)
([30], Any[[10, 20], [40, 50, 60]])</code></pre><p>The first value <code>[30]</code> represents a coarse split that cuts the dataset from -Inf-30, and 30-Inf. Each part is further recursively split using the next set of splitters</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.split_range-Union{Tuple{T}, Tuple{AbstractRange{T},Any}} where T" href="#Dagger.split_range-Union{Tuple{T}, Tuple{AbstractRange{T},Any}} where T"><code>Dagger.split_range</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Utility function to divide the range <code>range</code> into <code>n</code> chunks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.split_range_interval-Tuple{Any,Any}" href="#Dagger.split_range_interval-Tuple{Any,Any}"><code>Dagger.split_range_interval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">split_range_interval(range, n)</code></pre><p>split a range into pieces each of length <code>n</code> or lesser</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.stage_operands-Union{Tuple{T}, Tuple{Any,MatMul,ArrayOp,PromotePartition{T,1}}} where T" href="#Dagger.stage_operands-Union{Tuple{T}, Tuple{Any,MatMul,ArrayOp,PromotePartition{T,1}}} where T"><code>Dagger.stage_operands</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>an operand which should be distributed as per convenience</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.thunkize-Tuple{Any,Dagger.DArray}" href="#Dagger.thunkize-Tuple{Any,Dagger.DArray}"><code>Dagger.thunkize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If a DArray tree has a Thunk in it, make the whole thing a big thunk</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.tochunk-Tuple{Any}" href="#Dagger.tochunk-Tuple{Any}"><code>Dagger.tochunk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create a chunk from a sequential object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.treereduce-Tuple{Any,Any}" href="#Dagger.treereduce-Tuple{Any,Any}"><code>Dagger.treereduce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Tree reduce</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.write_event-Tuple{Dagger.Context,Dagger.Event}" href="#Dagger.write_event-Tuple{Dagger.Context,Dagger.Event}"><code>Dagger.write_event</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Write a log event</p></div></div></section><footer><hr/></footer></article></body></html>
