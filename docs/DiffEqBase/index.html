<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DiffEqBase.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DiffEqBase.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.AffineDiffEqOperator" href="#DiffEqBase.AffineDiffEqOperator"><code>DiffEqBase.AffineDiffEqOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>AffineDiffEqOperator{T} &lt;: AbstractDiffEqOperator{T}</p><p><code>Ex: (A₁(t) + ... + Aₙ(t))*u + B₁(t) + ... + Bₙ(t)</code></p><p>AffineDiffEqOperator{T}(As,Bs,u_cache=nothing)</p><p>Takes in two tuples for split Affine DiffEqs</p><ol><li>update_coefficients! works by updating the coefficients of the component operators.</li><li>Function calls L(u,p,t) and L(u,p,t,du) are fallbacks interpretted in this form. This will allow them to work directly in the nonlinear ODE solvers without modification.</li><li>f(u,p,t,du) is only allowed if a u_cache is given</li><li>B(t) can be Union{Number,AbstractArray}, in which case they are constants. Otherwise they are interpreted they are functions v=B(t) and B(v,t)</li></ol><p>Solvers will see this operator from integrator.f and can interpret it by checking the internals of As and Bs. For example, it can check is_constant(As[1]) etc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.check_error-Tuple{DiffEqBase.DEIntegrator}" href="#DiffEqBase.check_error-Tuple{DiffEqBase.DEIntegrator}"><code>DiffEqBase.check_error</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">check_error(integrator)</code></pre><p>Check state of <code>integrator</code> and return one of the <a href="http://docs.juliadiffeq.org/latest/basics/solution.html#Return-Codes-(RetCodes)-1">Return Codes</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.reeval_internals_due_to_modification!-Tuple{DiffEqBase.DEIntegrator}" href="#DiffEqBase.reeval_internals_due_to_modification!-Tuple{DiffEqBase.DEIntegrator}"><code>DiffEqBase.reeval_internals_due_to_modification!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reeval_internals_due_to_modification!(integrator::DDEIntegrator)</code></pre><p>Recalculate interpolation data and update ODE integrator after changes by callbacks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.remake-Tuple{Any}" href="#DiffEqBase.remake-Tuple{Any}"><code>DiffEqBase.remake</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remake(thing; &lt;keyword arguments&gt;)</code></pre><p>Re-construct <code>thing</code> with new field values specified by the keyword arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.set_t!-Tuple{DiffEqBase.DEIntegrator,Real}" href="#DiffEqBase.set_t!-Tuple{DiffEqBase.DEIntegrator,Real}"><code>DiffEqBase.set_t!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_t!(integrator::DEIntegrator, t::Real)</code></pre><p>Set current time point of the <code>integrator</code> to <code>t</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.set_u!-Tuple{DiffEqBase.DEIntegrator,Any}" href="#DiffEqBase.set_u!-Tuple{DiffEqBase.DEIntegrator,Any}"><code>DiffEqBase.set_u!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_u!(integrator::DEIntegrator, u)</code></pre><p>Set current state of the <code>integrator</code> to <code>u</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.step!-Tuple{DiffEqBase.DEIntegrator}" href="#DiffEqBase.step!-Tuple{DiffEqBase.DEIntegrator}"><code>DiffEqBase.step!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">step!(integ::DEIntegrator [, dt [, stop_at_tdt]])</code></pre><p>Perform one (successful) step on the integrator.</p><p>Alternative, if a <code>dt</code> is given, then <code>step!</code> the integrator until there is a temporal difference <code>≥ dt</code> in <code>integ.t</code>.  When <code>true</code> is passed to the optional third argument, the integrator advances exactly <code>dt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.u_modified!-Tuple{DiffEqBase.DEIntegrator,Any}" href="#DiffEqBase.u_modified!-Tuple{DiffEqBase.DEIntegrator,Any}"><code>DiffEqBase.u_modified!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">savevalues!(integrator::DEIntegrator,
  force_save=false) -&gt; Tuple{Bool, Bool}</code></pre><p>Try to save the state and time variables at the current time point, or the <code>saveat</code> point by using interpolation when appropriate. It returns a tuple that is <code>(saved, savedexactly)</code>. If <code>savevalues!</code> saved value, then <code>saved</code> is true, and if <code>savevalues!</code> saved at the current time point, then <code>savedexactly</code> is true.</p><p>The saving priority/order is as follows:</p><ul><li><code>save_on</code><ul><li><code>saveat</code></li><li><code>force_save</code></li><li><code>save_everystep</code>/<code>timeseries_steps</code></li></ul></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.ExplicitRKTableau" href="#DiffEqBase.ExplicitRKTableau"><code>DiffEqBase.ExplicitRKTableau</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>ExplicitRKTableau</code></p><p>Holds a tableau which defines an explicit Runge-Kutta method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.ImplicitRKTableau" href="#DiffEqBase.ImplicitRKTableau"><code>DiffEqBase.ImplicitRKTableau</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>ImplicitRKTableau</code></p><p>Holds a tableau which defines an implicit Runge-Kutta method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.check_error!-Tuple{DiffEqBase.DEIntegrator}" href="#DiffEqBase.check_error!-Tuple{DiffEqBase.DEIntegrator}"><code>DiffEqBase.check_error!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">check_error!(integrator)</code></pre><p>Same as <code>check_error</code> but also set solution&#39;s return code (<code>integrator.sol.retcode</code>) and run <code>postamble!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.copy_fields-Tuple{AbstractArray,DEDataArray}" href="#DiffEqBase.copy_fields-Tuple{AbstractArray,DEDataArray}"><code>DiffEqBase.copy_fields</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">copy_fields(arr:AbstractArray, template::DEDataArray)</code></pre><p>Create <code>DEDataArray</code> that wraps <code>arr</code> with all other fields set to a deep copy of the value in <code>template</code>.</p><p>copy_fields!(dest::T, src::T2) where {T&lt;:DEDataArray,T2&lt;:DEDataArray}</p><p>Replace all fields of <code>dest</code> except of its wrapped array with a copy of the value in <code>src</code>. Arrays are recursively copied.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.ConstantInterpolation,Any,Any,Any,Any,Type{Val{0}}}" href="#DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.ConstantInterpolation,Any,Any,Any,Any,Type{Val{0}}}"><code>DiffEqBase.interpolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Constant Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.ConstantInterpolation,Any,Any,Any,Any,Type{Val{1}}}" href="#DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.ConstantInterpolation,Any,Any,Any,Any,Type{Val{1}}}"><code>DiffEqBase.interpolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Constant Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{0}}}" href="#DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{0}}}"><code>DiffEqBase.interpolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hairer Norsett Wanner Solving Ordinary Differential Euations I - Nonstiff Problems Page 190</p><p>Hermite Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{1}}}" href="#DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{1}}}"><code>DiffEqBase.interpolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hermite Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{2}}}" href="#DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{2}}}"><code>DiffEqBase.interpolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hermite Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{3}}}" href="#DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{3}}}"><code>DiffEqBase.interpolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hermite Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.LinearInterpolation,Any,Any,Any,Any,Type{Val{0}}}" href="#DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.LinearInterpolation,Any,Any,Any,Any,Type{Val{0}}}"><code>DiffEqBase.interpolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Linear Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.LinearInterpolation,Any,Any,Any,Any,Type{Val{1}}}" href="#DiffEqBase.interpolant!-Tuple{Any,Any,DiffEqBase.LinearInterpolation,Any,Any,Any,Any,Type{Val{1}}}"><code>DiffEqBase.interpolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Linear Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant-Tuple{Any,DiffEqBase.ConstantInterpolation,Any,Any,Any,Any,Type{Val{0}}}" href="#DiffEqBase.interpolant-Tuple{Any,DiffEqBase.ConstantInterpolation,Any,Any,Any,Any,Type{Val{0}}}"><code>DiffEqBase.interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Constant Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant-Tuple{Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{0}}}" href="#DiffEqBase.interpolant-Tuple{Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{0}}}"><code>DiffEqBase.interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hairer Norsett Wanner Solving Ordinary Differential Equations I - Nonstiff Problems Page 190</p><p>Hermite Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant-Tuple{Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{1}}}" href="#DiffEqBase.interpolant-Tuple{Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{1}}}"><code>DiffEqBase.interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hermite Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant-Tuple{Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{2}}}" href="#DiffEqBase.interpolant-Tuple{Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{2}}}"><code>DiffEqBase.interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hermite Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant-Tuple{Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{3}}}" href="#DiffEqBase.interpolant-Tuple{Any,DiffEqBase.HermiteInterpolation,Any,Any,Any,Any,Any,Any,Type{Val{3}}}"><code>DiffEqBase.interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hermite Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolant-Tuple{Any,DiffEqBase.LinearInterpolation,Any,Any,Any,Any,Type{Val{0}}}" href="#DiffEqBase.interpolant-Tuple{Any,DiffEqBase.LinearInterpolation,Any,Any,Any,Any,Type{Val{0}}}"><code>DiffEqBase.interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Linear Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolation" href="#DiffEqBase.interpolation"><code>DiffEqBase.interpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>interpolation(tval::Number,t,u,ks)</p><p>Get the value at tval where the solution is known at the times t (sorted), with values u and derivatives ks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolation!" href="#DiffEqBase.interpolation!"><code>DiffEqBase.interpolation!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>interpolation(tvals,t,u,ks)</p><p>Get the value at tvals where the solution is known at the times t (sorted), with values u and derivatives ks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.interpolation!" href="#DiffEqBase.interpolation!"><code>DiffEqBase.interpolation!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>interpolation!(out,tval::Number,t,u,ks)</p><p>Get the value at tval where the solution is known at the times t (sorted), with values u and derivatives ks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.numargs-Tuple{Any}" href="#DiffEqBase.numargs-Tuple{Any}"><code>DiffEqBase.numargs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>numparameters(f)</code></p><p>Returns the number of parameters of <code>f</code> for the method which has the most parameters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.set_ut!-Tuple{DiffEqBase.DEIntegrator,Any,Any}" href="#DiffEqBase.set_ut!-Tuple{DiffEqBase.DEIntegrator,Any,Any}"><code>DiffEqBase.set_ut!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_ut!(integrator::DEIntegrator, u, t)</code></pre><p>Set current state of the <code>integrator</code> to <code>u</code> and <code>t</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.undefined_exports-Tuple{Any}" href="#DiffEqBase.undefined_exports-Tuple{Any}"><code>DiffEqBase.undefined_exports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">undefined_exports(mod)</code></pre><p>List symbols <code>export</code>&#39;ed but not actually defined.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RecursiveArrayTools.recursivecopy!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:DEDataArray" href="#RecursiveArrayTools.recursivecopy!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:DEDataArray"><code>RecursiveArrayTools.recursivecopy!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">recursivecopy!(dest::T, src::T) where {T&lt;:DEDataArray}</code></pre><p>Recursively copy fields of <code>src</code> to <code>dest</code>.</p></div></div></section><footer><hr/></footer></article></body></html>
