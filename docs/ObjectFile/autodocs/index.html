<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ObjectFile.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ObjectFile.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.DynamicLink" href="#ObjectFile.DynamicLink"><code>ObjectFile.DynamicLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DynamicLink</code></pre><p>This type encapsulates the linkage of one object file to another.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>DynamicLink()</em></li></ul><p><strong>Accessors:</strong></p><ul><li><em>DynamicLinks()</em></li><li><em>handle()</em></li><li><em>path()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.DynamicLinks" href="#ObjectFile.DynamicLinks"><code>ObjectFile.DynamicLinks</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DynamicLinks</code></pre><p>This type encapsulates the list of dynamic links within an object, holding a collection of <code>DynamicLink</code> objects.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>DynamicLinks()</em></li></ul><p><strong>Iteration</strong></p><ul><li><em>getindex()</em></li><li><em>lastindex()</em></li><li>iterate()</li><li>eltype()</li></ul><p><strong>Misc.</strong></p><ul><li><em>handle()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.MagicMismatch" href="#ObjectFile.MagicMismatch"><code>ObjectFile.MagicMismatch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MagicMismatch</code></pre><p>This is an error type used to denote that <code>readmeta()</code> was called on a file that does not contain the proper magic at the beginning for the type of object file that was attempting to be loaded.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.ObjectHandle" href="#ObjectFile.ObjectHandle"><code>ObjectFile.ObjectHandle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ObjectHandle</code></pre><p>The basic type that provides access to object files.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis.  Note tha &quot;must implement&quot; is a bit of a misnomer, if an Object file does not have need of a certain piece of this API (e.g. <code>COFF</code> files have no concept of <code>Segment</code>s), leaving that chunk of the API undefined will simply cause errors if a user attempts to use methods that use that part of the API (in the example above, an error will be thrown if the user calls <code>Segments(oh)</code> where <code>oh &lt;: COFFHandle</code>).</p><p><strong>Creation</strong></p><ul><li><em>readmeta()</em></li></ul><p><strong>IOStream-like operations:</strong></p><ul><li>seek()</li><li>seekstart()</li><li>skip()</li><li>startaddr()</li><li>iostream()</li><li>position()</li><li>read()</li><li>readuntil()</li><li>eof()</li><li>unpack()</li></ul><p><strong>Format-specific properties</strong></p><ul><li><em>endianness()</em></li><li><em>is64bit()</em></li><li><em>isrelocatable()</em></li><li><em>isexecutable()</em></li><li><em>islibrary()</em></li><li><em>isdynamic()</em></li><li><em>mangle<em>section</em>name()</em></li><li><em>mangle<em>symbol</em>name()</em></li><li>handle()</li><li><em>header()</em></li><li><em>format_string()</em></li></ul><p><strong>Section properties</strong></p><ul><li><em>section<em>header</em>offset()</em></li><li><em>section<em>header</em>size()</em></li><li><em>section<em>header</em>type()</em></li></ul><p><strong>Segment properties</strong></p><ul><li><em>segment<em>header</em>offset()</em></li><li><em>segment<em>header</em>size()</em></li><li><em>segment<em>header</em>type()</em></li></ul><p><strong>Symbol properties</strong></p><ul><li><em>symtab<em>entry</em>offset()</em></li><li><em>symtab<em>entry</em>size()</em></li><li><em>symtab<em>entry</em>type()</em></li></ul><p><strong>Misc</strong></p><ul><li><em>path()</em></li><li>show()</li><li>find_library()</li><li>find_libraries()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.RPath" href="#ObjectFile.RPath"><code>ObjectFile.RPath</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RPath</code></pre><p>This type encapsulates the search path used by an object file when looking for a shared library.  This class enables not only looking at the path, but querying the path for matches for given library names.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>RPath()</em></li></ul><p><strong>Utility</strong></p><ul><li><em>handle()</em></li></ul><p><strong>RPath operations</strong></p><ul><li><em>rpaths()</em></li><li>canonical_rpaths()</li><li>find_library()</li><li>lastindex()</li><li>iterate()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.RPath-Tuple{ObjectHandle}" href="#ObjectFile.RPath-Tuple{ObjectHandle}"><code>ObjectFile.RPath</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">RPath(oh::ObjectHandle)</code></pre><p>Construct an <code>RPath</code> object from the given <code>ObjectHandle</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Section" href="#ObjectFile.Section"><code>ObjectFile.Section</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Section</code></pre><p>An abstraction over the concept of a <code>Section</code> within an object file.  Because many operations upon sections require global operations (access to the string table, knowledge of position within the file, etc...) some operations are defined only upon the <code>SectionRef</code> datatype.  As a user, the <code>SectionRef</code> type should be the primary method of interacting with sections, as a developer adding new object file formats, some methods must support <code>Section</code>s, others must support only <code>SectionRef</code>s.  Note that any method that works on a <code>Section</code> must also work with a <code>SectionRef</code>, see the <code>@derefmethod</code> macro for a convenient helper macro to generate <code>SectionRef</code> -&gt; <code>Section</code> wrapper methods. The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>read()</em></li></ul><p><strong>Utility:</strong></p><ul><li>deref()</li></ul><p><strong>IO-like operations:</strong></p><ul><li>contents()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li><em>section_name()</em></li><li><em>section_size()</em></li><li><em>section_offset()</em></li><li><em>section_address()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SectionRef" href="#ObjectFile.SectionRef"><code>ObjectFile.SectionRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SectionRef</code></pre><p>Provides a reference to a <code>Section</code>, along with a reference to the <code>ObjectHandle</code> this <code>Section</code> comes from.  This should be the primary method by which users interact with sections inside object files.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis.  Note that this overlaps heavily with the <code>Section</code> object API, this is by design as many of the methods are simply passthroughs to the underlying <code>Section</code> API calls for ease of use.</p><p><strong>Creation:</strong></p><ul><li><em>SectionRef()</em></li></ul><p><strong>Utility</strong></p><ul><li><em>deref()</em></li><li><em>handle()</em></li><li><em>Sections()</em></li></ul><p><strong>IO-like operations:</strong></p><ul><li>read()</li><li>seekstart()</li><li>seek()</li><li>eof()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li>section_name()</li><li><em>section_number()</em></li><li>section_type()</li><li>section_size()</li><li>section_offset()</li><li>section_address()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SectionRef-Tuple{Sections,Section,Any}" href="#ObjectFile.SectionRef-Tuple{Sections,Section,Any}"><code>ObjectFile.SectionRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SectionRef(sections::Sections, section::Section, idx)</code></pre><p>Construct a <code>SectionRef</code> object pointing to the given <code>Section</code>, which itself represents the <code>idx</code>&#39;th section within the given <code>Sections</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Sections" href="#ObjectFile.Sections"><code>ObjectFile.Sections</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Sections</code></pre><p>An abstraction over the concept of a collection of <code>Section</code> types within an object file.  One can think of the <code>Sections</code> object containing the table of section headers within the object file, whereas the <code>Section</code>/<code>SectionRef</code> objects contain the actual section data itself.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>Sections()</em></li></ul><p><strong>Iteration</strong></p><ul><li>getindex()</li><li><em>lastindex()</em></li><li>length()</li><li>iterate()</li><li>eltype()</li></ul><p><strong>Search</strong></p><ul><li>findall()</li><li>findfirst()</li></ul><p><strong>Misc.</strong></p><ul><li><em>handle()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Sections-Tuple{SectionRef}" href="#ObjectFile.Sections-Tuple{SectionRef}"><code>ObjectFile.Sections</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Sections(section::SectionRef)</code></pre><p>Return the <code>Sections</code> collection this <code>section</code> belongs to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Segment" href="#ObjectFile.Segment"><code>ObjectFile.Segment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Segment</code></pre><p>An abstraction over the concept of a <code>Segment</code> within an object file.  A <code>Segment</code> is a portion of an object file that is given instruction on its layout in virtual memory; this is in contrast to a <code>Section</code>, which delineates different portions of an object file on disk.  ELF files have the strictest separation here, with a single executable file containing multiple <code>Segment</code> and <code>Section</code> objects, with <code>Section</code>s being assigned to one or more <code>Segment</code>s for virtual memory placement.  Mach-O files typically have two <code>Segment</code>s, one called <code>__TEXT</code>, one called <code>__DATA</code>.  COFF files do not have <code>Segment</code>.</p><p>Just like with <code>Section</code> objects, many operations upon segments require global operations (access to the string table, knowledge of position within the file, etc...) which causes some operations to be defined only upon the <code>SegmentRef</code> datatype.  As a user, the <code>SegmentRef</code> type should be the primary method of interacting with segments, as a developer adding new object file formats, some methods must support <code>Segment</code>s, others must support only <code>SegmentRef</code>s. Note that any method that works on a <code>Segment</code> must also work with a <code>SegmentRef</code>, see the <code>@derefmethod</code> macro for a convenient helper macro to generate <code>SegmentRef</code> -&gt; <code>Section</code> wrapper methods. The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>read()</em></li></ul><p><strong>Utility:</strong></p><ul><li>deref()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li><em>segment_name()</em></li><li><em>segment_offset()</em></li><li><em>segment<em>file</em>size()</em></li><li><em>segment<em>memory</em>size()</em></li><li><em>segment_address()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SegmentRef" href="#ObjectFile.SegmentRef"><code>ObjectFile.SegmentRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SegmentRef</code></pre><p>Provides a reference to a <code>Segment</code>, along with a reference to the <code>ObjectHandle</code> this <code>Segment</code> comes from.  This should be the primary method by which users interact with segments inside object files.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis.  Note that this overlaps heavily with the <code>Segment</code> object API, this is by design as many of the methods are simply passthroughs to the underlying <code>Segment</code> API calls for ease of use.</p><p><strong>Creation:</strong></p><ul><li><em>SegmentRef()</em></li></ul><p><strong>Utility</strong></p><ul><li><em>deref()</em></li><li><em>Segments()</em></li><li>handle()</li></ul><p><strong>Format-specific properties:</strong></p><ul><li><em>segment_name()</em></li><li><em>segment_number()</em></li><li>segment_offset()</li><li>segment<em>file</em>size()</li><li>segment<em>memory</em>size()</li><li>segment_address()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Segments" href="#ObjectFile.Segments"><code>ObjectFile.Segments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Segments</code></pre><p>An abstraction over the concept of a collection of <code>Segment</code> types within an object file.  One can think of the <code>Segments</code> object containing the table of segment headers within the object file, whereas the <code>Segment</code>/<code>SegmentRef</code> objects contain the actual segment data itself.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>Segments()</em></li></ul><p><strong>Iteration</strong></p><ul><li><em>getindex()</em></li><li><em>lastindex()</em></li><li>length()</li><li>iterate()</li><li>eltype()</li></ul><p><strong>Search</strong></p><ul><li>findall()</li><li>findfirst()</li></ul><p><strong>Misc.</strong></p><ul><li><em>handle()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Segments-Tuple{SegmentRef}" href="#ObjectFile.Segments-Tuple{SegmentRef}"><code>ObjectFile.Segments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Segments(seg::SegmentRef)</code></pre><p>Return the <code>Segments</code> collection this <code>Segment</code> belongs to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.StrTab" href="#ObjectFile.StrTab"><code>ObjectFile.StrTab</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StrTab</code></pre><p>This type encapsulates a string table within an object file, enabling queries against the string table for symbol names, section names, etc... The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>StrTab()</em></li></ul><p><strong>Accessors</strong></p><ul><li><em>handle()</em></li><li><em>strtab_lookup()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SymbolRef" href="#ObjectFile.SymbolRef"><code>ObjectFile.SymbolRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SymbolRef</code></pre><p>Provides a reference to a <code>SymtabEntry</code>, along with a reference to the <code>ObjectHandle</code> this <code>SymtabEntry</code> comes from.  This should be the primary method by which users interact with symbols inside object files.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis.  Note that this overlaps heavily with the <code>SymtabEntry</code> object API, this is by design as many of the methods are simply passthroughs to the underlying <code>SymtabEntry</code> API calls for ease of use.</p><p><strong>Creation:</strong></p><ul><li><em>SymbolRef()</em></li></ul><p><strong>Util:</strong></p><ul><li><em>deref()</em></li><li><em>Symbols()</em></li><li>handle()</li></ul><p><strong>Properties:</strong></p><ul><li><em>symbol_number()</em></li><li><em>symbol_name()</em></li><li>symbol_value()</li><li>isundef()</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SymbolRef-Tuple{Symbols,SymtabEntry,UInt32}" href="#ObjectFile.SymbolRef-Tuple{Symbols,SymtabEntry,UInt32}"><code>ObjectFile.SymbolRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>SymbolRef(symbols::Symbols, sym::SymtabEntry, idx::UInt32)</p><p>Construct a <code>SymbolRef</code> object pointing to the given <code>SymtabEntry</code>, which itself represents the <code>idx</code>&#39;th symbol within the given <code>Symbols</code> collection.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Symbols" href="#ObjectFile.Symbols"><code>ObjectFile.Symbols</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Symbols</code></pre><p>An abstraction over the concept of a collection of symbol (<code>SymtabEntry</code>) types within an object file.  One can think of the <code>Symbols</code> object containing the table of symbols within the object file, whereas the <code>SymtabEntry</code>/<code>SymbolRef</code> objects contain the actual symbol data itself.  The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation</strong></p><ul><li><em>Symbols()</em></li></ul><p><strong>Iteration</strong></p><ul><li>getindex()</li><li><em>lastindex()</em></li><li>length()</li><li>iterate()</li><li>eltype()</li></ul><p><strong>Misc.</strong></p><ul><li><em>handle()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.Symbols-Tuple{SymbolRef}" href="#ObjectFile.Symbols-Tuple{SymbolRef}"><code>ObjectFile.Symbols</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Symbols(sym::SymbolRef)</code></pre><p>Return the <code>Symbols</code> object that this <code>SymbolRef</code> belongs to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.SymtabEntry" href="#ObjectFile.SymtabEntry"><code>ObjectFile.SymtabEntry</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SymtabEntry</code></pre><p>An abstraction over the concept of a symbol within an object file.  This type does not use the <code>Symbol</code> name as this would conflict with the builtin Julia <code>Symbol</code> type, so the name <code>SymtabEntry</code> is used instead.  As a user, the <code>SymbolRef</code> type should be the primary method of interacting with symbols, as a developer adding new object file formats, some methods must support <code>SymtabEntry</code>s, others must support only <code>SymbolRef</code>s.  Note that any method that works on a <code>SymtabEntry</code> must also work with a <code>SymbolRef</code>, see the <code>@derefmethod</code> macro for a convenient helper macro to generate <code>SymbolRef</code> -&gt; <code>SymtabEntry</code> wrapper methods. The list of available API operations is given below, with methods that subclasses must implement marked in emphasis:</p><p><strong>Creation:</strong></p><ul><li><em>SymtabEntry()</em></li></ul><p><strong>Util:</strong></p><ul><li>deref()</li></ul><p><strong>Properties:</strong></p><ul><li><em>symbol_name()</em></li><li><em>symbol_value()</em></li><li><em>isundef()</em></li><li><em>isglobal()</em></li><li><em>islocal()</em></li><li><em>isweak()</em></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.fixed_string" href="#ObjectFile.fixed_string"><code>ObjectFile.fixed_string</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">fixed_string{T}</code></pre><p>A fixed-byte string, stored as an integer type (e.g. <code>T</code> = <code>UInt128</code>, or <code>T</code> = <code>UInt64</code>) but displayed and treated as a string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eof-Tuple{SectionRef}" href="#Base.eof-Tuple{SectionRef}"><code>Base.eof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eof(section::SectionRef)</code></pre><p>Returns <code>true</code> if the <code>ObjectHandle</code> that this <code>SectionRef</code> refers to has read beyond the current section&#39;s extent</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findall-Tuple{Sections,AbstractString}" href="#Base.findall-Tuple{Sections,AbstractString}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findall(sections::Sections, name::String)</code></pre><p>Return a list of sections that match the given <code>name</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findall-Union{Tuple{S}, Tuple{Sections,Array{S,1}}} where S&lt;:AbstractString" href="#Base.findall-Union{Tuple{S}, Tuple{Sections,Array{S,1}}} where S&lt;:AbstractString"><code>Base.findall</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findall(sections::Sections, name::String)</code></pre><p>Return a list of sections that match one of the given <code>names</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst-Tuple{Sections,AbstractString}" href="#Base.findfirst-Tuple{Sections,AbstractString}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findfirst(sections::Sections, name::String)</code></pre><p>Return the first section that matches the given <code>name</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst-Tuple{Sections,Array{String,1}}" href="#Base.findfirst-Tuple{Sections,Array{String,1}}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findfirst(sections::Sections, names::Vector{String})</code></pre><p>Return the first section that matches on of the given <code>names</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.read-Tuple{SectionRef}" href="#Base.read-Tuple{SectionRef}"><code>Base.read</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">read(section::SectionRef)</code></pre><p>Read the contents of the section referred to by <code>section</code>, returning a <code>Vector{UInt8}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.seek-Tuple{SectionRef,Any}" href="#Base.seek-Tuple{SectionRef,Any}"><code>Base.seek</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">seek(section::SectionRef, offset)</code></pre><p>Seek to <code>offset</code> relative to <code>section</code> in the <code>ObjectHandle</code> that this <code>SectionRef</code> refers to</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.seekstart-Tuple{SectionRef}" href="#Base.seekstart-Tuple{SectionRef}"><code>Base.seekstart</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">seekstart(section::SectionRef)</code></pre><p>Seek to the beginning of <code>section</code> in the <code>ObjectHandle</code> it was loaded from.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.canonical_rpaths-Tuple{RPath}" href="#ObjectFile.canonical_rpaths-Tuple{RPath}"><code>ObjectFile.canonical_rpaths</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">canonical_rpaths(rpath::RPath)</code></pre><p>Return a canonicalized list of paths that will be searched.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.contents-Union{Tuple{H}, Tuple{H,Section{H}}} where H&lt;:ObjectHandle" href="#ObjectFile.contents-Union{Tuple{H}, Tuple{H,Section{H}}} where H&lt;:ObjectHandle"><code>ObjectFile.contents</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">contents(oh::ObjectHandle, section::Section)</code></pre><p>Read the contents of the section referred to by <code>section</code> from the given <code>ObjectHandle</code>, returning a <code>Vector{UInt8}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.deref-Tuple{SectionRef}" href="#ObjectFile.deref-Tuple{SectionRef}"><code>ObjectFile.deref</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deref(section::SectionRef)</code></pre><p>Dereference the given <code>SectionRef</code> object to a <code>Section</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.deref-Tuple{SegmentRef}" href="#ObjectFile.deref-Tuple{SegmentRef}"><code>ObjectFile.deref</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deref(seg::SegmentRef)</code></pre><p>Dereference the given <code>SegmentRef</code> object to a <code>Segment</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.endianness-Tuple{ObjectHandle}" href="#ObjectFile.endianness-Tuple{ObjectHandle}"><code>ObjectFile.endianness</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">endianness(oh::ObjectHandle)</code></pre><p>Returns the endianness of the given <code>ObjectHandle</code> (e.g. <code>:LittleEndian</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.find_libraries-Tuple{ObjectHandle}" href="#ObjectFile.find_libraries-Tuple{ObjectHandle}"><code>ObjectFile.find_libraries</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">find_libraries(oh::ObjectHandle)</code></pre><p>Return a mapping from sonames to absolute paths, containing all the sonames declared as beeing needed by the given <code>ObjectHandle</code>.  See the documentation for <code>find_library(::RPath, ::String)</code> and <code>RPath</code> for more details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.find_library-Tuple{ObjectHandle,AbstractString}" href="#ObjectFile.find_library-Tuple{ObjectHandle,AbstractString}"><code>ObjectFile.find_library</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">find_library(oh::ObjectHandle, soname::String)</code></pre><p>Return the absolute path to the given <code>soname</code>, using the linker search path that the given <code>ObjectHandle</code> would use at runtime.  See the documentation for <code>find_library(::RPath, ::String)</code> for more details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.find_library-Tuple{RPath,AbstractString}" href="#ObjectFile.find_library-Tuple{RPath,AbstractString}"><code>ObjectFile.find_library</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">find_library(rpath::RPath, soname::String)</code></pre><p>Return the full path to a library, searching the given <code>RPath</code>, and then the default library search paths.  This method takes the given <code>soname</code> and joins it to the end of every path within the given <code>RPath</code>, returning the resultant path if it exists, returning back the original <code>soname</code> if it doesn&#39;t.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.format_string-Tuple{Type}" href="#ObjectFile.format_string-Tuple{Type}"><code>ObjectFile.format_string</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">format_string(::Type{H}) where {H &lt;: ObjectHandle}</code></pre><p>Return the string name of the given <code>ObjectHandle</code>, examples are &quot;ELF&quot;, &quot;MachO&quot;, &quot;COFF&quot;, etc...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.getindex_ref-NTuple{6,Any}" href="#ObjectFile.getindex_ref-NTuple{6,Any}"><code>ObjectFile.getindex_ref</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getindex_ref(collection, offset, stride, T, ref_type, idx)</code></pre><p>Given a <code>collection</code>, such as <code>Sections</code>, <code>DynamicLinks</code>, etc... use the given <code>offset</code>, <code>stride</code>, and <code>T</code> parameters to read in and construct a <code>ref_type</code> object located at index <code>idx</code>.  Example invocation:</p><pre><code class="language-none">getindex_ref(
    sections,
    section_header_offset(oh),
    section_header_size(oh),
    section_header_type(oh),
    SectionRef,
    idx
)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.handle-Tuple{RPath}" href="#ObjectFile.handle-Tuple{RPath}"><code>ObjectFile.handle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle(rpath::RPath)</code></pre><p>Return the handle that this <code>RPath</code> object refers to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.handle-Tuple{SectionRef}" href="#ObjectFile.handle-Tuple{SectionRef}"><code>ObjectFile.handle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle(section::SectionRef)</code></pre><p>Return the <code>ObjectHandle</code> this <code>SectionRef</code> belongs to.  This method is <code>SectionRef</code>-only.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.handle-Tuple{Sections}" href="#ObjectFile.handle-Tuple{Sections}"><code>ObjectFile.handle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle(sections::Sections)</code></pre><p>Return the <code>ObjectHandle</code> that this <code>Sections</code> object belongs to</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.handle-Tuple{SegmentRef}" href="#ObjectFile.handle-Tuple{SegmentRef}"><code>ObjectFile.handle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle(seg::SegmentRef)</code></pre><p>Return the <code>ObjectHandle</code> this <code>SegmentRef</code> belongs to.  This method is <code>SegmentRef</code>-only.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.handle-Tuple{StrTab}" href="#ObjectFile.handle-Tuple{StrTab}"><code>ObjectFile.handle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle(s::StrTab)</code></pre><p>Return the <code>ObjectHandle</code> this <code>StrTab</code> belongs to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.handle-Tuple{SymbolRef}" href="#ObjectFile.handle-Tuple{SymbolRef}"><code>ObjectFile.handle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle(sym::SymbolRef)</code></pre><p>Return the <code>ObjectHandle</code> that this <code>SymbolRef</code> belongs to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.header-Tuple{ObjectHandle}" href="#ObjectFile.header-Tuple{ObjectHandle}"><code>ObjectFile.header</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">header(oh::ObjectHandle)</code></pre><p>Return the <code>ObjectHandle</code>&#39;s header object, whatever that may be for this particular object file format.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.iostream-Tuple{ObjectHandle}" href="#ObjectFile.iostream-Tuple{ObjectHandle}"><code>ObjectFile.iostream</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">iostream(oh::ObjectHandle)</code></pre><p>Returns the <code>IOStream</code> backing the <code>ObjectHandle</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.is64bit-Tuple{ObjectHandle}" href="#ObjectFile.is64bit-Tuple{ObjectHandle}"><code>ObjectFile.is64bit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is64bit(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> represents a 64-bit object</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isdynamic-Tuple{ObjectHandle}" href="#ObjectFile.isdynamic-Tuple{ObjectHandle}"><code>ObjectFile.isdynamic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isdynamic(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> makes use of dynamic linking.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isexecutable-Tuple{ObjectHandle}" href="#ObjectFile.isexecutable-Tuple{ObjectHandle}"><code>ObjectFile.isexecutable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isexecutable(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> represents an executable object</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isglobal-Tuple{SymtabEntry}" href="#ObjectFile.isglobal-Tuple{SymtabEntry}"><code>ObjectFile.isglobal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isglobal(sym::SymtabEntry)</code></pre><p>Return <code>true</code> if the given symbol is global</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.islibrary-Tuple{ObjectHandle}" href="#ObjectFile.islibrary-Tuple{ObjectHandle}"><code>ObjectFile.islibrary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">islibrary(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> represents a shared library</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.islocal-Tuple{SymtabEntry}" href="#ObjectFile.islocal-Tuple{SymtabEntry}"><code>ObjectFile.islocal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">islocal(sym::SymtabEntry)</code></pre><p>Return <code>true</code> if the given symbol is local</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isrelocatable-Tuple{ObjectHandle}" href="#ObjectFile.isrelocatable-Tuple{ObjectHandle}"><code>ObjectFile.isrelocatable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isrelocatable(oh::ObjectHandle)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> represents a relocatable object file, e.g. an <code>.o</code> file as generated by <code>gcc -c</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isundef-Tuple{SymtabEntry}" href="#ObjectFile.isundef-Tuple{SymtabEntry}"><code>ObjectFile.isundef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isundef(sym::SymtabEntry)</code></pre><p>Return <code>true</code> if the given symbol is undefined</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.isweak-Tuple{SymtabEntry}" href="#ObjectFile.isweak-Tuple{SymtabEntry}"><code>ObjectFile.isweak</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isweak(sym::SymtabEntry)</code></pre><p>Return <code>true</code> if the given symbol is weak</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.mangle_section_name-Tuple{ObjectHandle,AbstractString}" href="#ObjectFile.mangle_section_name-Tuple{ObjectHandle,AbstractString}"><code>ObjectFile.mangle_section_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mangle_section_name(oh::ObjectHandle, name::AbstractString)</code></pre><p>Turn a section <code>name</code> into the object-format specific naming convention, e.g. returning <code>&quot;.bss&quot;</code> for <code>ELF</code>/<code>COFF</code> files, and <code>&quot;__bss&quot;</code> for <code>MachO</code> files</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.mangle_symbol_name-Tuple{ObjectHandle,AbstractString}" href="#ObjectFile.mangle_symbol_name-Tuple{ObjectHandle,AbstractString}"><code>ObjectFile.mangle_symbol_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mangle_symbol_name(oh::ObjectHandle, name::AbstractString)</code></pre><p>Mangle a symbol name using the object-format specific naming convention, e.g. prefixing <code>&quot;_&quot;</code> for MachO files.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.path-Tuple{IO}" href="#ObjectFile.path-Tuple{IO}"><code>ObjectFile.path</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">path(io::IO)</code></pre><p>Try to guess the path of an <code>IO</code> object.  If it cannot be guessed, returns the empty string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.path-Tuple{ObjectHandle}" href="#ObjectFile.path-Tuple{ObjectHandle}"><code>ObjectFile.path</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">path(oh::ObjectHandle)</code></pre><p>Return the absolute path to the given <code>ObjectHandle</code>, if it was a file loaded from the local disk.  If it was loaded from a general <code>IOStream</code> or in some other way such that the path is unknown or unknowable, return the empty string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.read_struct-NTuple{4,Any}" href="#ObjectFile.read_struct-NTuple{4,Any}"><code>ObjectFile.read_struct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">read_struct(oh, type_func, size_func, name)</code></pre><p>Given a <code>Type</code>, (such as <code>ELFSection64</code>), <code>unpack()</code> it from the given object and return it, throwing errors as appropriate, and skipping over any excess padding bytes as determined by <code>type_func</code> and <code>size_func</code>. Example invocation:</p><p>read<em>struct(oh, symtab</em>entry<em>type, symtab</em>entry_size, &quot;Symbol Entry&quot;)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.readmeta-Tuple{Function,AbstractString}" href="#ObjectFile.readmeta-Tuple{Function,AbstractString}"><code>ObjectFile.readmeta</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readmeta(f::Function, file::AbstractString)</code></pre><p>Do-block variant of <code>readmeta()</code>.  Use via something like:</p><pre><code class="language-none">readmeta(&quot;libfoo.so&quot;) do f
    ...
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.readmeta-Tuple{IO}" href="#ObjectFile.readmeta-Tuple{IO}"><code>ObjectFile.readmeta</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readmeta(io::IO)</code></pre><p>Read an Object File out from an <code>IOStream</code>, guessing at the type of object within the stream by calling <code>readmeta(io, T)</code> for each <code>T</code> within <code>ObjTypes</code>, and returning the first that does not throw a <code>MagicMismatch</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.readmeta-Union{Tuple{T}, Tuple{IO,Type{T}}} where T&lt;:ObjectHandle" href="#ObjectFile.readmeta-Union{Tuple{T}, Tuple{IO,Type{T}}} where T&lt;:ObjectHandle"><code>ObjectFile.readmeta</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readmeta(io::IO, ::ObjectHandle)</code></pre><p>Read an Object File out from an <code>IOStream</code>.  This is the first method you should call in order to manipulate object files.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.rpaths-Tuple{RPath}" href="#ObjectFile.rpaths-Tuple{RPath}"><code>ObjectFile.rpaths</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rpaths(rpath::RPath)</code></pre><p>Return the list of paths that will be searched for shared libraries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_address-Tuple{Section}" href="#ObjectFile.section_address-Tuple{Section}"><code>ObjectFile.section_address</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">section_address(section::Section)</code></pre><p>The address of the section in virtual memory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_header_offset-Tuple{ObjectHandle}" href="#ObjectFile.section_header_offset-Tuple{ObjectHandle}"><code>ObjectFile.section_header_offset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">section_header_offset(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the offset (in bytes) at which the sections start within the containing object file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_header_size-Tuple{ObjectHandle}" href="#ObjectFile.section_header_size-Tuple{ObjectHandle}"><code>ObjectFile.section_header_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">section_header_size(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the size of a section header (used for reading in the sections header when trying to load a <code>Section</code> object or iterating over a <code>Sections</code> object)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_header_type-Tuple{ObjectHandle}" href="#ObjectFile.section_header_type-Tuple{ObjectHandle}"><code>ObjectFile.section_header_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">section_header_type(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the type of a section header (used for reading in the sections header when trying to load a <code>Section</code> object or iterating over a <code>Sections</code> object).  For instance, for a 64-bit ELF file, this would return the type <code>ELFSection64</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_name-Tuple{Section}" href="#ObjectFile.section_name-Tuple{Section}"><code>ObjectFile.section_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">section_name(section::Section)</code></pre><p>Return the name of the given section as a string.  In order to return a true name, it is necessary to perform a lookup within the object&#39;s string table, which cannot be done using just a <code>Section</code> object; use a <code>SectionRef</code> object instead if you need that.  For sanity sake, this method will return a string, but the contents of the string may be something like the offset within the string table pointing to this <code>Section</code>&#39;s name, e.g. &quot;@strtab.123&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_number-Tuple{SectionRef}" href="#ObjectFile.section_number-Tuple{SectionRef}"><code>ObjectFile.section_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">section_number(section::SectionRef)</code></pre><p>The index of the given section within the section header table.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_offset-Tuple{Section}" href="#ObjectFile.section_offset-Tuple{Section}"><code>ObjectFile.section_offset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">section_offset(section::Section)</code></pre><p>The offset of the section in the file, in bytes</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.section_size-Tuple{Section}" href="#ObjectFile.section_size-Tuple{Section}"><code>ObjectFile.section_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">section_size(section::Section)</code></pre><p>The size of the actual data contained in the section. This should exclude any padding mandated by the file format e.g. due to alignment rules</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_header_offset-Tuple{ObjectHandle}" href="#ObjectFile.segment_header_offset-Tuple{ObjectHandle}"><code>ObjectFile.segment_header_offset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">segment_header_offset(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the offset (in bytes) at which the segments start within the containing object file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_header_size-Tuple{ObjectHandle}" href="#ObjectFile.segment_header_size-Tuple{ObjectHandle}"><code>ObjectFile.segment_header_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">segment_header_size(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the size of a segment header (used for reading in the segments header when trying to load a <code>Segment</code> object or iterating over a <code>Segments</code> object)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_header_type-Tuple{ObjectHandle}" href="#ObjectFile.segment_header_type-Tuple{ObjectHandle}"><code>ObjectFile.segment_header_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">segment_header_type(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the type of a segment header (used for reading in the segments header when trying to load a <code>Segment</code> object or iterating over a <code>Segments</code> object).  For instance, for a 64-bit ELF file, this would return the type <code>ELFSegment64</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_name-Tuple{SegmentRef}" href="#ObjectFile.segment_name-Tuple{SegmentRef}"><code>ObjectFile.segment_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">segment_name(seg::SegmentRef)</code></pre><p>The name of the given <code>Segment</code>, returned as a string.  This method often performs some kind of lookup within the string table of the object to get the full name of the segment.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.segment_number-Tuple{SegmentRef}" href="#ObjectFile.segment_number-Tuple{SegmentRef}"><code>ObjectFile.segment_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">segment_number(seg::SegmentRef)</code></pre><p>Return the index of the referred segment.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.strtab_lookup-Tuple{StrTab,Any}" href="#ObjectFile.strtab_lookup-Tuple{StrTab,Any}"><code>ObjectFile.strtab_lookup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">strtab_lookup(s::StrTab, index)</code></pre><p>Reads a string from the given <code>StrTab</code> at <code>index</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symbol_name-Tuple{SymbolRef}" href="#ObjectFile.symbol_name-Tuple{SymbolRef}"><code>ObjectFile.symbol_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symbol_name(sym::SymbolRef)</code></pre><p>Return the name of the given symbol as a string.  This method often performs some kind of lookup within the string table of the object to get the full name of the symbol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symbol_name-Tuple{SymtabEntry}" href="#ObjectFile.symbol_name-Tuple{SymtabEntry}"><code>ObjectFile.symbol_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symbol_name(sym::SymtabEntry)</code></pre><p>Return the name of the given section as a string.  In order to return a true name, it is necessary to perform a lookup within the object&#39;s string table, which cannot be done using just a <code>SymtabEntry</code> object; use a <code>SymbolRef</code> object instead if you need that.  For sanity sake, this method will return a string, but the contents of the string may be something like the offset within the string table pointing to this <code>SymtabEntry</code>&#39;s name, e.g. &quot;@strtab.123&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symbol_number-Tuple{SymbolRef}" href="#ObjectFile.symbol_number-Tuple{SymbolRef}"><code>ObjectFile.symbol_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symbol_number(sym::SymbolRef)</code></pre><p>Return the number (index) of the given symbol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symbol_value-Tuple{SymtabEntry}" href="#ObjectFile.symbol_value-Tuple{SymtabEntry}"><code>ObjectFile.symbol_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symbol_value(sym::SymtabEntry)</code></pre><p>Return the value of the given symbol</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symtab_entry_offset-Tuple{ObjectHandle}" href="#ObjectFile.symtab_entry_offset-Tuple{ObjectHandle}"><code>ObjectFile.symtab_entry_offset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symtab_entry_offset(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the offset (in bytes) at which the symbol table starts within the containing object file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symtab_entry_size-Tuple{ObjectHandle}" href="#ObjectFile.symtab_entry_size-Tuple{ObjectHandle}"><code>ObjectFile.symtab_entry_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symtab_entry_size(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the size of a symbol table entry (used for reading in the symbol table when trying to load a <code>SymtabEntry</code> object or iterating over a <code>Symbols</code> object).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.symtab_entry_type-Tuple{ObjectHandle}" href="#ObjectFile.symtab_entry_type-Tuple{ObjectHandle}"><code>ObjectFile.symtab_entry_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symtab_entry_type(oh::ObjectHandle)</code></pre><p>Given an <code>ObjectHandle</code>, return the type of a symbol table entry (used for reading in the symbol table when trying to load a <code>SymtabEntry</code> object or iterating over a <code>Symbols</code> object).  For instance, for a 64-bit ELF file, this would return the type <code>ELFSymtabEntry64</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_string-Union{Tuple{T}, Tuple{Any,T}} where T&lt;:Integer" href="#Base.unsafe_string-Union{Tuple{T}, Tuple{Any,T}} where T&lt;:Integer"><code>Base.unsafe_string</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_string(io, max_len::Integer)</code></pre><p>Read in a null-terminated string, stopping with a maximum length of <code>max_len</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_string-Union{Tuple{fixed_string{T}}, Tuple{T}} where T&lt;:Integer" href="#Base.unsafe_string-Union{Tuple{fixed_string{T}}, Tuple{T}} where T&lt;:Integer"><code>Base.unsafe_string</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unsafe_string(x::fixed_string)</code></pre><p>Convert a <code>fixed_string</code> object to a native-Julia <code>String</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.show_collection-Union{Tuple{ST}, Tuple{H}, Tuple{IO,ST,Type{H}}} where ST where H&lt;:ObjectHandle" href="#ObjectFile.show_collection-Union{Tuple{ST}, Tuple{H}, Tuple{IO,ST,Type{H}}} where ST where H&lt;:ObjectHandle"><code>ObjectFile.show_collection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">show_collection(io, collection, ::Type{H&lt;:ObjectHandle})</code></pre><p>Given a collection-like object, (<code>Symbols</code>, <code>DynamicLinks</code>, ``)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ObjectFile.startaddr-Tuple{ObjectHandle}" href="#ObjectFile.startaddr-Tuple{ObjectHandle}"><code>ObjectFile.startaddr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">startaddr(oh::ObjectHandle)</code></pre><p>Returns the offset within the underlying <code>IOStream</code> at which this <code>ObjectHandle</code> is located.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
