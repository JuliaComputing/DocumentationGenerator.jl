<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FunctionalTables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FunctionalTables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.FunctionalTable" href="#FunctionalTables.FunctionalTable"><code>FunctionalTables.FunctionalTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FunctionalTable(itr)
FunctionalTable(itr, sortspecs)
FunctionalTable(itr, sortspecs, sortingpolicy; cfg)
</code></pre><p>Create a <code>FunctionalTable</code> from an iterable that returns <code>NamedTuple</code>s.</p><p>Returned values need to have the same names (but not necessarily types).</p><p><code>sorting</code> specifies sorting, and is a tuple of <code>:key</code> or <code>:key =&gt; reverse</code> elements.</p><p><code>cfg</code> determines sink configuration for collecting elements of the columns, see <a href="#FunctionalTables.SinkConfig"><code>SinkConfig</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.RLEVector" href="#FunctionalTables.RLEVector"><code>FunctionalTables.RLEVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct RLEVector{C, T, S}</code></pre><p>An RLE encoded vector, using negative lengths for missing values.</p><p>When an elemenet in <code>counts</code> is positive, it encodes that many of the corresponding element in <code>data</code>.</p><p>Negative <code>counts</code> encode missing values of type <code>S</code> (has to be a concrete singleton). In this case there is no corresponding value in <code>data</code>, ie <code>data</code> may have <em>fewer elements</em> than <code>counts</code>.</p><p>An RLEVector can also act as a column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SinkConfig" href="#FunctionalTables.SinkConfig"><code>FunctionalTables.SinkConfig</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SinkConfig{M}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SinkConfig-Tuple{}" href="#FunctionalTables.SinkConfig-Tuple{}"><code>FunctionalTables.SinkConfig</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SinkConfig(; useRLE, missingvalue)
</code></pre><p>Make a sink configuration, using defaults.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.TrustSorting" href="#FunctionalTables.TrustSorting"><code>FunctionalTables.TrustSorting</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Accept the specified sorting to hold without any checks (except for verifying that column names are valid).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This can lead to incorrect results, use cautiously. <a href="#FunctionalTables.VerifySorting"><code>VerifySorting</code></a> is recommended instead as it has little overhead.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.TrySorting" href="#FunctionalTables.TrySorting"><code>FunctionalTables.TrySorting</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Try the specified sorting, then gracefully degrade to a subset of it that holds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.VerifySorting" href="#FunctionalTables.VerifySorting"><code>FunctionalTables.VerifySorting</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Verify that the specified sorting holds. This is the default sorting policy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.by-Tuple{Tuple{Vararg{Symbol,N} where N},FunctionalTable}" href="#FunctionalTables.by-Tuple{Tuple{Vararg{Symbol,N} where N},FunctionalTable}"><code>FunctionalTables.by</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">by(indexkeys, ft; cfg)
</code></pre><p>An iterator that groups rows of tables by the columns <code>indexkeys</code>, returning <code>(index::NamedTupe, table::FunctionalTable)</code> for each contiguous block of the index keys.</p><p><code>cfg</code> is used for collecting <code>table</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.collect_column-Tuple{SinkConfig,Any}" href="#FunctionalTables.collect_column-Tuple{SinkConfig,Any}"><code>FunctionalTables.collect_column</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">collect_column(cfg, itr)
</code></pre><p>Collect results from <code>itr</code> into a sink (using config <code>cfg</code>), then finalize and return the column.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.collect_columns-Union{Tuple{K}, Tuple{SinkConfig,Any,ColumnSorting,SortingPolicy{K}}} where K" href="#FunctionalTables.collect_columns-Union{Tuple{K}, Tuple{SinkConfig,Any,ColumnSorting,SortingPolicy{K}}} where K"><code>FunctionalTables.collect_columns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>columns, sorting = </p><pre><code class="language-julia">collect_columns(cfg, itr, sorting, sortingpolicy)
</code></pre><p>Collect results from <code>itr</code>, which are supposed to be <code>NamedTuple</code>s with the same names, into sinks (using config <code>cfg</code>), then finalize and return the <code>NamedTuple</code> of the columns and the sorting (which is <code>≡ sorting</code> unless <code>sortingpolicy ≡ SortingPolicy(:prefix)</code>).</p><p><code>sorting</code> is ignored when <code>sortingpolicy ≡ SortingPolicy(:accept)</code>, otherwise used according to the value of the latter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.columns-Tuple{FunctionalTable}" href="#FunctionalTables.columns-Tuple{FunctionalTable}"><code>FunctionalTables.columns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">columns(ft; vector, mutable)
</code></pre><p>Return the columns in a <code>NamedTuple</code>.</p><p>When <code>mutable</code>, all columns will be mutable <code>&lt;: AbstractVector</code>, and not share (shallow) structure.</p><p>When <code>vector</code>, all columns will be <code>&lt;: AbstractVector</code>, but may be immutable or share structure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.select-Tuple{FunctionalTable,Tuple{Vararg{Symbol,N} where N}}" href="#FunctionalTables.select-Tuple{FunctionalTable,Tuple{Vararg{Symbol,N} where N}}"><code>FunctionalTables.select</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">select(ft, keep)
</code></pre><p>select(ft, keep...) select(ft; drop)</p><p>Select a subset of columns from the table.</p><p><code>select(ft, keep)</code> and <code>select(ft, keep...)</code> returns the table with the given columns.</p><p><code>select(ft; drop = keys)</code> is a convenience form for keeping <strong>all but</strong> the given columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ColumnSort" href="#FunctionalTables.ColumnSort"><code>FunctionalTables.ColumnSort</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ColumnSort(key)
ColumnSort(key, rev)
</code></pre><p>Process an individual sort specification, called by <a href="#FunctionalTables.column_sorting"><code>column_sorting</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ColumnSort" href="#FunctionalTables.ColumnSort"><code>FunctionalTables.ColumnSort</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ColumnSort{K, R}</code></pre><p>Sort specification for a column. <code>K::Symbol</code> is a key for sorting, <code>R::Bool</code> reverses sorting for this key.</p><p>This type is <em>not part of the interface</em>, for internal representation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.ColumnSorting" href="#FunctionalTables.ColumnSorting"><code>FunctionalTables.ColumnSorting</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for sorting, used internally.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.Keys" href="#FunctionalTables.Keys"><code>FunctionalTables.Keys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for keys, used internally.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.RepeatedValue" href="#FunctionalTables.RepeatedValue"><code>FunctionalTables.RepeatedValue</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>RepeatedValue(value, len)</p><p>Equivalent to a vector containing <code>len</code> instances of <code>value</code>. Used <em>internally</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SortingPolicy" href="#FunctionalTables.SortingPolicy"><code>FunctionalTables.SortingPolicy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SortingPolicy{K}</code></pre><p>Policy for dealing with specified sortings.</p><p>See <a href="#FunctionalTables.VerifySorting"><code>VerifySorting</code></a>, <a href="#FunctionalTables.TrustSorting"><code>TrustSorting</code></a>, and <a href="#FunctionalTables.TrySorting"><code>TrySorting</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.SplitTable" href="#FunctionalTables.SplitTable"><code>FunctionalTables.SplitTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SplitTable{K, T&lt;:FunctionalTable, C&lt;:SinkConfig}</code></pre><p>Implements <a href="#FunctionalTables.by-Tuple{Tuple{Vararg{Symbol,N} where N},FunctionalTable}"><code>by</code></a>.</p><p>Iterator state is a tuple, with</p><ol><li><p><code>sinks</code> and <code>firstkey</code>, created from the element with a non-matching key,</p></li><li><p><code>itrstate</code>, the iteration state for <code>itr</code>.</p></li></ol></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,FunctionalTables.SplitTable}" href="#Base.map-Tuple{Any,FunctionalTables.SplitTable}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map(f, st; cfg)
</code></pre><p>Map a table split with <a href="#FunctionalTables.by-Tuple{Tuple{Vararg{Symbol,N} where N},FunctionalTable}"><code>by</code></a> using <code>f</code>.</p><p>Specifically, <code>f(indexkeys, table)</code> receives the index keys (a <code>NamedTuple</code>) and a <code>FunctionalTable</code>.</p><p>It is supposed to return an <em>iterable</em> that returns rows (can be a <code>FunctionalTable</code>). These will be prepended with the corresponding index, and collected into a <code>FunctionalTable</code> with <code>cfg</code>.</p><p>When <code>f</code> returns just a single row (eg aggregation), wrap by <code>Ref</code> to create a single-element iterable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Union{Function, Type},FunctionalTable}" href="#Base.map-Tuple{Union{Function, Type},FunctionalTable}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map(f, ft; cfg)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge-Tuple{FunctionalTable,FunctionalTable}" href="#Base.merge-Tuple{FunctionalTable,FunctionalTable}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">merge(a, b; replace)
</code></pre><p>Merge two <code>FunctionalTable</code>s.</p><p>When <code>replace == true</code>, columns in the first one are replaced by second one, otherwise an error is thrown if column names overlap.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge-Tuple{FunctionalTable,Union{Function, Type}}" href="#Base.merge-Tuple{FunctionalTable,Union{Function, Type}}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">merge(ft, f; cfg, replace)
</code></pre><p>Map <code>ft</code> using <code>f</code> by rows, then <code>merge</code> the two. See <a href="#Base.map-Tuple{Union{Function, Type},FunctionalTable}"><code>map(::Callable,::FunctionalTable)</code></a>.</p><p><code>cfg</code> is passed to <code>map</code>, <code>replace</code> governs replacement of overlapping columns in <code>merge</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.append1-Union{Tuple{S}, Tuple{T}, Tuple{Array{T,1},S}} where S where T" href="#FunctionalTables.append1-Union{Tuple{S}, Tuple{T}, Tuple{Array{T,1},S}} where S where T"><code>FunctionalTables.append1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">append1(v, elt)
</code></pre><p>Append <code>elt</code> to <code>v</code>, allocating a new vector and copying the contents.</p><p>Type of new collection is calculated using <code>promote_type</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.cancontain-Union{Tuple{S}, Tuple{Any,S}} where S" href="#FunctionalTables.cancontain-Union{Tuple{S}, Tuple{Any,S}} where S"><code>FunctionalTables.cancontain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cancontain(T, elt)
</code></pre><p>Test if a collection of element type <code>T</code> can contain a new element <code>elt</code> without <em>any</em> loss of precision.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.checkvalidkeys-Tuple{Tuple{Vararg{Symbol,N} where N},Tuple{Vararg{Symbol,N} where N}}" href="#FunctionalTables.checkvalidkeys-Tuple{Tuple{Vararg{Symbol,N} where N},Tuple{Vararg{Symbol,N} where N}}"><code>FunctionalTables.checkvalidkeys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">checkvalidkeys(argkeys, validkeys)
</code></pre><p>Check that <code>argkeys</code> are a subset of the valid keys.</p><p>When that does not hold, throw and error with an informative message.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.cmp_sorting-Tuple{FunctionalTables.ColumnSorting,Any,Any}" href="#FunctionalTables.cmp_sorting-Tuple{FunctionalTables.ColumnSorting,Any,Any}"><code>FunctionalTables.cmp_sorting</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cmp_sorting(cs, a, b)
</code></pre><p>Compare rows <code>a</code> and <code>b</code>, which support the <code>getproperty</code> interface, with the given column sorting.</p><p><em>Internal</em>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.column_sorting" href="#FunctionalTables.column_sorting"><code>FunctionalTables.column_sorting</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">column_sorting(sortspecs)
column_sorting(sortspecs, colkeys)
</code></pre><p>Process sorting specifications for columns (an iterable or possibly a ColumnSorting), return a value of type <code>ColumnSorting</code>.</p><p>Verify that sort keys are unique. When <code>colkeys</code> is given, verify that the sort keys are a subset of it.</p><p>Accepted syntax:</p><ul><li><p><code>:key</code>, for sorting a column in ascending order</p></li><li><p><code>:key =&gt; reverse</code>, for sorting a column in descending order</p></li></ul><p>All functions which accept sort specs should use this, but the function itself is not part of the API.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.dropkeys-Tuple{Tuple{Vararg{Symbol,N} where N},Tuple{Vararg{Symbol,N} where N}}" href="#FunctionalTables.dropkeys-Tuple{Tuple{Vararg{Symbol,N} where N},Tuple{Vararg{Symbol,N} where N}}"><code>FunctionalTables.dropkeys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dropkeys(ftkeys, drop)
</code></pre><p>Check that <code>drop ⊆ ftkeys</code>, then return <code>ftkeys ∖ drop</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.finalize_sink-Tuple{SinkConfig,Array{T,1} where T}" href="#FunctionalTables.finalize_sink-Tuple{SinkConfig,Array{T,1} where T}"><code>FunctionalTables.finalize_sink</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">finalize_sink(?, sink)
</code></pre><p>Convert <code>sink</code> to a <em>column</em>.</p><p><code>sink</code> may share structure with the result and is not supposed to be used for saving any more elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.finalize_sinks-Tuple{Any,Union{Tuple, NamedTuple}}" href="#FunctionalTables.finalize_sinks-Tuple{Any,Union{Tuple, NamedTuple}}"><code>FunctionalTables.finalize_sinks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">finalize_sinks(cfg, sinks)
</code></pre><p>Finalize a (named) tuple of sinks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.fuse-Tuple{Any,NamedTuple,Vararg{Any,N} where N}" href="#FunctionalTables.fuse-Tuple{Any,NamedTuple,Vararg{Any,N} where N}"><code>FunctionalTables.fuse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fuse(f, index, tables)
</code></pre><p>Prepend the <code>index</code> as repeated columns to <code>f(index, tables...)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.make_sink-Tuple{SinkConfig,Any}" href="#FunctionalTables.make_sink-Tuple{SinkConfig,Any}"><code>FunctionalTables.make_sink</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">make_sink(cfg, elt)
</code></pre><p>Create and return a sink using configuration <code>cfg</code> that stores <code>elt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.make_sinks-Tuple{Any,Union{Tuple, NamedTuple}}" href="#FunctionalTables.make_sinks-Tuple{Any,Union{Tuple, NamedTuple}}"><code>FunctionalTables.make_sinks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">make_sinks(cfg, elts)
</code></pre><p>Make sinks for a (named) tuple pf elements.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.merge_repeated-Tuple{NamedTuple,FunctionalTable}" href="#FunctionalTables.merge_repeated-Tuple{NamedTuple,FunctionalTable}"><code>FunctionalTables.merge_repeated</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">merge_repeated(index, ft)
</code></pre><p>Make a functional table from <code>index</code>, repeating each value for a column to match the length of <code>ft</code>, then merge the two.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.merge_sorting-Tuple{FunctionalTables.ColumnSorting,Tuple{Vararg{Symbol,N} where N}}" href="#FunctionalTables.merge_sorting-Tuple{FunctionalTables.ColumnSorting,Tuple{Vararg{Symbol,N} where N}}"><code>FunctionalTables.merge_sorting</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">merge_sorting(cs, otherkeys)
</code></pre><p>Calculate sorting when a table with <code>sorting</code> is merged with a table containing <code>otherkeys</code>, which may replace columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.narrow-Tuple{Any}" href="#FunctionalTables.narrow-Tuple{Any}"><code>FunctionalTables.narrow</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">narrow(x)
</code></pre><p>Convert the argument to a narrower type if possible without losing precision.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This function is not type stable, use only when new container types are determined.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.retained_sorting-Tuple{FunctionalTables.ColumnSorting,Any,Any}" href="#FunctionalTables.retained_sorting-Tuple{FunctionalTables.ColumnSorting,Any,Any}"><code>FunctionalTables.retained_sorting</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">retained_sorting(cs, a, b)
</code></pre><p>Return the part of <code>sorting</code> under which <code>a ≤ b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.select_sorting-Tuple{FunctionalTables.ColumnSorting,Tuple{Vararg{Symbol,N} where N}}" href="#FunctionalTables.select_sorting-Tuple{FunctionalTables.ColumnSorting,Tuple{Vararg{Symbol,N} where N}}"><code>FunctionalTables.select_sorting</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">select_sorting(cs, keep)
</code></pre><p>Calculate sorting when only <code>keep</code> keys are kept.</p><p><code>keep</code> may contain keys not in the sorting, ie those of a <code>FunctionalTable</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.sortkey-Union{Tuple{ColumnSort{K,R} where R}, Tuple{K}} where K" href="#FunctionalTables.sortkey-Union{Tuple{ColumnSort{K,R} where R}, Tuple{K}} where K"><code>FunctionalTables.sortkey</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sortkey(cs)
</code></pre><p>Accessor for sort key. <em>Internal.</em></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.split_namedtuple-Tuple{Type{#s596} where #s596&lt;:NamedTuple,NamedTuple}" href="#FunctionalTables.split_namedtuple-Tuple{Type{#s596} where #s596&lt;:NamedTuple,NamedTuple}"><code>FunctionalTables.split_namedtuple</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">split_namedtuple(splitter, nt)
</code></pre><p>Splits a named tuple in two, based on the names in <code>splitter</code>.</p><p>Returns two <code>NamedTuple</code>s; the first one is ordered as <code>splitter</code>, the second one with the remaining values as in the original argument.</p><pre><code class="language-julia-repl">julia&gt; split_namedtuple(NamedTuple{(:a, :c)}, (c = 1, b = 2, a = 3, d = 4))
((a = 3, c = 1), (b = 2, d = 4))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionalTables.store!_or_reallocate-Union{Tuple{T}, Tuple{SinkConfig,Array{T,1},Any}} where T" href="#FunctionalTables.store!_or_reallocate-Union{Tuple{T}, Tuple{SinkConfig,Array{T,1},Any}} where T"><code>FunctionalTables.store!_or_reallocate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">store!_or_reallocate(?, sink, elt)
</code></pre><p>Either store <code>elt</code> in <code>sink</code> (in which case the returned value is <code>≡ sink</code>), or allocate a new sink that can do this, copy the contents, save <code>elt</code> and return that (then the returned value is <code>≢ sink</code>).</p></div></div></section><footer><hr/></footer></article></body></html>
