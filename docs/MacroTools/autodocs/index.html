<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · MacroTools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MacroTools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.inexpr-Tuple{Any,Any}" href="#MacroTools.inexpr-Tuple{Any,Any}"><code>MacroTools.inexpr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">inexpr(expr, x)</code></pre><p>Simple expression match; will return <code>true</code> if the expression <code>x</code> can be found inside <code>expr</code>.</p><pre><code class="language-none">inexpr(:(2+2), 2) == true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.isdef-Tuple{Any}" href="#MacroTools.isdef-Tuple{Any}"><code>MacroTools.isdef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Test for function definition expressions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.isexpr-Tuple{Expr}" href="#MacroTools.isexpr-Tuple{Expr}"><code>MacroTools.isexpr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isexpr(x, ts...)</code></pre><p>Convenient way to test the type of a Julia expression. Expression heads and types are supported, so for example you can call</p><pre><code class="language-none">isexpr(expr, String, :string)</code></pre><p>to pick up on all string-like expressions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.namify-Tuple{Symbol}" href="#MacroTools.namify-Tuple{Symbol}"><code>MacroTools.namify</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>An easy way to get pull the (function/type) name out of expressions like <code>foo{T}</code> or <code>Bar{T} &lt;: Vector{T}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.prettify-Tuple{Any}" href="#MacroTools.prettify-Tuple{Any}"><code>MacroTools.prettify</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prettify(ex)</code></pre><p>Makes generated code generaly nicer to look at.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.rmlines-Tuple{Any}" href="#MacroTools.rmlines-Tuple{Any}"><code>MacroTools.rmlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rmlines(x)</code></pre><p>Remove the line nodes from a block or array of expressions.</p><p>Compare <code>quote end</code> vs <code>rmlines(quote end)</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.splitarg-Tuple{Any}" href="#MacroTools.splitarg-Tuple{Any}"><code>MacroTools.splitarg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">splitarg(arg)</code></pre><p>Match function arguments (whether from a definition or a function call) such as <code>x::Int=2</code> and return <code>(arg_name, arg_type, is_splat, default)</code>. <code>arg_name</code> and <code>default</code> are <code>nothing</code> when they are absent. For example:</p><pre><code class="language-julia">&gt; map(splitarg, (:(f(a=2, x::Int=nothing, y, args...))).args[2:end])
4-element Array{Tuple{Symbol,Symbol,Bool,Any},1}:
 (:a, :Any, false, 2)
 (:x, :Int, false, :nothing)
 (:y, :Any, false, nothing)
 (:args, :Any, true, nothing)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.splitdef-Tuple{Any}" href="#MacroTools.splitdef-Tuple{Any}"><code>MacroTools.splitdef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">splitdef(fdef)</code></pre><p>Match any function definition</p><pre><code class="language-julia">function name{params}(args; kwargs)::rtype where {whereparams}
   body
end</code></pre><p>and return <code>Dict(:name=&gt;..., :args=&gt;..., etc.)</code>. The definition can be rebuilt by calling <code>MacroTools.combinedef(dict)</code>, or explicitly with</p><pre><code class="language-none">rtype = get(dict, :rtype, :Any)
all_params = [get(dict, :params, [])..., get(dict, :whereparams, [])...]
:(function $(dict[:name]){$(all_params...)}($(dict[:args]...);
                                            $(dict[:kwargs]...))::$rtype
      $(dict[:body])
  end)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.unblock-Tuple{Any}" href="#MacroTools.unblock-Tuple{Any}"><code>MacroTools.unblock</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unblock(expr)</code></pre><p>Remove outer <code>begin</code> blocks from an expression, if the block is redundant (i.e. contains only a single expression).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.alias_gensyms-Tuple{Any}" href="#MacroTools.alias_gensyms-Tuple{Any}"><code>MacroTools.alias_gensyms</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">alias_gensyms(expr)</code></pre><p>Replaces gensyms with animal names This makes gensym&#39;d code far easier to follow.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.assoc!-Tuple{Any,Any,Any}" href="#MacroTools.assoc!-Tuple{Any,Any,Any}"><code>MacroTools.assoc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">assoc!(d, k, v)</code></pre><p>is the same as <code>d[k] = v</code> but returns <code>d</code> rather than <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.combinearg-NTuple{4,Any}" href="#MacroTools.combinearg-NTuple{4,Any}"><code>MacroTools.combinearg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">combinearg(arg_name, arg_type, is_splat, default)</code></pre><p><code>combinearg</code> is the inverse of <code>splitarg</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.combinedef-Tuple{Dict}" href="#MacroTools.combinedef-Tuple{Dict}"><code>MacroTools.combinedef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">combinedef(dict::Dict)</code></pre><p><code>combinedef</code> is the inverse of <code>splitdef</code>. It takes a splitdef-like Dict and returns a function definition. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.gatherwheres-Tuple{Any}" href="#MacroTools.gatherwheres-Tuple{Any}"><code>MacroTools.gatherwheres</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>gatherwheres(:(f(x::T, y::U) where T where U)) =&gt; (:(f(x::T, y::U)), (:U, :T))</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.gensym_ids-Tuple{Any}" href="#MacroTools.gensym_ids-Tuple{Any}"><code>MacroTools.gensym_ids</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gensym_ids(expr)</code></pre><p>Replaces gensyms with unique ids (deterministically)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.postwalk-Tuple{Any,Any}" href="#MacroTools.postwalk-Tuple{Any,Any}"><code>MacroTools.postwalk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">postwalk(f, expr)</code></pre><p>Applies <code>f</code> to each node in the given expression tree, returning the result. <code>f</code> sees expressions <em>after</em> they have been transformed by the walk. See also <code>prewalk</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.prewalk-Tuple{Any,Any}" href="#MacroTools.prewalk-Tuple{Any,Any}"><code>MacroTools.prewalk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prewalk(f, expr)</code></pre><p>Applies <code>f</code> to each node in the given expression tree, returning the result. <code>f</code> sees expressions <em>before</em> they have been transformed by the walk, and the walk will be applied to whatever <code>f</code> returns.</p><p>This makes <code>prewalk</code> somewhat prone to infinite loops; you probably want to try <code>postwalk</code> first.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
