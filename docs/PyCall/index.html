<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PyCall.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PyCall.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyArray" href="#PyCall.PyArray"><code>PyCall.PyArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PyArray(o::PyObject)</code></pre><p>This converts an <code>ndarray</code> object <code>o</code> to a PyArray.</p><p>This implements a nocopy wrapper to a NumPy array (currently of only numeric types only).</p><p>If you are using <code>pycall</code> and the function returns an <code>ndarray</code>, you can use <code>PyArray</code> as the return type to directly receive a <code>PyArray</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyDict" href="#PyCall.PyDict"><code>PyCall.PyDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PyDict(o::PyObject)
PyDict(d::Dict{K,V})</code></pre><p>This returns a PyDict, which is a no-copy wrapper around a Python dictionary.</p><p>Alternatively, you can specify the return type of a <code>pycall</code> as PyDict.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyObject" href="#PyCall.PyObject"><code>PyCall.PyObject</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PyObject(juliavar)</code></pre><p>This converts a julia variable to a PyObject, which is a reference to a Python object. You can convert back to native julia types using <code>convert(T, o::PyObject)</code>, or using <code>PyAny(o)</code>.</p><p>Given <code>o::PyObject</code>, <code>o[:attribute]</code> is equivalent to <code>o.attribute</code> in Python, with automatic type conversion.</p><p>Given <code>o::PyObject</code>, <code>get(o, key)</code> is equivalent to <code>o[key]</code> in Python, with automatic type conversion.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyVector" href="#PyCall.PyVector"><code>PyCall.PyVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PyVector(o::PyObject)</code></pre><p>This returns a PyVector object, which is a wrapper around an arbitrary Python list or sequence object.</p><p>Alternatively, <code>PyVector</code> can be used as the return type for a <code>pycall</code> that returns a sequence object (including tuples).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyNULL-Tuple{}" href="#PyCall.PyNULL-Tuple{}"><code>PyCall.PyNULL</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PyNULL()</code></pre><p>Return a <code>PyObject</code> that has a <code>NULL</code> underlying pointer, i.e. it doesn&#39;t actually refer to any Python object.</p><p>This is useful for initializing <code>PyObject</code> global variables and array elements before an actual Python object is available.   For example, you might do <code>const myglobal = PyNULL()</code> and later on (e.g. in a module <code>__init__</code> function), reassign <code>myglobal</code> to point to an actual object with <code>copy!(myglobal, someobject)</code>.   This procedure will properly handle Python&#39;s reference counting (so that the Python object will not be freed until you are done with <code>myglobal</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyReverseDims-Tuple{AbstractArray}" href="#PyCall.PyReverseDims-Tuple{AbstractArray}"><code>PyCall.PyReverseDims</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PyReverseDims(array)</code></pre><p>Passes a Julia <code>array</code> to Python as a NumPy row-major array (rather than Julia&#39;s native column-major order) with the dimensions reversed (e.g. a 2×3×4 Julia array is passed as a 4×3×2 NumPy row-major array).  This is useful for Python libraries that expect row-major data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.PyTextIO-Tuple{IO}" href="#PyCall.PyTextIO-Tuple{IO}"><code>PyCall.PyTextIO</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PyTextIO(io::IO)
PyObject(io::IO)</code></pre><p>Julia IO streams are converted into Python objects implementing the RawIOBase interface, so they can be used for binary I/O in Python</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.ispynull-Tuple{PyObject}" href="#PyCall.ispynull-Tuple{PyObject}"><code>PyCall.ispynull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ispynull(o::PyObject)</code></pre><p>Test where <code>o</code> contains a <code>NULL</code> pointer to a Python object, i.e. whether it is equivalent to a <code>PyNULL()</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pybuiltin-Tuple{Any}" href="#PyCall.pybuiltin-Tuple{Any}"><code>PyCall.pybuiltin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pybuiltin(s::AbstractString)</code></pre><p>Look up a string or symbol <code>s</code> among the global Python builtins. If <code>s</code> is a string it returns a PyObject, while if <code>s</code> is a symbol it returns the builtin converted to <code>PyAny</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pybytes-Tuple{Union{DenseArray{UInt8,1}, String}}" href="#PyCall.pybytes-Tuple{Union{DenseArray{UInt8,1}, String}}"><code>PyCall.pybytes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pybytes(b::Union{String,DenseVector{UInt8}})</code></pre><p>Convert <code>b</code> to a Python <code>bytes</code> object.   This differs from the default <code>PyObject(b)</code> conversion of <code>String</code> to a Python string (which may fail if <code>b</code> does not contain valid Unicode), or from the default conversion of a <code>Vector{UInt8}</code> to a <code>bytearray</code> object (which is mutable, unlike <code>bytes</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pycall!-Tuple{PyObject,Union{Ptr{PyObject_struct}, PyObject},Union{Tuple{Vararg{Type,N}}, Type} where N,Vararg{Any,N} where N}" href="#PyCall.pycall!-Tuple{PyObject,Union{Ptr{PyObject_struct}, PyObject},Union{Tuple{Vararg{Type,N}}, Type} where N,Vararg{Any,N} where N}"><code>PyCall.pycall!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pycall!(ret::PyObject, o::Union{PyObject,PyPtr}, returntype::Type, args...; kwargs...)</code></pre><p>Set <code>ret</code> to the result of <code>pycall(o, returntype, args...; kwargs)</code> and return <code>convert(returntype, ret)</code>. Avoids allocating an extra PyObject for <code>ret</code>. See <code>pycall</code> for other details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pycall-Tuple{Union{Ptr{PyObject_struct}, PyObject},Union{Tuple{Vararg{Type,N}}, Type} where N,Vararg{Any,N} where N}" href="#PyCall.pycall-Tuple{Union{Ptr{PyObject_struct}, PyObject},Union{Tuple{Vararg{Type,N}}, Type} where N,Vararg{Any,N} where N}"><code>PyCall.pycall</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pycall(o::Union{PyObject,PyPtr}, returntype::TypeTuple, args...; kwargs...)</code></pre><p>Call the given Python function (typically looked up from a module) with the given args... (of standard Julia types which are converted automatically to the corresponding Python types if possible), converting the return value to returntype (use a returntype of PyObject to return the unconverted Python object reference, or of PyAny to request an automated conversion)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyeval" href="#PyCall.pyeval"><code>PyCall.pyeval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyeval(s::AbstractString, returntype::TypeTuple=PyAny, locals=PyDict{AbstractString, PyObject}(),
                            input_type=Py_eval_input; kwargs...)</code></pre><p>This evaluates <code>s</code> as a Python string and returns the result converted to <code>rtype</code> (which defaults to <code>PyAny</code>). The remaining arguments are keywords that define local variables to be used in the expression.</p><p>For example, <code>pyeval(&quot;x + y&quot;, x=1, y=2)</code> returns 3.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyfunction-Tuple{Any,Vararg{Any,N} where N}" href="#PyCall.pyfunction-Tuple{Any,Vararg{Any,N} where N}"><code>PyCall.pyfunction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pyfunction(f, argtypes...; kwtypes...)</code></pre><p>Create a Python object that wraps around the Julia function (or callable object) <code>f</code>.   Unlike <code>PyObject(f)</code>, this allows you to specify the argument types that the Julia function expects — giving you more control and potentially better performance.</p><p><code>kwtypes...</code> should be a set of <code>somekeyword=SomeType</code> arguments giving the desired Julia type for each keyword <code>somekeyword</code>.  Unspecified keywords are converted to <code>PyAny</code> (i.e. auto-detected) by default.</p><p>The return value <code>ret = f(...)</code> is still converted back to a Python object by <code>PyObject(ret)</code>.   If you want a different return-type conversion than the default of <code>PyObject(ret)</code>, you can instead call <code>pyfunctionret</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyfunctionret-Tuple{Any,Any,Vararg{Any,N} where N}" href="#PyCall.pyfunctionret-Tuple{Any,Any,Vararg{Any,N} where N}"><code>PyCall.pyfunctionret</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pyfunctionret(f, returntype, argtypes...; kwtypes...)</code></pre><p>Like <code>pyfunction</code>, but also lets you specify the <code>returntype</code> for conversion back to Python.   In particular, if <code>ret = f(...)</code> is the return value of <code>f</code>, then it is converted to Python via <code>PyObject(returntype(ret))</code>.</p><p>If <code>returntype</code> is <code>Any</code>, then <code>ret</code> is not converted to a &quot;native&quot; Python type at all, and is instead converted to a &quot;wrapped&quot; Julia object in Python.  If <code>returntype</code> is <code>nothing</code>, then the return value is discarded and <code>nothing</code> is returned to Python.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pygui-Tuple{}" href="#PyCall.pygui-Tuple{}"><code>PyCall.pygui</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pygui()</code></pre><p>Return the current GUI toolkit as a symbol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pygui_start" href="#PyCall.pygui_start"><code>PyCall.pygui_start</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pygui_start(gui::Symbol = pygui())</code></pre><p>Start the event loop of a certain toolkit.</p><p>The argument <code>gui</code> defaults to the current default GUI, but it could be <code>:wx</code>, <code>:gtk</code>, <code>:gtk3</code>, <code>:tk</code>, or <code>:qt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pygui_stop" href="#PyCall.pygui_stop"><code>PyCall.pygui_stop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pygui_stop(gui::Symbol = pygui())</code></pre><p>Stop any running event loop for gui. The <code>gui</code> argument defaults to current default GUI.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyimport-Tuple{AbstractString}" href="#PyCall.pyimport-Tuple{AbstractString}"><code>PyCall.pyimport</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pyimport(s::AbstractString)</code></pre><p>Import the Python module <code>s</code> (a string or symbol) and return a pointer to it (a <code>PyObject</code>). Functions or other symbols in the module may then be looked up by s[name] where name is a string (for the raw PyObject) or symbol (for automatic type-conversion). Unlike the @pyimport macro, this does not define a Julia module and members cannot be accessed with <code>s.name</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyimport_conda" href="#PyCall.pyimport_conda"><code>PyCall.pyimport_conda</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pyimport_conda(modulename, condapkg, [channel])</code></pre><p>Returns the result of <code>pyimport(modulename)</code> if possible.   If the module is not found, and PyCall is configured to use the Conda Python distro (via the Julia Conda package), then automatically install <code>condapkg</code> via <code>Conda.add(condapkg)</code> and then re-try the <code>pyimport</code>.   Other Anaconda-based Python installations are also supported as long as their <code>conda</code> program is functioning.</p><p>If PyCall is not using Conda and the <code>pyimport</code> fails, throws an exception with an error message telling the user how to configure PyCall to use Conda for automated installation of the module.</p><p>The third argument, <code>channel</code> is an optional Anaconda &quot;channel&quot; to use for installing the package; this is useful for packages that are not included in the default Anaconda package listing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyimport_e-Tuple{AbstractString}" href="#PyCall.pyimport_e-Tuple{AbstractString}"><code>PyCall.pyimport_e</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pyimport_e(s::AbstractString)</code></pre><p>Like <code>pyimport(s)</code>, but returns an <code>ispynull(o) == true</code> object if the module cannot be imported rather than throwing an error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyrepr-Tuple{PyObject}" href="#PyCall.pyrepr-Tuple{PyObject}"><code>PyCall.pyrepr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pyrepr(o::PyObject)</code></pre><p>Return a string representation of <code>o</code> corresponding to <code>repr(o)</code> in Python.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pystr-Tuple{PyObject}" href="#PyCall.pystr-Tuple{PyObject}"><code>PyCall.pystr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pystr(o::PyObject)</code></pre><p>Return a string representation of <code>o</code> corresponding to <code>str(o)</code> in Python.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pystring-Tuple{PyObject}" href="#PyCall.pystring-Tuple{PyObject}"><code>PyCall.pystring</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pystring(o::PyObject)</code></pre><p>Return a string representation of <code>o</code>.  Normally, this corresponds to <code>repr(o)</code> in Python, but unlike <code>repr</code> it should never fail (falling back to <code>str</code> or to printing the raw pointer if necessary).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pytype_mapping-Tuple{PyObject,Type}" href="#PyCall.pytype_mapping-Tuple{PyObject,Type}"><code>PyCall.pytype_mapping</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pytype_mapping(pytype, jltype)</code></pre><p>Given a Python type object <code>pytype</code>, tell PyCall to convert it to <code>jltype</code> in <code>PyAny(object)</code> conversions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pytype_query" href="#PyCall.pytype_query"><code>PyCall.pytype_query</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pytype_query(o::PyObject, default=PyObject)</code></pre><p>Given a Python object <code>o</code>, return the corresponding native Julia type (defaulting to <code>default</code>) that we convert <code>o</code> to in <code>PyAny(o)</code> conversions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pywrap" href="#PyCall.pywrap"><code>PyCall.pywrap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pywrap(o::PyObject)</code></pre><p>This returns a wrapper <code>w</code> that is an anonymous module which provides (read) access to converted versions of o&#39;s members as w.member.</p><p>For example, <code>@pyimport module as name</code> is equivalent to <code>const name = pywrap(pyimport(&quot;module&quot;))</code></p><p>If the Python module contains identifiers that are reserved words in Julia (e.g. function), they cannot be accessed as <code>w.member</code>; one must instead use <code>w.pymember(:member)</code> (for the PyAny conversion) or w.pymember(&quot;member&quot;) (for the raw PyObject).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.__pycall!-Tuple{PyObject,Ptr{PyCall.PyObject_struct},Union{Ptr{PyObject_struct}, PyObject},Union{Ptr{Nothing}, PyObject}}" href="#PyCall.__pycall!-Tuple{PyObject,Ptr{PyCall.PyObject_struct},Union{Ptr{PyObject_struct}, PyObject},Union{Ptr{Nothing}, PyObject}}"><code>PyCall.__pycall!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Lowest level version of  <code>pycall!(ret, o, ...)</code>, assumes <code>pyargsptr</code> and <code>kw</code> have all their args set to Python values, so we can just call the function <code>o</code>. Sets <code>ret.o</code> to the result of the call, and returns <code>ret::PyObject</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall._pycall!" href="#PyCall._pycall!"><code>PyCall._pycall!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Low-level version of <code>pycall!(ret, o, ...)</code> for when <code>kw</code> is already in python friendly format but you don&#39;t have the python tuple to hold the arguments (<code>pyargsptr</code>). Sets <code>ret.o</code> to the result of the call, and returns <code>ret::PyObject</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall._pycall!-Tuple{PyObject,Union{Ptr{PyObject_struct}, PyObject},Any,Any}" href="#PyCall._pycall!-Tuple{PyObject,Union{Ptr{PyObject_struct}, PyObject},Any,Any}"><code>PyCall._pycall!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Low-level version of <code>pycall!(ret, o, ...; kwargs...)</code> Sets <code>ret.o</code> to the result of the call, and returns <code>ret::PyObject</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.anaconda_conda-Tuple{}" href="#PyCall.anaconda_conda-Tuple{}"><code>PyCall.anaconda_conda</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">anaconda_conda()</code></pre><p>Return the path of the <code>conda</code> program if PyCall is configured to use an Anaconda install (but <em>not</em> the Conda.jl Python), and the empty string otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.def_py_class-Tuple{AbstractString,Array{T,1} where T}" href="#PyCall.def_py_class-Tuple{AbstractString,Array{T,1} where T}"><code>PyCall.def_py_class</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">def_py_class(type_name::AbstractString, methods::Vector;
             base_classes=[], getsets::Vector=[])</code></pre><p><code>def_py_class</code> creates a Python class whose methods are implemented in Julia. <code>@pydef</code> macros expand into a call to this function.</p><p><strong>Arguments</strong></p><ul><li><code>methods</code>: a vector of tuples <code>(py_name::String, jl_fun::Function)</code>  <code>py_name</code> will be a method of the Python class, which will call <code>jl_fun</code></li><li><code>base_classes</code>: the Python base classes to inherit from.</li></ul><p>Return value: the created class (<code>::PyTypeObject</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pyreturn-Tuple{Any}" href="#PyCall.pyreturn-Tuple{Any}"><code>PyCall.pyreturn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pyreturn(x) :: PyPtr</code></pre><p>Prepare <code>PyPtr</code> from <code>x</code> for passing it to Python.  If <code>x</code> is already a <code>PyObject</code>, the refcount is incremented.  Otherwise a <code>PyObject</code> wrapping/converted from <code>x</code> is created.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyCall.pystealref!-Tuple{PyObject}" href="#PyCall.pystealref!-Tuple{PyObject}"><code>PyCall.pystealref!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>&quot;Steal&quot; a reference from a PyObject: return the raw PyPtr, while setting the corresponding <code>o.o</code> field to <code>NULL</code> so that no decref will be performed when <code>o</code> is garbage collected.  (This means that you can no longer use <code>o</code>.)  Used for passing objects to Python.</p></div></div></section><footer><hr/></footer></article></body></html>
