<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DelayDiffEq.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DelayDiffEq.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.Discontinuity" href="#DelayDiffEq.Discontinuity"><code>DelayDiffEq.Discontinuity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Discontinuity(t, order::Int)</code></pre><p>Object of discontinuity of order <code>order</code> at time <code>t</code>, i.e. discontinuity of <code>order</code>th derivative at time <code>t</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.MethodOfSteps-Tuple{Any}" href="#DelayDiffEq.MethodOfSteps-Tuple{Any}"><code>DelayDiffEq.MethodOfSteps</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">MethodOfSteps(alg; constrained::Bool=false, fixedpoint_abstol=nothing,
              fixedpoint_reltol=nothing, fixedpoint_norm=nothing,
              max_fixedpoint_iters::Int=10)</code></pre><p>Construct an algorithm that solves delay differential equations by the method of steps, where <code>alg</code> is an ODE algorithm from OrdinaryDiffEq.jl without lazy interpolation upon which the calculation of steps is based.</p><p>If the algorithm is <code>constrained</code> only steps of size at most the minimal delay will be taken. If it is unconstrained, fixed-point iteration is applied for step sizes that exceed the minimal delay.</p><p>The absolute and relative tolerance of the fixed-point iterations can be set by <code>fixedpoint_abstol</code> and <code>fixedpoint_reltol</code>, respectively, either as scalars or vectors. Based on these tolerances error estimates are calculated during the fixed-point iterations with a norm that may be specified as <code>fixedpoint_norm</code>. Fixed-point iterations are stopped if the error estimate is less than 1 or after the maximal number <code>max_fixedpoint_iters</code> of iteration steps.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.auto_dt_reset!-Tuple{DelayDiffEq.DDEIntegrator}" href="#DiffEqBase.auto_dt_reset!-Tuple{DelayDiffEq.DDEIntegrator}"><code>DiffEqBase.auto_dt_reset!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">auto_dt_reset!(dde_int::DDEIntegrator)</code></pre><p>Automatically determine initial time step of <code>dde_int</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.get_proposed_dt-Tuple{DelayDiffEq.DDEIntegrator}" href="#DiffEqBase.get_proposed_dt-Tuple{DelayDiffEq.DDEIntegrator}"><code>DiffEqBase.get_proposed_dt</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_proposed_dt(integrator::DDEIntegrator)</code></pre><p>Get the time step that <code>integrator</code> will take after the current step.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.initialize!-Tuple{DelayDiffEq.DDEIntegrator}" href="#DiffEqBase.initialize!-Tuple{DelayDiffEq.DDEIntegrator}"><code>DiffEqBase.initialize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">initialize!(integrator::DDEIntegrator)</code></pre><p>Set initial values of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.reeval_internals_due_to_modification!-Union{Tuple{DDEIntegrator}, Tuple{not_initialization}, Tuple{DDEIntegrator,Type{Val{not_initialization}}}} where not_initialization" href="#DiffEqBase.reeval_internals_due_to_modification!-Union{Tuple{DDEIntegrator}, Tuple{not_initialization}, Tuple{DDEIntegrator,Type{Val{not_initialization}}}} where not_initialization"><code>DiffEqBase.reeval_internals_due_to_modification!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reeval_internals_due_to_modification!(integrator::DDEIntegrator)</code></pre><p>Recalculate interpolation data and update ODE integrator after changes by callbacks.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.reinit!" href="#DiffEqBase.reinit!"><code>DiffEqBase.reinit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reinit!(integrator::DDEIntegrator[, u0 = integrator.sol.prob.u0;
        t0 = integrator.sol.prob.tspan[1],
        tf = integrator.sol.prob.tspan[2],
        erase_sol = true,
        kwargs...])</code></pre><p>Reinitialize <code>integrator</code> with (optionally) different initial state <code>u0</code>, different integration interval from <code>t0</code> to <code>tf</code>, and erased solution if <code>erase_sol = true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.set_proposed_dt!-Tuple{DelayDiffEq.DDEIntegrator,Any}" href="#DiffEqBase.set_proposed_dt!-Tuple{DelayDiffEq.DDEIntegrator,Any}"><code>DiffEqBase.set_proposed_dt!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_proposed_dt!(integrator::DDEIntegrator, dt)</code></pre><p>Set the time step that <code>integrator</code> will take after the current step to <code>dt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.terminate!-Tuple{DelayDiffEq.DDEIntegrator}" href="#DiffEqBase.terminate!-Tuple{DelayDiffEq.DDEIntegrator}"><code>DiffEqBase.terminate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">terminate!(integrator::DDEIntegrator)</code></pre><p>Stop further calculations of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.u_modified!-Tuple{DelayDiffEq.DDEIntegrator,Bool}" href="#DiffEqBase.u_modified!-Tuple{DelayDiffEq.DDEIntegrator,Bool}"><code>DiffEqBase.u_modified!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">u_modified!(integrator::DDEIntegrator, bool::Bool)</code></pre><p>Signal <code>integrator</code> whether state vector <code>u</code> was modified by a callback.</p><p>A modified <code>u</code> will lead to recalculations in order to prevent discontinuities.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.DiscontinuityCallback-Tuple{Any,Array{#s19066,1} where #s19066&lt;:Discontinuity}" href="#DelayDiffEq.DiscontinuityCallback-Tuple{Any,Array{#s19066,1} where #s19066&lt;:Discontinuity}"><code>DelayDiffEq.DiscontinuityCallback</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DiscontinuityCallback(lags, discontinuities::Vector{&lt;:Discontinuity};
                      [interp_points::Int=10, abstol=1e-12, reltol=0])</code></pre><p>Callback that tracks <code>discontinuities</code> that are propagated by dependent <code>lags</code> of the form <code>(u,p,t) -&gt; lag(u,p,t)</code>.</p><p>Hereby a number <code>interp_points</code> of interpolation points are used to first check for different signs of functions <span>$f(t) = T + lag(u(t),p,t) - t$</span>, where <span>$T$</span> is time point of a previous discontinuity and <span>$t$</span> is contained in the current time interval. This shows that the current time interval contains propagated discontinuities of which the exact time point is then determined by a root finding algorithm. The sign at the lower bound of the time interval, i.e. at <code>tprev</code>, is set to 0 with absolute tolerance <code>abstol</code> and relative tolerance <code>reltol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.HistoryFunction" href="#DelayDiffEq.HistoryFunction"><code>DelayDiffEq.HistoryFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HistoryFunction(h, sol, integrator)</code></pre><p>Wrap history function <code>h</code>, solution <code>sol</code>, and integrator <code>integrator</code> to create a common interface for retrieving values at any time point with varying accuracy.</p><p>Before the initial time point of solution <code>sol</code> values are calculated by history function <code>h</code>, for time points in the time span of <code>sol</code> interpolated values of <code>sol</code> are returned, and after the final time point of <code>sol</code> an inter- or extrapolation of the current state of integrator <code>integrator</code> is retrieved.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.add_next_discontinuities!" href="#DelayDiffEq.add_next_discontinuities!"><code>DelayDiffEq.add_next_discontinuities!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_next_discontinuities!(integrator::DDEIntegrator, order[, t=integrator.t])</code></pre><p>Add discontinuities of next order that are propagated from discontinuity of order <code>order</code> at time <code>t</code> in <code>integrator</code>, but only if <code>order</code> is less or equal than the order of the applied method or the problem is neutral.</p><p>Discontinuities caused by constant delays are immediately calculated, and discontinuities caused by dependent delays are tracked by a callback.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.advance_ode_integrator!-Tuple{DelayDiffEq.DDEIntegrator}" href="#DelayDiffEq.advance_ode_integrator!-Tuple{DelayDiffEq.DDEIntegrator}"><code>DelayDiffEq.advance_ode_integrator!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">advance_ode_integrator!(integrator::DDEIntegrator)</code></pre><p>Advance ODE integrator of <code>integrator</code> to next time interval, values and complete interpolation data of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.agrees-NTuple{4,Any}" href="#DelayDiffEq.agrees-NTuple{4,Any}"><code>DelayDiffEq.agrees</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">agrees(h, u, p, t)</code></pre><p>Determine whether history function evaluates to <code>u</code> at time point <code>t</code> for parameters <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.assign_expr-Union{Tuple{name}, Tuple{Val{name},Type,Type}} where name" href="#DelayDiffEq.assign_expr-Union{Tuple{name}, Tuple{Val{name},Type,Type}} where name"><code>DelayDiffEq.assign_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">assign_expr(::Val{name}, ::Type{T}, ::Type{cache})</code></pre><p>Create expression that extracts field <code>name</code> of type <code>T</code> from cache of type <code>cache</code> to variable <code>name</code>.</p><p>Hereby u, uprev, uprev2, and function f are updated, if required.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.build_linked_cache-NTuple{9,Any}" href="#DelayDiffEq.build_linked_cache-NTuple{9,Any}"><code>DelayDiffEq.build_linked_cache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">build_linked_cache(cache, alg, u, uprev, uprev2, f, t, dt)</code></pre><p>Create cache for algorithm <code>alg</code> from existing cache <code>cache</code> with updated <code>u</code>, <code>uprev</code>, <code>uprev2</code>, <code>f</code>, <code>t</code>, and <code>dt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.build_solution_array-Tuple{DelayDiffEq.DDEIntegrator}" href="#DelayDiffEq.build_solution_array-Tuple{DelayDiffEq.DDEIntegrator}"><code>DelayDiffEq.build_solution_array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">build_solution_array(integrator::DDEIntegrator)</code></pre><p>Create a <code>DiffEqArray</code> of the time points and values that form the solution of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.build_solution_interpolation-Tuple{DelayDiffEq.DDEIntegrator,RecursiveArrayTools.DiffEqArray}" href="#DelayDiffEq.build_solution_interpolation-Tuple{DelayDiffEq.DDEIntegrator,RecursiveArrayTools.DiffEqArray}"><code>DelayDiffEq.build_solution_interpolation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">build_solution_interpolation(integrator::DDEIntegrator, sol::DiffEqArray)</code></pre><p>Create interpolation data to solution of <code>integrator</code>, which is formed by time points and values in <code>sol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.constant_extrapolant!-Tuple{Any,Any,DiffEqBase.DEIntegrator,Any,Any}" href="#DelayDiffEq.constant_extrapolant!-Tuple{Any,Any,DiffEqBase.DEIntegrator,Any,Any}"><code>DelayDiffEq.constant_extrapolant!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">constant_extrapolant!(val, t, integrator::DEIntegrator, idxs, deriv)</code></pre><p>Calculate constant extrapolation of derivative <code>deriv</code> at time <code>t</code> and indices <code>idxs</code> for <code>integrator</code>, and save result in <code>val</code> if <code>val</code> is not <code>nothing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.constant_extrapolant-Tuple{Any,DiffEqBase.DEIntegrator,Any,Any}" href="#DelayDiffEq.constant_extrapolant-Tuple{Any,DiffEqBase.DEIntegrator,Any,Any}"><code>DelayDiffEq.constant_extrapolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">constant_extrapolant(t, integrator::DEIntegrator, idxs, deriv)</code></pre><p>Calculate constant extrapolation of derivative <code>deriv</code> at time <code>t</code> and indices <code>idxs</code> for <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.determine_discontinuity_existence-Tuple{Int64,Int64,Any,Any}" href="#DelayDiffEq.determine_discontinuity_existence-Tuple{Int64,Int64,Any,Any}"><code>DelayDiffEq.determine_discontinuity_existence</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">determine_discontinuity_existence(prev_sign::Int, next_sign::Int, Θs, f)</code></pre><p>Determine whether function <code>f</code> has a root in the interval [0, 1] by checking signs of <code>f</code> at 0 and 1 (<code>prev_sign</code> and <code>next_sign</code>, respectively) and at interpolation points in <code>Θs</code>.</p><p>This corresponds to the existence of a propagated discontinuity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.find_discontinuity_time-Tuple{DelayDiffEq.DDEIntegrator,DelayDiffEq.DiscontinuityCallback,Int64,Int64,Any,Any}" href="#DelayDiffEq.find_discontinuity_time-Tuple{DelayDiffEq.DDEIntegrator,DelayDiffEq.DiscontinuityCallback,Int64,Int64,Any,Any}"><code>DelayDiffEq.find_discontinuity_time</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">find_discontinuity_time(integrator::DDEIntegrator, callback::DiscontinuityCallback,
                        prev_sign::Int, next_sign::Int, Θs, f)</code></pre><p>Find time of propagated discontinuity for a certain dependent delay and previous discontinuity, which is root of the function <code>f</code>, in the current time interval of <code>integrator</code> with interpolation points <code>Θs</code>. Hereby <code>f</code> shows signs <code>prev_sign</code> and <code>next_sign</code> at both ends of the time interval.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.fsal_typeof-Union{Tuple{ODEIntegrator{#s19069,uType,tType,P,eigenType,tTypeNoUnits,tdirType,ksEltype,SolType,F,CacheType,O,FSALType,EventErrorType} where EventErrorType where #s19069&lt;:OrdinaryDiffEqAlgorithm}, Tuple{FSALType}, Tuple{O}, Tuple{CacheType}, Tuple{F}, Tuple{SolType}, Tuple{ksEltype}, Tuple{tdirType}, Tuple{tTypeNoUnits}, Tuple{eigenType}, Tuple{P}, Tuple{tType}, Tuple{uType}} where FSALType where O where CacheType where F where SolType where ksEltype where tdirType where tTypeNoUnits where eigenType where P where tType where uType" href="#DelayDiffEq.fsal_typeof-Union{Tuple{ODEIntegrator{#s19069,uType,tType,P,eigenType,tTypeNoUnits,tdirType,ksEltype,SolType,F,CacheType,O,FSALType,EventErrorType} where EventErrorType where #s19069&lt;:OrdinaryDiffEqAlgorithm}, Tuple{FSALType}, Tuple{O}, Tuple{CacheType}, Tuple{F}, Tuple{SolType}, Tuple{ksEltype}, Tuple{tdirType}, Tuple{tTypeNoUnits}, Tuple{eigenType}, Tuple{P}, Tuple{tType}, Tuple{uType}} where FSALType where O where CacheType where F where SolType where ksEltype where tdirType where tTypeNoUnits where eigenType where P where tType where uType"><code>DelayDiffEq.fsal_typeof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fsal_typeof(integrator::ODEIntegrator)</code></pre><p>Return type of FSAL of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelayDiffEq.reduce_solution!-Tuple{DelayDiffEq.DDEIntegrator,Any}" href="#DelayDiffEq.reduce_solution!-Tuple{DelayDiffEq.DDEIntegrator,Any}"><code>DelayDiffEq.reduce_solution!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reduce_solution!(integrator::DDEIntegrator, tmax)</code></pre><p>Remove time points of ODE solution of <code>integrator</code> up to time <code>tmax</code> that are not required for calculation of DDE solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.apply_callback!-Tuple{DelayDiffEq.DDEIntegrator,DelayDiffEq.DiscontinuityCallback,Any,Any}" href="#DiffEqBase.apply_callback!-Tuple{DelayDiffEq.DDEIntegrator,DelayDiffEq.DiscontinuityCallback,Any,Any}"><code>DiffEqBase.apply_callback!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">apply_callback!(integrator::DDEIntegrator, callback::DiscontinuityCallback, cb_time,
                order)</code></pre><p>Handle discontinuity of order <code>order</code> at time <code>integrator.tprev + cb_time</code> in the current time interval of <code>integrator</code> that was found by <code>callback</code>. Cause the current step to fail, and add the found discontinuity to both the heap of discontinuities and of time stops.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.postamble!-Tuple{DelayDiffEq.DDEIntegrator}" href="#DiffEqBase.postamble!-Tuple{DelayDiffEq.DDEIntegrator}"><code>DiffEqBase.postamble!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">postamble!(integrator::DDEIntegrator)</code></pre><p>Clean up solution of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.handle_discontinuities!-Tuple{DelayDiffEq.DDEIntegrator}" href="#OrdinaryDiffEq.handle_discontinuities!-Tuple{DelayDiffEq.DDEIntegrator}"><code>OrdinaryDiffEq.handle_discontinuities!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle_discontinuities!(integrator::DDEIntegrator)</code></pre><p>Handle discontinuities at the current time point of <code>integrator</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.perform_step!-Tuple{DelayDiffEq.DDEIntegrator}" href="#OrdinaryDiffEq.perform_step!-Tuple{DelayDiffEq.DDEIntegrator}"><code>OrdinaryDiffEq.perform_step!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">perform_step!(integrator::DDEIntegrator)</code></pre><p>Calculate next step of <code>integrator</code>.</p></div></div></section><footer><hr/></footer></article></body></html>
