<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · AbstractTrees.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractTrees.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.Leaves" href="#AbstractTrees.Leaves"><code>AbstractTrees.Leaves</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Iterator to visit the leaves of a tree, e.g. for the tree</p><p>Any[1,Any[2,3]] ├─ 1 └─ Any[2,3]    ├─ 2    └─ 3</p><p>we will get [1,2,3]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.PostOrderDFS" href="#AbstractTrees.PostOrderDFS"><code>AbstractTrees.PostOrderDFS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Iterator to visit the nodes of a tree, guaranteeing that children will be visited before their parents.</p><p>e.g. for the tree</p><p>Any[1,Any[2,3]] ├─ 1 └─ Any[2,3]    ├─ 2    └─ 3</p><p>we will get [1,2,3,Any[2,3],Any[1,Any[2,3]]]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.PreOrderDFS" href="#AbstractTrees.PreOrderDFS"><code>AbstractTrees.PreOrderDFS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Iterator to visit the nodes of a tree, guaranteeing that parents will be visited before their children.</p><p>Optionally takes a filter function that determines whether the iterator should continue iterating over a node&#39;s children (if it has any) or should consider that node a leaf.</p><p>e.g. for the tree</p><p>Any[Any[1,2],Any[3,4]] ├─ Any[1,2] |  ├─ 1 |  └─ 2 └─ Any[3,4]    ├─ 3    └─ 4</p><p>we will get [Any[Any[1,2],Any[3,4]],Any[1,2],1,2,Any[3,4],3,4]</p><p><strong>Invalidation</strong></p><p>Modifying the underlying tree while iterating over it, is allowed, however, if parents and sibling links are not explicitly stored, the identify of any parent of the last obtained node does not change (i.e. mutation is allowed, replacing nodes is not).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.StatelessBFS" href="#AbstractTrees.StatelessBFS"><code>AbstractTrees.StatelessBFS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Iterator to visit the nodes of a tree, all nodes of a level will be visited before their children</p><p>e.g. for the tree</p><p>Any[1,Any[2,3]] ├─ 1 └─ Any[2,3]    ├─ 2    └─ 3</p><p>we will get [Any[1,Any[2,3]],1,Any[2,3],2,3]</p><p>WARNING: This is O(n^2), only use this if you know you need it, as opposed to a more standard statefull approach.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.ImplicitNodeStack" href="#AbstractTrees.ImplicitNodeStack"><code>AbstractTrees.ImplicitNodeStack</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Keeps a stack of nodes and their corresponding indices. Note that the last node is not explicitly stored in the node<em>stack, such that length(node</em>stack) == length(idx_stack)-1 (unless we&#39;re at the root in which case both are empty)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.StoredParents" href="#AbstractTrees.StoredParents"><code>AbstractTrees.StoredParents</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Indicates that this tree stores parent links explicitly. The implementation   is responsible for defining the parentind function to expose this   information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.StoredSiblings" href="#AbstractTrees.StoredSiblings"><code>AbstractTrees.StoredSiblings</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Indicates that this tree stores sibling links explicitly, or can compute them   quickly (e.g. because the tree has a (small) fixed branching ratio, so the   current index of a node can be determined by quick linear search). The   implementation is responsible for defining the relative_state function   to expose this information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees._print_tree" href="#AbstractTrees._print_tree"><code>AbstractTrees._print_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Usage</strong></p><p>Prints an ASCII formatted representation of the <code>tree</code> to the given <code>io</code> object. By default all children will be printed up to a maximum level of 5, though this valud can be overriden by the <code>maxdepth</code> parameter. The charset to use in printing can be customized using the <code>charset</code> keyword argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; print_tree(STDOUT,Dict(&quot;a&quot;=&gt;&quot;b&quot;,&quot;b&quot;=&gt;[&#39;c&#39;,&#39;d&#39;]))
Dict{String,Any}(&quot;b&quot;=&gt;[&#39;c&#39;,&#39;d&#39;],&quot;a&quot;=&gt;&quot;b&quot;)
├─ b
│  ├─ c
│  └─ d
└─ a
   └─ b

julia&gt; print_tree(STDOUT,Dict(&quot;a&quot;=&gt;&quot;b&quot;,&quot;b&quot;=&gt;[&#39;c&#39;,&#39;d&#39;]);
        charset = TreeCharSet(&#39;+&#39;,&#39;\\&#39;,&#39;|&#39;,&quot;--&quot;))
Dict{String,Any}(&quot;b&quot;=&gt;[&#39;c&#39;,&#39;d&#39;],&quot;a&quot;=&gt;&quot;b&quot;)
+-- b
|   +-- c
|   \-- d
\-- a
   \-- b</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.ascend-Tuple{Any,Any}" href="#AbstractTrees.ascend-Tuple{Any,Any}"><code>AbstractTrees.ascend</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Acends the tree, at each node choosing whether or not to continue.
Note that the parent is computed before the callback is exectuted, allowing
modification of the argument to the callback (as long as the overall tree
structure is not altered).</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.descend-Tuple{Any,Any}" href="#AbstractTrees.descend-Tuple{Any,Any}"><code>AbstractTrees.descend</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Descends the tree, at each node choosing the child given by select callback
or the current node if 0 is returned.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractTrees.rootstate-Tuple{Any}" href="#AbstractTrees.rootstate-Tuple{Any}"><code>AbstractTrees.rootstate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Trees must override with method if the state of the root is not the same as the tree itself (e.g. IndexedTrees should always override this method).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.iterate-Tuple{StatelessBFS,Any}" href="#Base.iterate-Tuple{StatelessBFS,Any}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Stateless level-order bfs iteration. The algorithm is as follows:</p><p>Go up. If there is a right neighbor, go right, then left until you reach the same level. If you reach the root, go left until you reach the next level.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
