<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DependentBootstrap.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DependentBootstrap.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BootInput" href="#DependentBootstrap.BootInput"><code>DependentBootstrap.BootInput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BootInput</code></pre><p>Core type that defines all parameters needed to perform a bootstrap procedure. The vast majority of users should use the keyword argument constructor that has the method signature:</p><pre><code class="language-none">BootInput(data ; kwargs...)</code></pre><p>where data is the dataset to be bootstrapped, and kwargs denotes a set of keyword arguments (defined below) that are used for every exported function in the DependentBootstrap package. The following keyword arguments and default values follow: </p><pre><code class="language-none">- blocklength         &lt;- Block length for bootstrapping procedure. Default value is 0. Set to &lt;= 0 to auto-estimate the optimal block length from the dataset. Float64 inputs allowed.
- numresample         &lt;- Number of times to resample the input dataset. Default value is the module constant NUM_RESAMPLE, currently set to 1000.
- bootmethod          &lt;- Bootstrapping methodology to use. Default value is the Symbol :stationary (for the stationary bootstrap).
- blocklengthmethod   &lt;- Block length selection procedure to use if user wishes to auto-estimate the block length. Default value is the Symbol :ppw2009 (use the method described in Patton, Politis, and White (2009)).
- flevel1             &lt;- A function that converts the input dataset to the estimator that the user wishes to bootstrap. Default value is the sample mean.
- flevel2             &lt;- A function that converts a vector of estimators constructed by flevel1 into a distributional parameter. Default value is sample variance.
- numobsperresample   &lt;- Number of observations to be drawn (with replacement) per resample. The default value is the number of observations in the dataset (the vast majority of users will want this default value).
- fblocklengthcombine &lt;- A function for converting a Vector{Float64} of estimated blocklengths to a single Float64 blocklength estimate. Default value is median.</code></pre><p>The constructor will attempt to convert all provided keyword arguments to appropriate types, and will notify the user via an error if a supplied keyword argument is not valid.</p><p>Note that the bootmethod and blocklengthmethod keyword arguments will accept both Symbol and String inputs, and will convert them to BootMethod and BlockLengthMethod types internally. To see a list of acceptable Symbol or String values for the bootmethod and blocklengthmethod keyword arguments, use: </p><pre><code class="language-none">- collect(keys(DependentBootstrap.BOOT_METHOD_DICT))
- collect(keys(DependentBootstrap.BLOCKLENGTH_METHOD_DICT))</code></pre><p>respectively. A small proportion of users may need the fine-grained control that comes from constructing BootMethod and BlockLengthMethod types explicitly and then providing them to the keyword constructor. These users should use ?BootMethod and ?BlockLengthMethod at the REPL for more info.</p><p>BootInput is not mutable, but the type is near instantaneous to construct, so if a user wishes to amend a BootInput it is recommended to just construct another one. A special constructor is provided to facilitate this process that has the method definition: </p><pre><code class="language-none">- BootInput(data, bootinput::BootInput ; kwargs...)</code></pre><p>where the new BootInput draws its fields from the keyword arguments that are provided, and then the input BootInput for any keyword arguments that are not provided.</p><p>Note that all exported functions in the DependentBootstrap package exhibit the method signature: </p><pre><code class="language-none">- exported_func(data ; kwargs...)</code></pre><p>which in practice just wraps the keyword argument constructor for a BootInput, and then calls the method signature: </p><pre><code class="language-none"> - exported_func(data, bootinput::BootInput)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dboot-Tuple{Any,BootInput}" href="#DependentBootstrap.dboot-Tuple{Any,BootInput}"><code>DependentBootstrap.dboot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dboot(data, bi::BootInput)
dboot(data ; kwargs...)</code></pre><p>Get the level 2 bootstrapped statistics associated with dataset in data, and bootstrap methodology in BootInput.</p><p>A keyword method that calls the keyword constructor for BootInput is also provided. Please use ?BootInput at the REPL for more detail on feasible keywords.</p><p>Note, the return type of the output will be determined by bi.flevel2, which must be a function that accepts Vector{T}, where T is the output type of bi.flevel1.</p><p>For example, if data is a Vector{&lt;:Number} and bi.flevel1 is mean, then in this case, bi.flevel1 will return Float64, and so bi.flevel2 must be some function that accepts Vector{Float64} as input (and can have any output type.)</p><p>Alternatively, bi.flevel2 could be the anonymous function (x -&gt; quantile(x, [0.025, 0.975])), in which case the input should be Vector{Float64}, and so bi.flevel1 should return Float64. Note, the output of bi.flevel2 in this case will be a 2-element Vector{Float64} with elements corresponding bootstrapped 95% confidence interval for the level1 statistic of the input dataset</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dbootconf-Tuple{Any}" href="#DependentBootstrap.dbootconf-Tuple{Any}"><code>DependentBootstrap.dbootconf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>dbootconf &lt;- Identical to dboot but with the level 2 statistic set to a confidence interval with width determined by keyword alpha. Default alpha=0.05 corresponds to a 95% confidence interval.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dbootdata-Union{Tuple{Td}, Tuple{Td,BootInput}} where Td" href="#DependentBootstrap.dbootdata-Union{Tuple{Td}, Tuple{Td,BootInput}} where Td"><code>DependentBootstrap.dbootdata</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dbootdata(data::T , bi::BootInput)::Vector{T}
dbootdata(data::T ; kwargs...)::Vector{T}</code></pre><p>Get the resampled datasets of the input data using the dependent bootstrap methodology defined in BootInput.</p><p>A keyword method that calls the keyword constructor for BootInput is also provided. Please use ?BootInput at the REPL for more detail on feasible keywords.</p><p>Note, this function should always have output type Vector{T}.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dbootinds-Tuple{BootInput}" href="#DependentBootstrap.dbootinds-Tuple{BootInput}"><code>DependentBootstrap.dbootinds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dbootinds(data::T ; bi::BootInput)::Vector{Vector{Int}}
dbootinds(data::T ; kwargs...)::Vector{Vector{Int}}</code></pre><p>Each inner vector of the returned Vector{Vector{Int}} provides indices that, when used to index the original dataset, will provide a single resampled dataset.</p><p>A keyword method that calls the keyword constructor for BootInput is also provided. Please use ?BootInput at the REPL for more detail on feasible keywords.</p><p>Please use dbootinds_one if you only want to obtain a single Vector{Int} resampling index.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dbootlevel1-Tuple{Any,BootInput}" href="#DependentBootstrap.dbootlevel1-Tuple{Any,BootInput}"><code>DependentBootstrap.dbootlevel1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dbootlevel1(data::T1, bi::BootInput)
dbootlevel1(data::T1; kwargs...)</code></pre><p>Get the level 1 bootstrapped statistics associated with dataset in data, and bootstrap methodology in BootInput.</p><p>A keyword method that calls the keyword constructor for BootInput is also provided. Please use ?BootInput at the REPL for more detail on feasible keywords.</p><p>Note, the return type is determined by bi.flevel1, which must be a function that accepts T1, ie typeof(data), as input. It may return any output type T2, as long as bi.flevel2 will accept Vector{T2} as input.</p><p>For example, if data is a Vector{&lt;:Number} then bi.flevel1 might be the function mean, which in this case will return Float64, so bi.flevel2 must be some function that can accept Vector{Float64} as input.</p><p>A more complicated example: if data is Matrix{&lt;:Number} then bi.flevel1 might be the anonymous function x-&gt;mean(x,dims=1), which in this case will return a single row Matrix{Float64}, and so bi.flevel2 must be some function that can accept Vector{Matrix{Float64}} as input.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dbootlevel2-Tuple{Any,BootInput}" href="#DependentBootstrap.dbootlevel2-Tuple{Any,BootInput}"><code>DependentBootstrap.dbootlevel2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>dbootlevel2 &lt;- Identical to the dboot function. This function is only included for naming consistency with dbootlevel1</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dbootvar-Tuple{Any}" href="#DependentBootstrap.dbootvar-Tuple{Any}"><code>DependentBootstrap.dbootvar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>dbootvar &lt;- Identical to dboot but with the level 2 statistic set to variance</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.optblocklength-Union{Tuple{Tbm}, Tuple{AbstractArray{#s1190,1} where #s1190&lt;:Number,BLPPW2009{P2003},Tbm}} where Tbm&lt;:DependentBootstrap.BootMethod" href="#DependentBootstrap.optblocklength-Union{Tuple{Tbm}, Tuple{AbstractArray{#s1190,1} where #s1190&lt;:Number,BLPPW2009{P2003},Tbm}} where Tbm&lt;:DependentBootstrap.BootMethod"><code>DependentBootstrap.optblocklength</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">optblocklength(data, bi::BootInput)::Float64
optblocklength(data ; kwargs...)::Float64</code></pre><p>Provides an estimate of the optimal block-length to use with a dependent bootstrap.</p><p>For multivariate datasets, optimal block length is estimated for each column of data, and then bi.fblocklengthcombine, which is a function that maps Vector{Float64} to Float64, is called to reduce the multiple estimates to a single estimates. The default value for fblocklengthcombine is median.</p><p>Block length methods currently implemented include: </p><pre><code class="language-none"> - Patton, Politis, White (2009) &quot;Correction to Automatic Block Length Selection For the Dependent Bootstrap&quot;</code></pre><p>For all methods discussed above, bandwidth is estimated following Politis (2003) &quot;Adaptive Bandwidth Choice&quot;, using the flat-top kernel suggested in that paper.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BLDummy" href="#DependentBootstrap.BLDummy"><code>DependentBootstrap.BLDummy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BLDummy &lt;- Dummy type for block length method</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BLPPW2009" href="#DependentBootstrap.BLPPW2009"><code>DependentBootstrap.BLPPW2009</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BLPPW2009 &lt;- Type for using multiple dispatch to get the block length selection procedure of Patton, Politis, and White (2009)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BandwidthMethod" href="#DependentBootstrap.BandwidthMethod"><code>DependentBootstrap.BandwidthMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BandwidthMethod &lt;- Abstract supertype for all bandwidth selection methods</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BlockLengthMethod" href="#DependentBootstrap.BlockLengthMethod"><code>DependentBootstrap.BlockLengthMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BlockLengthMethod &lt;- Abstract supertype for all block length selection methods</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BootCircular" href="#DependentBootstrap.BootCircular"><code>DependentBootstrap.BootCircular</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BootCircular &lt;- Type for using multiple dispatch to get the circular blocks bootstrap</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BootDummy" href="#DependentBootstrap.BootDummy"><code>DependentBootstrap.BootDummy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BootDummy &lt;- Dummy type used within the module. Should never be seen by the end user</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BootIID" href="#DependentBootstrap.BootIID"><code>DependentBootstrap.BootIID</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BootIID &lt;- Type for using multiple dispatch to get the IID boostrap</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BootMethod" href="#DependentBootstrap.BootMethod"><code>DependentBootstrap.BootMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BootMethod &lt;- Abstract supertype for all dependent bootstrap methods</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BootMoving" href="#DependentBootstrap.BootMoving"><code>DependentBootstrap.BootMoving</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BootMoving &lt;- Type for using multiple dispatch to get the moving blocks bootstrap</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BootNoOverlap" href="#DependentBootstrap.BootNoOverlap"><code>DependentBootstrap.BootNoOverlap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BootNoOverlap &lt;- Type for using multiple dispatch to get the non-overlapping blocks bootstrap</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.BootStationary" href="#DependentBootstrap.BootStationary"><code>DependentBootstrap.BootStationary</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>BootStationary &lt;- Type for using multiple dispatch to get the stationary bootstrap</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.KernelDummy" href="#DependentBootstrap.KernelDummy"><code>DependentBootstrap.KernelDummy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>KernelDummy &lt;- Dummy type for kernel functions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.KernelFunctionMethod" href="#DependentBootstrap.KernelFunctionMethod"><code>DependentBootstrap.KernelFunctionMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>KernelFunctionMethod &lt;- Abstract supertype for all kernel function methods</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.P2003" href="#DependentBootstrap.P2003"><code>DependentBootstrap.P2003</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>P2003 &lt;- Type for using multiple dispatch to get the bandwidth selection procedure of Politis (2003)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.bandwidth_politis_2003-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Number" href="#DependentBootstrap.bandwidth_politis_2003-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Number"><code>DependentBootstrap.bandwidth_politis_2003</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">bandwidth_politis_2003(x::AbstractVector{T})::Tuple{Int, Float64, Vector{Float64}} where {T&lt;:Number}</code></pre><p>Implements the methodology from Politis (2003) &quot;Adaptive Bandwidth Choice&quot; to obtain a data-driven bandwidth estimate.</p><p>Return tuple is, in order, the bandwidth estimate, the variance of x, and the autocorrelations used to get the bandwidth estimate.</p><p>Note, most users won&#39;t be interested in the second and third output, but sometimes this routine will be called by other functions that need these terms, so they are returned to avoid duplicate computation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.bootmethod_to_blocklengthmethod-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{BootCircular, BootIID, BootMoving, BootNoOverlap, BootStationary}" href="#DependentBootstrap.bootmethod_to_blocklengthmethod-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{BootCircular, BootIID, BootMoving, BootNoOverlap, BootStationary}"><code>DependentBootstrap.bootmethod_to_blocklengthmethod</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>bootmethod<em>to</em>blocklengthmethod &lt;- Convert a bootstrap method to the most appropriate block length method</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dbootdata_one-Union{Tuple{Td}, Tuple{Td,BootInput}} where Td" href="#DependentBootstrap.dbootdata_one-Union{Tuple{Td}, Tuple{Td,BootInput}} where Td"><code>DependentBootstrap.dbootdata_one</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dbootdata_one(data::T, bi::BootInput)::T
dbootdata_one(data::T; kwargs...)::T</code></pre><p>Get a single resampled dataset of the input data using the dependent boostrap methodology defined in BootInput.</p><p>A keyword method that calls the keyword constructor for BootInput is also provided. Please use ?BootInput at the REPL for more detail on feasible keywords.</p><p>Note, the output type will always be the same as the type of the input data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.dbootinds_one-Tuple{BootInput{DependentBootstrap.BootIID,Tbl,Tf1,Tf2,Tfc} where Tfc&lt;:Function where Tf2&lt;:Function where Tf1&lt;:Function where Tbl&lt;:DependentBootstrap.BlockLengthMethod}" href="#DependentBootstrap.dbootinds_one-Tuple{BootInput{DependentBootstrap.BootIID,Tbl,Tf1,Tf2,Tfc} where Tfc&lt;:Function where Tf2&lt;:Function where Tf1&lt;:Function where Tbl&lt;:DependentBootstrap.BlockLengthMethod}"><code>DependentBootstrap.dbootinds_one</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>dbootinds<em>one(bi::BootInput)::Vector{Int} dbootinds</em>one(data::T; kwargs...)::Vector{Int}</p><p>Returns a single resampling index that, when used to index the original dataset, will provide a single resampled dataset.</p><p>A keyword method that calls the keyword constructor for BootInput is also provided. Please use ?BootInput at the REPL for more detail on feasible keywords.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.kernel_politis_2003_flat_top-Tuple{Float64}" href="#DependentBootstrap.kernel_politis_2003_flat_top-Tuple{Float64}"><code>DependentBootstrap.kernel_politis_2003_flat_top</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">kernel_politis_2003_flat_top(x::Float64)::Float64</code></pre><p>Implements the flat-top kernel function discussed in Politis (2003) &quot;Adaptive Bandwidth Choice&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.local_get_index-Union{Tuple{T}, Tuple{AbstractArray{T,1},Array{Int64,1}}} where T" href="#DependentBootstrap.local_get_index-Union{Tuple{T}, Tuple{AbstractArray{T,1},Array{Int64,1}}} where T"><code>DependentBootstrap.local_get_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>local<em>get</em>index &lt;- Internal function used to resample the dataset data using the input resampling index inds</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.local_get_var-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64}} where T" href="#DependentBootstrap.local_get_var-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64}} where T"><code>DependentBootstrap.local_get_var</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>local<em>get</em>var &lt;- Internal function used to get the ith variable in dataset</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.num_obs-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T" href="#DependentBootstrap.num_obs-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T"><code>DependentBootstrap.num_obs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>num_obs &lt;- Internal function used to determine the number of observations in the input dataset</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DependentBootstrap.num_var-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T" href="#DependentBootstrap.num_var-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T"><code>DependentBootstrap.num_var</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>num_var &lt;- Internal function used to determine the number of variables in the input dataset</p></div></div></section><footer><hr/></footer></article></body></html>
