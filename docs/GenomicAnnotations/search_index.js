var documenterSearchIndex = {"docs": [

{
    "location": "#GenomicAnnotations.Locus",
    "page": "Home",
    "title": "GenomicAnnotations.Locus",
    "category": "type",
    "text": "Struct for storing information on genomic locations. strand can be \'+\', \'-\', or \'.\' when the strand is irrelevant.\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.Locus-Tuple{}",
    "page": "Home",
    "title": "GenomicAnnotations.Locus",
    "category": "method",
    "text": "Locus()\nLocus(position::UnitRange{Int})\nLocus(position::UnitRange{Int}, strand::Char)\n\n\n\n\n\n"
},

{
    "location": "#BioCore.sequence-Tuple{AbstractGene}",
    "page": "Home",
    "title": "BioCore.sequence",
    "category": "method",
    "text": "sequence(gene::AbstractGene)\n\nReturn genomic sequence for gene.\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.addgene!-Tuple{Chromosome,Any,Any}",
    "page": "Home",
    "title": "GenomicAnnotations.addgene!",
    "category": "method",
    "text": "addgene!(chr::Chromosome, feature, locus; kw...)\n\nAdd gene to chr. locus can be a Locus, a UnitRange, or a StepRange.\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.iscomplement-Tuple{AbstractGene}",
    "page": "Home",
    "title": "GenomicAnnotations.iscomplement",
    "category": "method",
    "text": "iscomplement(gene::Abstract)\n\nReturn true if gene.locus.compliment == \'-\', otherwise return false.\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.pushproperty!-Union{Tuple{T}, Tuple{AbstractGene,Symbol,T}} where T",
    "page": "Home",
    "title": "GenomicAnnotations.pushproperty!",
    "category": "method",
    "text": "pushproperty!(gene::AbstractGene, name::Symbol, x::T)\n\nAdd a property to gene, similarly to Base.setproperty!(::gene), but if the property is not missing in gene, it will be transformed to store a vector instead of overwriting existing data.\n\njulia> eltype(chr.genedata[:EC_number])\nUnion{Missing,String}\n\njulia> chr.genes[1].EC_number = \"EC:1.2.3.4\"\n\"EC:1.2.3.4\"\n\njulia> pushproperty!(chr.genes[1], :EC_number, \"EC:4.3.2.1\"); chr.genes[1].EC_number\n2-element Array{String,1}:\n \"EC:1.2.3.4\"\n \"EC:4.3.2.1\"\n\njulia> eltype(chr.genedata[:EC_number])\nUnion{Missing, Array{String,1}}\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.readgbk-Tuple{Any}",
    "page": "Home",
    "title": "GenomicAnnotations.readgbk",
    "category": "method",
    "text": "readgbk(filename)\n\nParse GenBank-formatted file filename, returning a Chromosome.\n\n\n\n\n\n"
},

{
    "location": "#Base.delete!-Tuple{AbstractArray{Gene,1}}",
    "page": "Home",
    "title": "Base.delete!",
    "category": "method",
    "text": "delete!(genes::AbstractArray{Gene, 1})\n\nDelete all genes in genes from genes[1].parent.\n\n\n\n\n\n"
},

{
    "location": "#Base.delete!-Tuple{Gene}",
    "page": "Home",
    "title": "Base.delete!",
    "category": "method",
    "text": "delete!(gene::Gene)\n\nDelete gene from gene.parent. Warning: does not work when broadcasted! Use delete!(::AbstractVector{Gene}) instead.\n\n\n\n\n\n"
},

{
    "location": "#Base.get-Tuple{Gene,Any,Any}",
    "page": "Home",
    "title": "Base.get",
    "category": "method",
    "text": "get(g::Gene, key, default)\n\nRetrieve key from g. If key is missing, return default.\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.filterseq-Tuple{Base.GenericIOBuffer{Array{UInt8,1}}}",
    "page": "Home",
    "title": "GenomicAnnotations.filterseq",
    "category": "method",
    "text": "Parse footer (sequence) portion of a GenBank file, returning a String. When BioSequences is available for 0.7 this will be changed to a DNASequence.\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.parsechromosome-Tuple{Any}",
    "page": "Home",
    "title": "GenomicAnnotations.parsechromosome",
    "category": "method",
    "text": "parsechromosome(lines)\n\nParse and return one chromosome entry, and the line number that it ends at.\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.parseposition-Tuple{String}",
    "page": "Home",
    "title": "GenomicAnnotations.parseposition",
    "category": "method",
    "text": "Parse lines encoding genomic position, returning the feature as a String, and an instance of Locus.\n\n\n\n\n\n"
},

{
    "location": "#GenomicAnnotations.vectorise-Union{Tuple{AbstractArray{Union{Missing, T},1}}, Tuple{T}} where T",
    "page": "Home",
    "title": "GenomicAnnotations.vectorise",
    "category": "method",
    "text": "vectorise(A::AbstractArray{Union{Missing, T}, 1}) where T\n\nConvert an array of type Vector{Union{Missing, T}} to Vector{Union{Missing, Vector{T}}}.\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [GenomicAnnotations]\nOrder = [:type, :function]"
},

]}
