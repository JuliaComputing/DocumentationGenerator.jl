<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · IJulia.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IJulia.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.installkernel-Tuple{AbstractString,Vararg{AbstractString,N} where N}" href="#IJulia.installkernel-Tuple{AbstractString,Vararg{AbstractString,N} where N}"><code>IJulia.installkernel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">installkernel(name::AbstractString, options::AbstractString...;
              specname::AbstractString,
              env=Dict())</code></pre><p>Install a new Julia kernel, where the given <code>options</code> are passed to the <code>julia</code> executable, the user-visible kernel name is given by <code>name</code> followed by the Julia version, and the <code>env</code> dictionary is added to the environment.</p><p>The new kernel name is returned by <code>installkernel</code>.  For example:</p><pre><code class="language-none">kernelpath = installkernel(&quot;Julia O3&quot;, &quot;-O3&quot;, env=Dict(&quot;FOO&quot;=&gt;&quot;yes&quot;))</code></pre><p>creates a new Julia kernel in which <code>julia</code> is launched with the <code>-O3</code> optimization flag and <code>FOO=yes</code> is included in the environment variables.</p><p>The returned <code>kernelpath</code> is the path of the installed kernel directory, something like <code>/...somepath.../kernels/julia-O3-1.0</code> (in Julia 1.0).  The <code>specname</code> argument can be passed to alter the name of this directory (which defaults to <code>name</code> with spaces replaced by hyphens).</p><p>You can uninstall the kernel by calling <code>rm(kernelpath, recursive=true)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.jupyterlab-Tuple{}" href="#IJulia.jupyterlab-Tuple{}"><code>IJulia.jupyterlab</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">jupyterlab(; dir=homedir(), detached=false)</code></pre><p>Similar to <code>IJulia.notebook()</code> but launches JupyterLab instead of the Jupyter notebook.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.notebook-Tuple{}" href="#IJulia.notebook-Tuple{}"><code>IJulia.notebook</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">notebook(; dir=homedir(), detached=false)</code></pre><p>The <code>notebook()</code> function launches the Jupyter notebook, and is equivalent to running <code>jupyter notebook</code> at the operating-system command-line.    The advantage of launching the notebook from Julia is that, depending on how Jupyter was installed, the user may not know where to find the <code>jupyter</code> executable.</p><p>By default, the notebook server is launched in the user&#39;s home directory, but this location can be changed by passing the desired path in the <code>dir</code> keyword argument.  e.g. <code>notebook(dir=pwd())</code> to use the current directory.</p><p>By default, <code>notebook()</code> does not return; you must hit ctrl-c or quit Julia to interrupt it, which halts Jupyter.  So, you must leave the Julia terminal open for as long as you want to run Jupyter.  Alternatively, if you run <code>notebook(detached=true)</code>, the <code>jupyter notebook</code> will launch in the background, and will continue running even after you quit Julia.  (The only way to stop Jupyter will then be to kill it in your operating system&#39;s process manager.)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.clear_history" href="#IJulia.clear_history"><code>IJulia.clear_history</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">clear_history([indices])</code></pre><p>The <code>clear_history()</code> function clears all of the input and output history stored in the running IJulia notebook.  This is sometimes useful because all cell outputs are remember in the <code>Out</code> global variable, which prevents them from being freed, so potentially this could waste a lot of memory in a notebook with many large outputs.</p><p>The optional <code>indices</code> argument is a collection of indices indicating a subset of cell inputs/outputs to clear.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.clear_output" href="#IJulia.clear_output"><code>IJulia.clear_output</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">clear_output(wait=false)</code></pre><p>Call <code>clear_output()</code> to clear visible output from the current notebook cell.  Using <code>wait=true</code> clears the output only when new output is available, which reduces flickering and is useful for simple animations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.display_dict-Tuple{Any}" href="#IJulia.display_dict-Tuple{Any}"><code>IJulia.display_dict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Generate a dictionary of <code>mime_type =&gt; data</code> pairs for all registered MIME types. This is the format that Jupyter expects in display<em>data and execute</em>result messages.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.display_mimejson-Tuple{Array{MIME,1},Any}" href="#IJulia.display_mimejson-Tuple{Array{MIME,1},Any}"><code>IJulia.display_mimejson</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Generate the preferred json-MIME representation of x.</p><p>Returns a tuple with the selected MIME type and the representation of the data using that MIME type (as a <code>JSONText</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.display_mimestring-Tuple{Array{MIME,1},Any}" href="#IJulia.display_mimestring-Tuple{Array{MIME,1},Any}"><code>IJulia.display_mimestring</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Generate the preferred MIME representation of x.</p><p>Returns a tuple with the selected MIME type and the representation of the data using that MIME type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.history" href="#IJulia.history"><code>IJulia.history</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">history([io], [indices...])</code></pre><p>The <code>history()</code> function prints all of the input history stored in the running IJulia notebook in a format convenient for copying.</p><p>The optional <code>indices</code> argument is one or more indices or collections of indices indicating a subset input cells to print.</p><p>The optional <code>io</code> argument is for specifying an output stream. The default is <code>stdout</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.load" href="#IJulia.load"><code>IJulia.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load(filename, replace=false)</code></pre><p>Load the file given by <code>filename</code> into a new input code cell in the running IJulia notebook, analogous to the <code>%load</code> magics in IPython. If the optional argument <code>replace</code> is <code>true</code>, then the file contents replace the <em>current</em> cell rather than creating a new cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.load_string" href="#IJulia.load_string"><code>IJulia.load_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">load_string(s, replace=false)</code></pre><p>Load the string <code>s</code> into a new input code cell in the running IJulia notebook, somewhat analogous to the <code>%load</code> magics in IPython. If the optional argument <code>replace</code> is <code>true</code>, then <code>s</code> replaces the <em>current</em> cell rather than creating a new cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.num_utf8_trailing-Tuple{Array{UInt8,1}}" href="#IJulia.num_utf8_trailing-Tuple{Array{UInt8,1}}"><code>IJulia.num_utf8_trailing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If <code>d</code> ends with an incomplete UTF8-encoded character, return the number of trailing incomplete bytes. Otherwise, return <code>0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.pop_posterror_hook-Tuple{Function}" href="#IJulia.pop_posterror_hook-Tuple{Function}"><code>IJulia.pop_posterror_hook</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pop_posterror_hook(f::Function)</code></pre><p>Remove a function <code>f()</code> from the list of functions to execute after an error occurs when a notebook cell is evaluated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.pop_postexecute_hook-Tuple{Function}" href="#IJulia.pop_postexecute_hook-Tuple{Function}"><code>IJulia.pop_postexecute_hook</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pop_postexecute_hook(f::Function)</code></pre><p>Remove a function <code>f()</code> from the list of functions to execute after executing any notebook cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.pop_preexecute_hook-Tuple{Function}" href="#IJulia.pop_preexecute_hook-Tuple{Function}"><code>IJulia.pop_preexecute_hook</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pop_preexecute_hook(f::Function)</code></pre><p>Remove a function <code>f()</code> from the list of functions to execute before executing any notebook cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.push_posterror_hook-Tuple{Function}" href="#IJulia.push_posterror_hook-Tuple{Function}"><code>IJulia.push_posterror_hook</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pop_posterror_hook(f::Function)</code></pre><p>Remove a function <code>f()</code> from the list of functions to execute after an error occurs when a notebook cell is evaluated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.push_postexecute_hook-Tuple{Function}" href="#IJulia.push_postexecute_hook-Tuple{Function}"><code>IJulia.push_postexecute_hook</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push_postexecute_hook(f::Function)</code></pre><p>Push a function <code>f()</code> onto the end of a list of functions to execute after executing any notebook cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.push_preexecute_hook-Tuple{Function}" href="#IJulia.push_preexecute_hook-Tuple{Function}"><code>IJulia.push_preexecute_hook</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push_preexecute_hook(f::Function)</code></pre><p>Push a function <code>f()</code> onto the end of a list of functions to execute before executing any notebook cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.readprompt-Tuple{AbstractString}" href="#IJulia.readprompt-Tuple{AbstractString}"><code>IJulia.readprompt</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">readprompt(prompt::AbstractString; password::Bool=false)</code></pre><p>Display the <code>prompt</code> string, request user input, and return the string entered by the user.  If <code>password</code> is <code>true</code>, the user&#39;s input is not displayed during typing.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.set_cur_msg-Tuple{Any}" href="#IJulia.set_cur_msg-Tuple{Any}"><code>IJulia.set_cur_msg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Jupyter associates cells with message headers. Once a cell&#39;s execution state has been set as to idle, it will silently drop stream messages (i.e. output to stdout and stderr) - see https://github.com/jupyter/notebook/issues/518. When using Interact, and a widget&#39;s state changes, a new message header is sent to the IJulia kernel, and while Reactive is updating Signal graph state, it&#39;s execution state is busy, meaning Jupyter will not drop stream messages if Interact can set the header message under which the stream messages will be sent. Hence the need for this function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.set_max_stdio-Tuple{Integer}" href="#IJulia.set_max_stdio-Tuple{Integer}"><code>IJulia.set_max_stdio</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_max_stdio(max_output::Integer)</code></pre><p>Sets the maximum number of bytes, <code>max_output</code>, that can be written to stdout and stderr before getting truncated. A large value here allows a lot of output to be displayed in the notebook, potentially bogging down the browser.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.set_verbose" href="#IJulia.set_verbose"><code>IJulia.set_verbose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_verbose(v=true)</code></pre><p>This function enables (or disables, for <code>set_verbose(false)</code>) verbose output from the IJulia kernel, when called within a running notebook. This consists of log messages printed to the terminal window where <code>jupyter</code> was launched, displaying information about every message sent or received by the kernel.   Used for debugging IJulia.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IJulia.watch_stream-Tuple{IO,AbstractString}" href="#IJulia.watch_stream-Tuple{IO,AbstractString}"><code>IJulia.watch_stream</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Continually read from (size limited) Libuv/OS buffer into an <code>IObuffer</code> to avoid problems when the Libuv/OS buffer gets full (https://github.com/JuliaLang/julia/issues/8789). Send data immediately when buffer contains more than <code>max_bytes</code> bytes. Otherwise, if data is available it will be sent every <code>stream_interval</code> seconds (see the Timers set up in watch<em>stdio). Truncate the output to `max</em>output<em>per</em>request` bytes per execution request since excessive output can bring browsers to a grinding halt.</p></div></div></section><footer><hr/></footer></article></body></html>
