var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#MotifSequenceGenerator-1",
    "page": "Readme",
    "title": "MotifSequenceGenerator",
    "category": "section",
    "text": "Documentation Travis AppVeyor\n(Image: ) (Image: Build Status) (Image: Build status)A julia module to generate random sequences of motifs, under the constrain that the sequence has some given total length."
},

{
    "location": "autodocs/#MotifSequenceGenerator.all_possible_sums-Union{Tuple{T}, Tuple{Array{T,1},Any}} where T",
    "page": "Docstrings",
    "title": "MotifSequenceGenerator.all_possible_sums",
    "category": "method",
    "text": "all_possible_sums(summands, n)\n\nCompute all possible sums from combining n elements from summands (with repetition), only using unique combinations.\n\nReturn a vector of tuples: the first entry of each tuple is the sum, while the second is the indices of summands used to compute the sum.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#MotifSequenceGenerator.random_sequence-Union{Tuple{M}, Tuple{Array{M,1},Any,Any,Any}, Tuple{Array{M,1},Any,Any,Any,Any}} where M",
    "page": "Docstrings",
    "title": "MotifSequenceGenerator.random_sequence",
    "category": "method",
    "text": "random_sequence(motifs::Vector{M}, q, limits, translate, δq = 0; kwargs...)\n\nCreate a random sequence of motifs of type M, under the constraint that the sequence has \"length\" ℓ exactly within q - δq ≤ ℓ ≤ q + δq. Return the sequence itself as well as the sequence of indices of motifs used to create it.\n\n\"length\" here means an abstracted length defined by the struct M, based on the limits and translate functions. It does not refer to the amount of elements!\n\nM can be anything, given the two functions\n\nlimits(motif) : Some function that given the motif it returns the (start, fine) of the the motif in the same units as q. This function establishes a measure of length, which simply is fine - start.\ntranslate(motif, t) : Some function that given the motif it returns a new motif which is translated by t (either negative or positive), with respect to the same units as q.\n\nKeywords\n\nPlease see the source code (use @which) for a full description of the algorithm.\n\ntries = 5 : Up to how many initial random sequences are accepted.\ntaulcut = 2 : Up to how times an element is dropped from the initial guess.\nsummands = 3 : Up to how many motifs may be combined as a sum to complete a sequence.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#MotifSequenceGenerator._motifs_at_origin-Union{Tuple{M}, Tuple{Array{M,1},Any,Any}} where M",
    "page": "Docstrings",
    "title": "MotifSequenceGenerator._motifs_at_origin",
    "category": "method",
    "text": "_motifs_at_origin(motifs, limits, translate) -> (motifs0, motiflens)\n\nBring all motifs to the origin and compute the motif lengths.\n\n\n\n\n\n"
},

{
    "location": "autodocs/#MotifSequenceGenerator._random_sequence_try-Tuple{Any,Any,Any}",
    "page": "Docstrings",
    "title": "MotifSequenceGenerator._random_sequence_try",
    "category": "method",
    "text": "_random_sequence_try(motiflens, q) -> seq, seq_length\n\nReturn a random sequence of motif indices so that the total sequence is guaranteed to have total length of q - δq ≤ ℓ ≤ q - δq + maximum(motiflens).\n\n\n\n\n\n"
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [MotifSequenceGenerator]\nOrder = [:type, :function]"
},

]}
