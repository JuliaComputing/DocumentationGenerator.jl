<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · MotifSequenceGenerator.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MotifSequenceGenerator.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MotifSequenceGenerator.all_possible_sums-Union{Tuple{T}, Tuple{Array{T,1},Any}} where T" href="#MotifSequenceGenerator.all_possible_sums-Union{Tuple{T}, Tuple{Array{T,1},Any}} where T"><code>MotifSequenceGenerator.all_possible_sums</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">all_possible_sums(summands, n)</code></pre><p>Compute all possible sums from combining <code>n</code> elements from <code>summands</code> (with repetition), only using unique combinations.</p><p>Return a vector of tuples: the first entry of each tuple is the sum, while the second is the indices of summands used to compute the sum.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MotifSequenceGenerator.random_sequence-Union{Tuple{M}, Tuple{Array{M,1},Any,Any,Any}, Tuple{Array{M,1},Any,Any,Any,Any}} where M" href="#MotifSequenceGenerator.random_sequence-Union{Tuple{M}, Tuple{Array{M,1},Any,Any,Any}, Tuple{Array{M,1},Any,Any,Any,Any}} where M"><code>MotifSequenceGenerator.random_sequence</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">random_sequence(motifs::Vector{M}, q, limits, translate, δq = 0; kwargs...)</code></pre><p>Create a random sequence of motifs of type <code>M</code>, under the constraint that the sequence has &quot;length&quot; <code>ℓ</code> <strong>exactly</strong> within <code>q - δq ≤ ℓ ≤ q + δq</code>. Return the sequence itself as well as the sequence of indices of <code>motifs</code> used to create it.</p><p>&quot;length&quot; here means an abstracted length defined by the struct <code>M</code>, based on the <code>limits</code> and <code>translate</code> functions. It does <strong>not</strong> refer to the amount of elements!</p><p><code>M</code> can be anything, given the two functions</p><ul><li><code>limits(motif)</code> : Some function that given the <code>motif</code> it returns the <code>(start, fine)</code> of the the motif in the same units as <code>q</code>. This function establishes a measure of length, which simply is <code>fine - start</code>.</li><li><code>translate(motif, t)</code> : Some function that given the <code>motif</code> it returns a <em>new</em> motif which is translated by <code>t</code> (either negative or positive), with respect to the same units as <code>q</code>.</li></ul><p><strong>Keywords</strong></p><p>Please see the source code (use <code>@which</code>) for a full description of the algorithm.</p><ul><li><code>tries = 5</code> : Up to how many initial random sequences are accepted.</li><li><code>taulcut = 2</code> : Up to how times an element is dropped from the initial guess.</li><li><code>summands = 3</code> : Up to how many motifs may be combined as a sum to complete a sequence.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MotifSequenceGenerator._motifs_at_origin-Union{Tuple{M}, Tuple{Array{M,1},Any,Any}} where M" href="#MotifSequenceGenerator._motifs_at_origin-Union{Tuple{M}, Tuple{Array{M,1},Any,Any}} where M"><code>MotifSequenceGenerator._motifs_at_origin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_motifs_at_origin(motifs, limits, translate) -&gt; (motifs0, motiflens)</code></pre><p>Bring all motifs to the origin and compute the motif lengths.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MotifSequenceGenerator._random_sequence_try-Tuple{Any,Any,Any}" href="#MotifSequenceGenerator._random_sequence_try-Tuple{Any,Any,Any}"><code>MotifSequenceGenerator._random_sequence_try</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_random_sequence_try(motiflens, q) -&gt; seq, seq_length</code></pre><p>Return a random sequence of motif indices so that the total sequence is <em>guaranteed</em> to have total length of <code>q - δq ≤ ℓ ≤ q - δq + maximum(motiflens)</code>.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
