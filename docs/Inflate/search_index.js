var documenterSearchIndex = {"docs": [

{
    "location": "#Inflate.InflateGzipStream",
    "page": "Home",
    "title": "Inflate.InflateGzipStream",
    "category": "type",
    "text": "InflateGzipStream(stream::IO)\n\nStreaming decompression of Gzip compressed stream. For an in-memory counterpart, see inflate_gzip.\n\ngzip_headers = Dict{String, Any}()\nInflateGzipStream(stream::IO; headers = gzip_headers)\n\nAlso retrieve gzip headers in the provided Dict. The headers are available directly after the object is constructed.\n\nInflateGzipStream(stream::IO; ignore_checksum = true)\n\nSkip computing CRC of the content, as well as the header, for consistency checking.\n\nReference: RFC 1952\n\n\n\n\n\n"
},

{
    "location": "#Inflate.InflateStream",
    "page": "Home",
    "title": "Inflate.InflateStream",
    "category": "type",
    "text": "InflateStream(stream::IO)\n\nStreaming decompression of unwrapped deflate compressed stream. For an in-memory counterpart, see inflate.\n\nReference: RFC 1951\n\n\n\n\n\n"
},

{
    "location": "#Inflate.InflateZlibStream",
    "page": "Home",
    "title": "Inflate.InflateZlibStream",
    "category": "type",
    "text": "InflateZlibStream(stream::IO)\n\nStreaming decompression of Zlib compressed stream. For an in-memory counterpart, see inflate_zlib.\n\nInflateZlibStream(stream::IO; ignore_checksum = true)\n\nSkip computing Adler checksum for consistency checking.\n\nReference: RFC 1950\n\n\n\n\n\n"
},

{
    "location": "#Inflate.inflate-Tuple{Array{UInt8,1}}",
    "page": "Home",
    "title": "Inflate.inflate",
    "category": "method",
    "text": "inflate(source::Vector{UInt8})\n\nDecompress in-memory source, in unwrapped deflate format. The output will also be a Vector{UInt8}. For a streaming counterpart, see InflateStream.\n\nReference: RFC 1951\n\n\n\n\n\n"
},

{
    "location": "#Inflate.inflate_gzip-Tuple{AbstractString}",
    "page": "Home",
    "title": "Inflate.inflate_gzip",
    "category": "method",
    "text": "inflate_gzip(filename::AbstractString)\n\nConvenience wrapper for reading a gzip compressed text file. The result is returned as a string.\n\n\n\n\n\n"
},

{
    "location": "#Inflate.inflate_gzip-Tuple{Array{UInt8,1}}",
    "page": "Home",
    "title": "Inflate.inflate_gzip",
    "category": "method",
    "text": "inflate_gzip(source::Vector{UInt8})\n\nDecompress in-memory source, in Gzip compressed format. The output will also be a Vector{UInt8}. For a streaming counterpart, see InflateGzipStream.\n\ngzip_headers = Dict{String, Any}()\ninflate_gzip(source::Vector{UInt8}; headers = gzip_headers)\n\nAlso retrieve gzip headers in the provided Dict.\n\ninflate_gzip(source::Vector{UInt8}; ignore_checksum = true)\n\nSkip computing CRC of the content, as well as the header, for consistency checking.\n\nReference: RFC 1952\n\n\n\n\n\n"
},

{
    "location": "#Inflate.inflate_zlib-Tuple{Array{UInt8,1}}",
    "page": "Home",
    "title": "Inflate.inflate_zlib",
    "category": "method",
    "text": "inflate_zlib(source::Vector{UInt8})\n\nDecompress in-memory source, in Zlib compressed format. The output will also be a Vector{UInt8}. For a streaming counterpart, see InflateZlibStream.\n\ninflate_zlib(source::Vector{UInt8}; ignore_checksum = true)\n\nSkip computing Adler checksum for consistency checking.\n\nReference: RFC 1950\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [Inflate]\nOrder = [:type, :function]"
},

]}
