var documenterSearchIndex = {"docs": [

{
    "location": "#AbstractLattices.:∧-Tuple{ClosedInterval,ClosedInterval}",
    "page": "Home",
    "title": "AbstractLattices.:∧",
    "category": "method",
    "text": "J ∧ K is the largest ClosedInterval contained in both. See also *.\n\n\n\n\n\n"
},

{
    "location": "#AbstractLattices.:∨-Tuple{ClosedInterval,ClosedInterval}",
    "page": "Home",
    "title": "AbstractLattices.:∨",
    "category": "method",
    "text": "J ∨ K is the smalles ClosedInterval containing both. See also +.\n\n\n\n\n\n"
},

{
    "location": "#ClosedIntervals.EmptyInterval",
    "page": "Home",
    "title": "ClosedIntervals.EmptyInterval",
    "category": "function",
    "text": "EmptyInterval(T::DataType = Float64) creates an empty ClosedInterval of a given type.\n\n\n\n\n\n"
},

{
    "location": "#ClosedIntervals.left-Tuple{ClosedInterval}",
    "page": "Home",
    "title": "ClosedIntervals.left",
    "category": "method",
    "text": "For a ClosedInterval I, left(I) returns its left end point.\n\n\n\n\n\n"
},

{
    "location": "#ClosedIntervals.right-Tuple{ClosedInterval}",
    "page": "Home",
    "title": "ClosedIntervals.right",
    "category": "method",
    "text": "For a ClosedInterval I, right(I) returns its right end point.\n\n\n\n\n\n"
},

{
    "location": "#Base.:*-Tuple{ClosedInterval,ClosedInterval}",
    "page": "Home",
    "title": "Base.:*",
    "category": "method",
    "text": "For ClosedIntervals J and K, J*K is their intersection. Also available as J ∧ K.\n\n\n\n\n\n"
},

{
    "location": "#Base.:+-Tuple{ClosedInterval,ClosedInterval}",
    "page": "Home",
    "title": "Base.:+",
    "category": "method",
    "text": "For ClosedIntervals J and K, J+K is the smallest ClosedInterval containing them both. This is also available as J ∨ K.\n\n\n\n\n\n"
},

{
    "location": "#Base.:<<-Tuple{ClosedInterval,ClosedInterval}",
    "page": "Home",
    "title": "Base.:<<",
    "category": "method",
    "text": "For ClosedIntervals I and J, I<<J tests if I is completely to the left of J.\n\n\n\n\n\n"
},

{
    "location": "#Base.:>>-Tuple{ClosedInterval,ClosedInterval}",
    "page": "Home",
    "title": "Base.:>>",
    "category": "method",
    "text": "For ClosedIntervals I and J, I>>J tests if I is completely to the right of J.\n\n\n\n\n\n"
},

{
    "location": "#Base.in-Tuple{Any,ClosedInterval}",
    "page": "Home",
    "title": "Base.in",
    "category": "method",
    "text": "For a number x and a ClosedInterval I (of the same type) in(x,I) tests if x is contained in the interval I.\n\n\n\n\n\n"
},

{
    "location": "#Base.isempty-Tuple{ClosedInterval}",
    "page": "Home",
    "title": "Base.isempty",
    "category": "method",
    "text": "For a ClosedInterval I, isempty(I) tests if I is an empty interval.\n\n\n\n\n\n"
},

{
    "location": "#Base.isless-Tuple{ClosedInterval,ClosedInterval}",
    "page": "Home",
    "title": "Base.isless",
    "category": "method",
    "text": "Lexicographic ordering of ClosedIntervals.\n\n\n\n\n\n"
},

{
    "location": "#Base.length-Union{Tuple{ClosedInterval{T}}, Tuple{T}} where T",
    "page": "Home",
    "title": "Base.length",
    "category": "method",
    "text": "length(I) is the length of the ClosedInterval I.\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [ClosedIntervals]\nOrder = [:type, :function]"
},

]}
