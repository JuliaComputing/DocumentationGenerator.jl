<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Clang.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Clang.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li class="current"><a class="toctext" href>API Reference</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Reference</a></li></ul></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.address_space-Tuple{Clang.LibClang.CXType}" href="#Clang.address_space-Tuple{Clang.LibClang.CXType}"><code>Clang.address_space</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">address_space(t::CXType)
address_space(t::CLType)</code></pre><p>Returns the address space of the given type. Wrapper for libclang&#39;s <code>clang_getAddressSpace</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.annotate-Tuple{Ptr{Nothing},Any,Any,Any}" href="#Clang.annotate-Tuple{Ptr{Nothing},Any,Any,Any}"><code>Clang.annotate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">annotate(tu::TranslationUnit, tokens, token_num, cursors)
annotate(tu::CXTranslationUnit, tokens, token_num, cursors)</code></pre><p>Annotate the given set of tokens by providing cursors for each token that can be mapped to a specific entity within the abstract syntax tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.argnum-Tuple{Clang.LibClang.CXCursor}" href="#Clang.argnum-Tuple{Clang.LibClang.CXCursor}"><code>Clang.argnum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">argnum(c::CXCursor) -&gt; Int
argnum(c::CLCXXMethod) -&gt; Int
argnum(c::CLFunctionDecl) -&gt; Int</code></pre><p>Return the number of non-variadic arguments associated with a given cursor. Wrapper for libclang&#39;s <code>clang_Cursor_getNumArguments</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.argnum-Tuple{Clang.LibClang.CXType}" href="#Clang.argnum-Tuple{Clang.LibClang.CXType}"><code>Clang.argnum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">argnum(t::CXType) -&gt; Int
argnum(t::CLFunctionProto) -&gt; Int
argnum(t::CLFunctionNoProto) -&gt; Int</code></pre><p>Return the number of non-variadic parameters associated with a function type. Wrapper for libclang&#39;s <code>clang_getNumArgTypes</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.argtype-Tuple{Clang.LibClang.CXType,Unsigned}" href="#Clang.argtype-Tuple{Clang.LibClang.CXType,Unsigned}"><code>Clang.argtype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">argtype(t::CXType, i::Unsigned) -&gt; CXType
argtype(t::CLFunctionProto, i::Integer) -&gt; CLType
argtype(t::CLFunctionNoProto, i::Integer) -&gt; CLType</code></pre><p>Return the type of a parameter of a function type. Wrapper for libclang&#39;s <code>clang_getArgType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.argument-Tuple{Clang.LibClang.CXCursor,Unsigned}" href="#Clang.argument-Tuple{Clang.LibClang.CXCursor,Unsigned}"><code>Clang.argument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">argument(c::CXCursor, i::Unsigned) -&gt; CXCursor
argument(c::CLFunctionDecl, i::Integer) -&gt; CLCursor
argument(c::CLCXXMethod, i::Integer) -&gt; CLCursor</code></pre><p>Return the argument cursor of a function or method. Wrapper for libclang&#39;s <code>clang_Cursor_getArgument</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.bitwidth-Tuple{Clang.LibClang.CXCursor}" href="#Clang.bitwidth-Tuple{Clang.LibClang.CXCursor}"><code>Clang.bitwidth</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">bitwidth(c::CLFieldDecl) -&gt; Int</code></pre><p>Return the bit width of a bit field declaration as an integer. Wrapper for libclang&#39;s <code>clang_getFieldDeclBitWidth</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.canonical-Tuple{Clang.LibClang.CXCursor}" href="#Clang.canonical-Tuple{Clang.LibClang.CXCursor}"><code>Clang.canonical</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">canonical(c::CXCursor) -&gt; CXCursor
canonical(c::CLCursor) -&gt; CLCursor</code></pre><p>Return the canonical cursor corresponding to the given cursor. Wrapper for libclang&#39;s <code>clang_getCanonicalCursor</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.canonical-Tuple{Clang.LibClang.CXType}" href="#Clang.canonical-Tuple{Clang.LibClang.CXType}"><code>Clang.canonical</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">canonical(t::CXType) -&gt; CXType
canonical(t::CLType) -&gt; CLType</code></pre><p>Return the canonical type for a CXType.</p><p>Clang&#39;s type system explicitly models typedefs and all the ways a specific type can be represented. The canonical type is the underlying type with all the &quot;sugar&quot; removed. For example, if &#39;T&#39; is a typedef for &#39;int&#39;, the canonical type for &#39;T&#39; would be &#39;int&#39;. Wrapper for libclang&#39;s <code>clang_getCanonicalType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.children-Tuple{Clang.LibClang.CXCursor}" href="#Clang.children-Tuple{Clang.LibClang.CXCursor}"><code>Clang.children</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">children(cursor::CXCursor) -&gt; Vector{CXCursor}
children(cursor::CLCursor) -&gt; Vector{CLCursor}</code></pre><p>Return a child cursor vector of the given cursor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.clang2julia-Tuple{CLCursor}" href="#Clang.clang2julia-Tuple{CLCursor}"><code>Clang.clang2julia</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">clang2julia(c::CLCursor) -&gt; Symbol/Expr</code></pre><p>Convert libclang cursor/type to Julia.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.clang2julia-Tuple{CLType}" href="#Clang.clang2julia-Tuple{CLType}"><code>Clang.clang2julia</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">clang2julia(t::CLType) -&gt; Symbol/Expr</code></pre><p>Convert libclang cursor/type to Julia.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.copydeps-Tuple{Any}" href="#Clang.copydeps-Tuple{Any}"><code>Clang.copydeps</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">copydeps(dst)</code></pre><p>Copy dependencies to <code>dst</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.element_num-Tuple{Clang.LibClang.CXType}" href="#Clang.element_num-Tuple{Clang.LibClang.CXType}"><code>Clang.element_num</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">element_num(t::CXType) -&gt; Int
element_num(t::CLVector) -&gt; Int
element_num(t::CLConstantArray) -&gt; Int
element_num(t::CLIncompleteArray) -&gt; Int
element_num(t::CLVariableArray) -&gt; Int
element_num(t::CLDependentSizedArray) -&gt; Int</code></pre><p>Return the number of elements of an array or vector type. Wrapper for libclang&#39;s <code>clang_getNumElements</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.element_type-Tuple{Clang.LibClang.CXType}" href="#Clang.element_type-Tuple{Clang.LibClang.CXType}"><code>Clang.element_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">element_type(t::CXType) -&gt; CXType
element_type(t::CLVector) -&gt; CLType
element_type(t::CLConstantArray) -&gt; CLType
element_type(t::CLIncompleteArray) -&gt; CLType
element_type(t::CLVariableArray) -&gt; CLType
element_type(t::CLDependentSizedArray) -&gt; CLType
element_type(t::CLComplex) -&gt; CLType</code></pre><p>Return the element type of an array, complex, or vector type. Wrapper for libclang&#39;s <code>clang_getElementType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.extent-Tuple{Clang.LibClang.CXCursor}" href="#Clang.extent-Tuple{Clang.LibClang.CXCursor}"><code>Clang.extent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extent(c::CXCursor) -&gt; CXSourceRange
extent(c::CLCursor) -&gt; CXSourceRange</code></pre><p>Return the physical extent of the source construct referenced by the given cursor.</p><p>The extent of a cursor starts with the file/line/column pointing at the first character within the source construct that the cursor refers to and ends with the last character within that source construct. For a declaration, the extent covers the declaration itself. For a reference, the extent covers the location of the reference (e.g., where the referenced entity was actually used). Wrapper for libclang&#39;s <code>clang_getCursorExtent</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.extent-Tuple{Ptr{Nothing},Clang.LibClang.CXToken}" href="#Clang.extent-Tuple{Ptr{Nothing},Clang.LibClang.CXToken}"><code>Clang.extent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extent(tu::TranslationUnit, t::CLToken) -&gt; CXSourceRange
extent(tu::TranslationUnit, t::CXToken) -&gt; CXSourceRange
extent(tu::CXTranslationUnit, t::CXToken) -&gt; CXSourceRange</code></pre><p>Return a source range that covers the given token.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.filename-Tuple{Clang.LibClang.CXCursor}" href="#Clang.filename-Tuple{Clang.LibClang.CXCursor}"><code>Clang.filename</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">filename(c::CXCursor) -&gt; String
filename(c::CLCursor) -&gt; String</code></pre><p>Return the complete file and path name of the given file referenced by the input cursor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.function_args-Tuple{CLCursor}" href="#Clang.function_args-Tuple{CLCursor}"><code>Clang.function_args</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function_args(cursor::CLCursor) -&gt; Vector{CLCursor}</code></pre><p>Return function arguments for a given cursor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.get_included_file-Tuple{Clang.LibClang.CXCursor}" href="#Clang.get_included_file-Tuple{Clang.LibClang.CXCursor}"><code>Clang.get_included_file</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_included_file(c::CXCursor) -&gt; CXFile
get_included_file(c::CLCursor) -&gt; CXFile</code></pre><p>Return the file that is included by the given inclusion directive cursor. Wrapper for libclang&#39;s <code>clang_getIncludedFile</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.get_lexical_parent-Tuple{Clang.LibClang.CXCursor}" href="#Clang.get_lexical_parent-Tuple{Clang.LibClang.CXCursor}"><code>Clang.get_lexical_parent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_lexical_parent(c::CXCursor) -&gt; CXCursor
get_lexical_parent(c::CLCursor) -&gt; CLCursor</code></pre><p>Return the lexical parent of the given cursor. Please checkout libclang&#39;s doc to know more. Wrapper for libclang&#39;s <code>clang_getCursorLexicalParent</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.get_named_type-Tuple{Clang.LibClang.CXType}" href="#Clang.get_named_type-Tuple{Clang.LibClang.CXType}"><code>Clang.get_named_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_named_type(t::CXType) -&gt; CXType
get_named_type(t::CLElaborated) -&gt; CLType</code></pre><p>Return the type named by the qualified-id. Wrapper for libclang&#39;s <code>clang_Type_getNamedType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.get_semantic_parent-Tuple{Clang.LibClang.CXCursor}" href="#Clang.get_semantic_parent-Tuple{Clang.LibClang.CXCursor}"><code>Clang.get_semantic_parent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_semantic_parent(c::CXCursor) -&gt; CXCursor
get_semantic_parent(c::CLCursor) -&gt; CLCursor</code></pre><p>Return the semantic parent of the given cursor. Please checkout libclang&#39;s doc to know more. Wrapper for libclang&#39;s <code>clang_getCursorSemanticParent</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.get_translation_unit-Tuple{Clang.LibClang.CXCursor}" href="#Clang.get_translation_unit-Tuple{Clang.LibClang.CXCursor}"><code>Clang.get_translation_unit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_translation_unit(c::CXCursor) -&gt; CXTranslationUnit
get_translation_unit(c::CLCursor) -&gt; CXTranslationUnit</code></pre><p>Returns the translation unit that a cursor originated from. Wrapper for libclang&#39;s <code>clang_Cursor_getTranslationUnit</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.getcursor-Tuple{Ptr{Nothing}}" href="#Clang.getcursor-Tuple{Ptr{Nothing}}"><code>Clang.getcursor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getcursor(tu::TranslationUnit) -&gt; CXCursor
getcursor(tu::CXTranslationUnit) -&gt; CLCursor</code></pre><p>Return the cursor that represents the given translation unit.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.getcursor-Tuple{}" href="#Clang.getcursor-Tuple{}"><code>Clang.getcursor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getcursor() -&gt; (NULL)CXCursor</code></pre><p>Return the NULL CXCursor. Wrapper for libclang&#39;s <code>clang_getNullCursor</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.getdef-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getdef-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getdef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getdef(c::CXCursor) -&gt; CXCursor
getdef(c::CLCursor) -&gt; CLCursor</code></pre><p>For a cursor that is either a reference to or a declaration of some entity, retrieve a cursor that describes the definition of that entity. Wrapper for libclang&#39;s <code>clang_getCursorDefinition</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.getref-Tuple{Clang.LibClang.CXCursor}" href="#Clang.getref-Tuple{Clang.LibClang.CXCursor}"><code>Clang.getref</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getref(c::CXCursor) -&gt; CXCursor
getref(c::CLCursor) -&gt; CLCursor</code></pre><p>For a cursor that is a reference, retrieve a cursor representing the entity that it references. Wrapper for libclang&#39;s <code>clang_getCursorReferenced</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.hasattr-Tuple{Clang.LibClang.CXCursor}" href="#Clang.hasattr-Tuple{Clang.LibClang.CXCursor}"><code>Clang.hasattr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hasattr(c::CXCursor) -&gt; Bool
hasattr(c::CLCursor) -&gt; Bool</code></pre><p>Determine whether the given cursor has any attributes. Wrapper for libclang&#39;s <code>clang_Cursor_hasAttrs</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.integer_type-Tuple{Clang.LibClang.CXCursor}" href="#Clang.integer_type-Tuple{Clang.LibClang.CXCursor}"><code>Clang.integer_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">integer_type(c::CLEnumDecl) -&gt; CLType</code></pre><p>Retrieve the integer type of an enum declaration. Wrapper for libclang&#39;s <code>clang_getEnumDeclIntegerType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.is_plain_old_data-Tuple{Clang.LibClang.CXType}" href="#Clang.is_plain_old_data-Tuple{Clang.LibClang.CXType}"><code>Clang.is_plain_old_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_plain_old_data(t::CXType) -&gt; Bool
is_plain_old_data(t::CLType) -&gt; Bool</code></pre><p>Return true if the CXType is a plain old data type. Wrapper for libclang&#39;s <code>clang_isPODType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.is_translation_unit-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.is_translation_unit-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.is_translation_unit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_translation_unit(k::CXcursorKind) -&gt; Bool
is_translation_unit(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a translation unit. Wrapper for libclang&#39;s <code>clang_isTranslationUnit</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.is_typedef_anon-Tuple{CLCursor,CLCursor}" href="#Clang.is_typedef_anon-Tuple{CLCursor,CLCursor}"><code>Clang.is_typedef_anon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">is_typedef_anon(current::CLCursor, next::CLCursor) -&gt; Bool</code></pre><p>Return true if the current cursor is an typedef anonymous struct/enum.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isattr-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isattr-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isattr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isattr(k::CXcursorKind) -&gt; Bool
isattr(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents an attribute. Wrapper for libclang&#39;s <code>clang_isAttribute</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isbit-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isbit-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isbit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isbit(c::CXCursor) -&gt; Bool
isbit(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the cursor specifies a Record member that is a bitfield. Wrapper for libclang&#39;s <code>clang_Cursor_isBitField</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isbuiltin-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isbuiltin-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isbuiltin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isbuiltin(c::CXCursor) -&gt; Bool
isbuiltin(c::CLCursor) -&gt; Bool</code></pre><p>Determine whether a  CXCursor that is a macro, is a builtin one. Wrapper for libclang&#39;s <code>clang_Cursor_isMacroBuiltin</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isdecl-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isdecl-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isdecl</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isdecl(k::CXcursorKind) -&gt; Bool
isdecl(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a declaration. Wrapper for libclang&#39;s <code>clang_isDeclaration</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isdef-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isdef-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isdef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isdef(c::CXCursor) -&gt; Bool
isdef(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the declaration pointed to by this cursor is also a definition of that entity. Wrapper for libclang&#39;s <code>clang_isCursorDefinition</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isexpr-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isexpr-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isexpr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isexpr(k::CXcursorKind) -&gt; Bool
isexpr(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents an expression. Wrapper for libclang&#39;s <code>clang_isExpression</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isfunctionlike-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isfunctionlike-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isfunctionlike</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isfunctionlike(c::CXCursor) -&gt; Bool
isfunctionlike(c::CLCursor) -&gt; Bool</code></pre><p>Determine whether a CXCursor that is a macro, is function like. Wrapper for libclang&#39;s <code>clang_Cursor_isMacroFunctionLike</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isinlined-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isinlined-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isinlined</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isinlined(c::CXCursor) -&gt; Bool
isinlined(c::CLCursor) -&gt; Bool</code></pre><p>Determine whether a CXCursor that is a function declaration, is an inline declaration. Wrapper for libclang&#39;s <code>clang_Cursor_isFunctionInlined</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isnull-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isnull-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isnull</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isnull(c::CXCursor) -&gt; Bool
isnull(c::CLCursor) -&gt; Bool</code></pre><p>Return true if cursor is null. Wrapper for libclang&#39;s <code>clang_Cursor_isNull</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.ispreprocessing-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.ispreprocessing-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.ispreprocessing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ispreprocessing(k::CXcursorKind) -&gt; Bool
ispreprocessing(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a preprocessing element, such as a preprocessor directive or macro instantiation. Wrapper for libclang&#39;s <code>clang_isPreprocessing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isref-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isref-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isref</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isref(k::CXcursorKind) -&gt; Bool
isref(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a simple reference. Note that other kinds of cursors (such as expressions) can also refer to other cursors. Use <a href="#Clang.getref-Tuple{Clang.LibClang.CXCursor}"><code>getref</code></a> to determine whether a particular cursor refers to another entity. Wrapper for libclang&#39;s <code>clang_isReference</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isrestrict-Tuple{Clang.LibClang.CXType}" href="#Clang.isrestrict-Tuple{Clang.LibClang.CXType}"><code>Clang.isrestrict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isrestrict(t::CXType) -&gt; Bool
isrestrict(t::CLType) -&gt; Bool</code></pre><p>Determine whether a CXType has the &quot;restrict&quot; qualifier set, without looking through typedefs that may have added &quot;restrict&quot; at a different level. Wrapper for libclang&#39;s <code>clang_isRestrictQualifiedType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isstmt-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isstmt-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isstmt</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isstmt(k::CXcursorKind) -&gt; Bool
isstmt(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a statement. Wrapper for libclang&#39;s <code>clang_isStatement</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isunexposed-Tuple{Clang.LibClang.CXCursorKind}" href="#Clang.isunexposed-Tuple{Clang.LibClang.CXCursorKind}"><code>Clang.isunexposed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isunexposed(k::CXcursorKind) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents a currently unexposed piece of the AST (e.g., CXCursor<em>UnexposedStmt). Wrapper for libclang&#39;s `clang</em>isUnexposed`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isvariadic-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isvariadic-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isvariadic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvariadic(c::CXCursor) -&gt; Bool
isvariadic(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor is a variadic function or method. Wrapper for libclang&#39;s <code>clang_Cursor_isVariadic</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isvariadic-Tuple{Clang.LibClang.CXType}" href="#Clang.isvariadic-Tuple{Clang.LibClang.CXType}"><code>Clang.isvariadic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvariadic(t::CXType) -&gt; Bool
isvariadic(t::CLType) -&gt; Bool</code></pre><p>Return true if the CXType is a variadic function type. Wrapper for libclang&#39;s <code>clang_isFunctionTypeVariadic</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isvolatile-Tuple{Clang.LibClang.CXType}" href="#Clang.isvolatile-Tuple{Clang.LibClang.CXType}"><code>Clang.isvolatile</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvolatile(t::CXType) -&gt; Bool
isvolatile(t::CLType) -&gt; Bool</code></pre><p>Determine whether a CXType has the &quot;volatile&quot; qualifier set, without looking through typedefs that may have added &quot;volatile&quot; at a different level. Wrapper for libclang&#39;s <code>clang_isVolatileQualifiedType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.kind-Tuple{CLCursor}" href="#Clang.kind-Tuple{CLCursor}"><code>Clang.kind</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">kind(c::CLCursor) -&gt; CXCursorKind</code></pre><p>Return the kind of the given cursor. Note this method directly reads CXCursor&#39;s <code>kind</code> field, which won&#39;t invoke additional <code>clang_getCursorKind</code> function calls.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.kind-Tuple{Clang.LibClang.CXCursor}" href="#Clang.kind-Tuple{Clang.LibClang.CXCursor}"><code>Clang.kind</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">kind(c::CXCursor) -&gt; CXCursorKind</code></pre><p>Return the kind of the given cursor. Wrapper for libclang&#39;s <code>clang_getCursorKind</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.kind-Tuple{Clang.LibClang.CXToken}" href="#Clang.kind-Tuple{Clang.LibClang.CXToken}"><code>Clang.kind</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">kind(t::CXToken) -&gt; CXTokenKind
kind(t::CLToken) -&gt; CXTokenKind</code></pre><p>Return the kind of the given token.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.kind-Tuple{Clang.LibClang.CXType}" href="#Clang.kind-Tuple{Clang.LibClang.CXType}"><code>Clang.kind</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">kind(t::CXType) -&gt; CXTypeKind
kind(t::CLType) -&gt; CXTypeKind</code></pre><p>Return the kind of the given type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.location-Tuple{Clang.LibClang.CXCursor}" href="#Clang.location-Tuple{Clang.LibClang.CXCursor}"><code>Clang.location</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">location(c::CXCursor) -&gt; CXSourceLocation
location(c::CLCursor) -&gt; CXSourceLocation</code></pre><p>Return the physical location of the source constructor referenced by the given cursor. Wrapper for libclang&#39;s <code>clang_getCursorLocation</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.location-Tuple{Ptr{Nothing},Clang.LibClang.CXToken}" href="#Clang.location-Tuple{Ptr{Nothing},Clang.LibClang.CXToken}"><code>Clang.location</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">location(tu::TranslationUnit, t::CLToken) -&gt; CXSourceLocation
location(tu::TranslationUnit, t::CXToken) -&gt; CXSourceLocation
location(tu::CXTranslationUnit, t::CXToken) -&gt; CXSourceLocation</code></pre><p>Return the source location of the given token.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.name-Tuple{Clang.LibClang.CXCursor}" href="#Clang.name-Tuple{Clang.LibClang.CXCursor}"><code>Clang.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">name(c::CXCursor) -&gt; String
name(c::CLCursor) -&gt; String</code></pre><p>Return the display name for the entity referenced by this cursor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.name_safe-Tuple{AbstractString}" href="#Clang.name_safe-Tuple{AbstractString}"><code>Clang.name_safe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">name_safe(name::AbstractString)</code></pre><p>Return a valid Julia variable name, prefixed with &quot;_&quot; if the <code>name</code> is conflict with Julia&#39;s reserved words.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.parse_header-Tuple{AbstractString}" href="#Clang.parse_header-Tuple{AbstractString}"><code>Clang.parse_header</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">parse_header(header::AbstractString; index::Index=Index(), args::Vector{String}=String[],
             includes::Vector{String}=String[], flags=CXTranslationUnit_None) -&gt; TranslationUnit</code></pre><p>Return the TranslationUnit for a given header. This is the main entry point for parsing. See also <a href="#Clang.parse_headers-Tuple{Array{String,1}}"><code>parse_headers</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>header::AbstractString</code>: the header file to parse.</li><li><code>index::Index</code>: CXIndex pointer (pass to avoid re-allocation).</li><li><code>args::Vector{String}</code>: compiler switches as string array, eg: [&quot;-x&quot;, &quot;c++&quot;, &quot;-fno-elide-type&quot;].</li><li><code>includes::Vector{String}</code>: vector of extra include directories to search.</li><li><code>flags</code>: bitwise OR of CXTranslationUnit_Flags.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.parse_headers-Tuple{Array{String,1}}" href="#Clang.parse_headers-Tuple{Array{String,1}}"><code>Clang.parse_headers</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">parse_headers(headers::Vector{String}; index::Index=Index(), args::Vector{String}=String[], includes::Vector{String}=String[],
    flags = CXTranslationUnit_DetailedPreprocessingRecord | CXTranslationUnit_SkipFunctionBodies) -&gt; Dict</code></pre><p>Return a TranslationUnit Dict for the given headers. See also <a href="#Clang.parse_header-Tuple{AbstractString}"><code>parse_header</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.pointee_type-Tuple{Clang.LibClang.CXType}" href="#Clang.pointee_type-Tuple{Clang.LibClang.CXType}"><code>Clang.pointee_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pointee_type(t::CXType) -&gt; CXType
pointee_type(t::CLType) -&gt; CLType</code></pre><p>Return the type of the pointee for pointer types. Wrapper for libclang&#39;s <code>clang_getPointeeType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.print_buffer-Tuple{Any,Any}" href="#Clang.print_buffer-Tuple{Any,Any}"><code>Clang.print_buffer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Pretty-print a buffer of expressions (and comments) to an output stream Adds blank lines at appropriate places for readability</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.resolve_type-Tuple{CLType}" href="#Clang.resolve_type-Tuple{CLType}"><code>Clang.resolve_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">resolve_type(t::CLType) -&gt; CLType</code></pre><p>This function attempts to work around some limitations of the current libclang API.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.result_type-Tuple{Clang.LibClang.CXCursor}" href="#Clang.result_type-Tuple{Clang.LibClang.CXCursor}"><code>Clang.result_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">result_type(c::CXCursor) -&gt; CXType
result_type(c::CLFunctionDecl) -&gt; CLType
result_type(c::CLCXXMethod) -&gt; CLType</code></pre><p>Return the return type associated with a given cursor. This only returns a valid type if the cursor refers to a function or method. Wrapper for libclang&#39;s <code>clang_getCursorResultType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.result_type-Tuple{Clang.LibClang.CXType}" href="#Clang.result_type-Tuple{Clang.LibClang.CXType}"><code>Clang.result_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">result_type(t::CXType) -&gt; CXType
result_type(t::CLFunctionProto) -&gt; CLType
result_type(t::CLFunctionNoProto) -&gt; CLType</code></pre><p>Return the return type associated with a function type. Wrapper for libclang&#39;s <code>clang_getResultType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.return_type" href="#Clang.return_type"><code>Clang.return_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">return_type(c::CLCursor, resolve::Bool=true) -&gt; CXtype</code></pre><p>Return the return type associated with a function/method cursor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.search-Tuple{Array{CLCursor,1},Function}" href="#Clang.search-Tuple{Array{CLCursor,1},Function}"><code>Clang.search</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">search(cursors::Vector{CLCursor}, ismatch::Function) -&gt; Vector{CLCursor}</code></pre><p>Return vector of CLCursors that match predicate. <code>ismatch</code> is a function that accepts a CLCursor argument.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.spelling-Tuple{Clang.LibClang.CXCursor}" href="#Clang.spelling-Tuple{Clang.LibClang.CXCursor}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">spelling(c::CXCursor) -&gt; String
spelling(c::CLCursor) -&gt; String</code></pre><p>Return a name for the entity referenced by this cursor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.spelling-Tuple{Clang.LibClang.CXTypeKind}" href="#Clang.spelling-Tuple{Clang.LibClang.CXTypeKind}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">spelling(kind::CXTypeKind) -&gt; String</code></pre><p>Return the spelling of a given CXTypeKind.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.spelling-Tuple{Clang.LibClang.CXType}" href="#Clang.spelling-Tuple{Clang.LibClang.CXType}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">spelling(t::CXType) -&gt; String
spelling(t::CLType) -&gt; String</code></pre><p>Pretty-print the underlying type using the rules of the language of the translation unit from which it came. If the type is invalid, an empty string is returned. Wrapper for libclang&#39;s <code>clang_getTypeSpelling</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.spelling-Tuple{Ptr{Nothing},Clang.LibClang.CXToken}" href="#Clang.spelling-Tuple{Ptr{Nothing},Clang.LibClang.CXToken}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">spelling(tu::TranslationUnit, t::CLToken) -&gt; String
spelling(tu::TranslationUnit, t::CXToken) -&gt; String
spelling(tu::CXTranslationUnit, t::CXToken) -&gt; String</code></pre><p>Return the spelling of the given token. The spelling of a token is the textual representation of that token, e.g., the text of an identifier or keyword.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.spelling-Tuple{TranslationUnit}" href="#Clang.spelling-Tuple{TranslationUnit}"><code>Clang.spelling</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">spelling(tu::TranslationUnit) -&gt; String</code></pre><p>Return the original translation unit source file name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.symbol_safe-Tuple{AbstractString}" href="#Clang.symbol_safe-Tuple{AbstractString}"><code>Clang.symbol_safe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symbol_safe(name::AbstractString)</code></pre><p>Same as <a href="#Clang.name_safe-Tuple{AbstractString}"><code>name_safe</code></a>, but return a Symbol.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.tokenize-Tuple{Clang.LibClang.CXCursor}" href="#Clang.tokenize-Tuple{Clang.LibClang.CXCursor}"><code>Clang.tokenize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tokenize(c::CXCursor) -&gt; TokenList
tokenize(c::CLCursor) -&gt; TokenList</code></pre><p>Return a TokenList from the given cursor.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.type-Tuple{Clang.LibClang.CXCursor}" href="#Clang.type-Tuple{Clang.LibClang.CXCursor}"><code>Clang.type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">type(c::CXCursor) -&gt; CXType
type(c::CLCursor) -&gt; CLType</code></pre><p>Return the type of a CXCursor (if any). To get the cursor from a type, see <a href="#Clang.typedecl-Tuple{Clang.LibClang.CXType}"><code>typedecl</code></a>. Wrapper for libclang&#39;s <code>clang_getCursorType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.typedecl-Tuple{Clang.LibClang.CXType}" href="#Clang.typedecl-Tuple{Clang.LibClang.CXType}"><code>Clang.typedecl</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">typedecl(t::CXType) -&gt; CXCursor
typedecl(t::CLType) -&gt; CLCursor</code></pre><p>Return the cursor for the declaration of the given type. To get the type of the cursor, see <a href="#Clang.type-Tuple{Clang.LibClang.CXCursor}"><code>type</code></a>. Wrapper for libclang&#39;s <code>clang_getTypeDeclaration</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.typedef_name-Tuple{Clang.LibClang.CXType}" href="#Clang.typedef_name-Tuple{Clang.LibClang.CXType}"><code>Clang.typedef_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">typedef_name(t::CXType) -&gt; String
typedef_name(t::CLType) -&gt; String</code></pre><p>Return the typedef name of the given type. Wrapper for libclang&#39;s <code>clang_getTypedefName</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.typedef_type-Tuple{CLCursor}" href="#Clang.typedef_type-Tuple{CLCursor}"><code>Clang.typedef_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">typedef_type(c::CLCursor) -&gt; CXType</code></pre><p>Return the underlying type of a typedef declaration.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.typesize-Tuple{CLType}" href="#Clang.typesize-Tuple{CLType}"><code>Clang.typesize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">typesize(t::CLType) -&gt; Int
typesize(c::CLCursor) -&gt; Int</code></pre><p>Return field declaration size.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.underlying_type-Tuple{Clang.LibClang.CXCursor}" href="#Clang.underlying_type-Tuple{Clang.LibClang.CXCursor}"><code>Clang.underlying_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">underlying_type(c::CLTypedefDecl) -&gt; CLType</code></pre><p>Return the underlying type of a typedef declaration. Wrapper for libclang&#39;s <code>clang_getTypedefDeclUnderlyingType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.value-Tuple{CLEnumConstantDecl}" href="#Clang.value-Tuple{CLEnumConstantDecl}"><code>Clang.value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">value(c::CLCursor) -&gt; Int</code></pre><p>Return the integer value of an enum constant declaration.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.wrap!-Tuple{AbstractContext,CLEnumDecl}" href="#Clang.wrap!-Tuple{AbstractContext,CLEnumDecl}"><code>Clang.wrap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wrap!(ctx::AbstractContext, cursor::CLEnumDecl)</code></pre><p>Subroutine for handling enum declarations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.wrap!-Tuple{AbstractContext,CLFunctionDecl}" href="#Clang.wrap!-Tuple{AbstractContext,CLFunctionDecl}"><code>Clang.wrap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wrap!(ctx::AbstractContext, cursor::CLFunctionDecl)</code></pre><p>Subroutine for handling function declarations. Note that VarArg functions are not supported.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.wrap!-Tuple{AbstractContext,CLMacroDefinition}" href="#Clang.wrap!-Tuple{AbstractContext,CLMacroDefinition}"><code>Clang.wrap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wrap!(ctx::AbstractContext, cursor::CLMacroDefinition)</code></pre><p>Subroutine for handling macro declarations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.wrap!-Tuple{AbstractContext,CLStructDecl}" href="#Clang.wrap!-Tuple{AbstractContext,CLStructDecl}"><code>Clang.wrap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wrap!(ctx::AbstractContext, cursor::CLStructDecl)</code></pre><p>Subroutine for handling struct declarations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.wrap!-Tuple{AbstractContext,CLTypeRef}" href="#Clang.wrap!-Tuple{AbstractContext,CLTypeRef}"><code>Clang.wrap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wrap!(ctx::AbstractContext, cursor::CLTypeRef)</code></pre><p>For now, we just skip CXCursor_TypeRef cursors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.wrap!-Tuple{AbstractContext,CLTypedefDecl}" href="#Clang.wrap!-Tuple{AbstractContext,CLTypedefDecl}"><code>Clang.wrap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wrap!(ctx::AbstractContext, cursor::CLTypedefDecl)</code></pre><p>Subroutine for handling typedef declarations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.wrap!-Tuple{AbstractContext,CLUnionDecl}" href="#Clang.wrap!-Tuple{AbstractContext,CLUnionDecl}"><code>Clang.wrap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wrap!(ctx::AbstractContext, cursor::CLUnionDecl)</code></pre><p>Subroutine for handling union declarations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.Index" href="#Clang.Index"><code>Clang.Index</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Index(exclude_decls_from_PCH, display_diagnostics)</code></pre><p>Provide a shared context for creating translation units.</p><p><strong>Arguments</strong></p><ul><li><code>exclude_decls_from_PCH</code>: whether to allow enumeration of &quot;local&quot; declarations.</li><li><code>display_diagnostics</code>: whether to display diagnostics.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.TokenList" href="#Clang.TokenList"><code>Clang.TokenList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Tokenizer access</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.TranslationUnit" href="#Clang.TranslationUnit"><code>Clang.TranslationUnit</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TranslationUnit(idx, source, args)
TranslationUnit(idx, source, args, unsavedFiles, options)</code></pre><p>Parse the given source file and the translation unit corresponding to that file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.WrapContext" href="#Clang.WrapContext"><code>Clang.WrapContext</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WrapContext</code></pre><p>Store shared information about the wrapping session.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.CLANG_JULIA_TYPEMAP" href="#Clang.CLANG_JULIA_TYPEMAP"><code>Clang.CLANG_JULIA_TYPEMAP</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Mapping from libclang types to Julia types</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.RESERVED_ARG_TYPES" href="#Clang.RESERVED_ARG_TYPES"><code>Clang.RESERVED_ARG_TYPES</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Unsupported argument types</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.RESERVED_WORDS" href="#Clang.RESERVED_WORDS"><code>Clang.RESERVED_WORDS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Reserved Julia identifiers will be prepended with &quot;_&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isconst-Tuple{Clang.LibClang.CXType}" href="#Base.isconst-Tuple{Clang.LibClang.CXType}"><code>Base.isconst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isconst(t::CXType) -&gt; Bool
isconst(t::CLType) -&gt; Bool</code></pre><p>Determine whether a CXType has the &quot;const&quot; qualifier set, without looking through typedefs that may have added &quot;const&quot; at a different level. Wrapper for libclang&#39;s <code>clang_isConstQualifiedType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{Clang.LibClang.CXCursorKind}" href="#Base.isvalid-Tuple{Clang.LibClang.CXCursorKind}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvalid(k::CXcursorKind) -&gt; Bool
isvalid(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor kind represents an valid cursor. Wrapper for libclang&#39;s <code>clang_isInvalid</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.calling_conv-Tuple{Clang.LibClang.CXType}" href="#Clang.calling_conv-Tuple{Clang.LibClang.CXType}"><code>Clang.calling_conv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calling_conv(t::CXType) -&gt; CXCallingConv
calling_conv(t::CLFunctionProto) -&gt; CXCallingConv
calling_conv(t::CLFunctionNoProto) -&gt; CXCallingConv</code></pre><p>Return the calling convention associated with a function type. Wrapper for libclang&#39;s <code>clang_getFunctionTypeCallingConv</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.handle_macro_exprn-Tuple{TokenList,Int64}" href="#Clang.handle_macro_exprn-Tuple{TokenList,Int64}"><code>Clang.handle_macro_exprn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">handle_macro_exprn(tokens::TokenList, pos::Int)</code></pre><p>For handling of #define&#39;d constants, allows basic expressions but bails out quickly.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isanonymous-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isanonymous-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isanonymous</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isanonymous(c::CXCursor) -&gt; Bool
isanonymous(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the given cursor represents an anonymous record declaration(C++). Wrapper for libclang&#39;s <code>clang_Cursor_isAnonymous</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isvalid-Tuple{Clang.LibClang.CXType}" href="#Clang.isvalid-Tuple{Clang.LibClang.CXType}"><code>Clang.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvalid(t::CXType) -&gt; Bool
isvalid(t::CLType) -&gt; Bool</code></pre><p>Return true if the type is a valid type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.isvirtual-Tuple{Clang.LibClang.CXCursor}" href="#Clang.isvirtual-Tuple{Clang.LibClang.CXCursor}"><code>Clang.isvirtual</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvirtual(c::CXCursor) -&gt; Bool
isvirtual(c::CLCursor) -&gt; Bool</code></pre><p>Return true if the base class specified by the cursor with kind CX<em>CXXBaseSpecifier is virtual. Wrapper for libclang&#39;s `clang</em>isVirtualBase`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Clang.linkage-Tuple{Clang.LibClang.CXCursor}" href="#Clang.linkage-Tuple{Clang.LibClang.CXCursor}"><code>Clang.linkage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">linkage(c::CXCursor) -&gt; CXLinkageKind
linkage(c::CLCursor) -&gt; CXLinkageKind</code></pre><p>Return the linkage of the entity referred to by a given cursor. Wrapper for libclang&#39;s <code>clang_getCursorLinkage</code>.</p></div></div></section><footer><hr/><a class="previous" href="../tutorial/"><span class="direction">Previous</span><span class="title">Tutorial</span></a></footer></article></body></html>
