<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · PackageCompiler.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PackageCompiler.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.build_executable" href="#PackageCompiler.build_executable"><code>PackageCompiler.build_executable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_executable(
    julia_program, output_name = nothing, c_program = nothing;
    snoopfile = nothing, builddir = nothing, verbose = false, quiet = false,
    copy_julialibs = true, copy_files = nothing, release = false, Release = false,
    sysimage = nothing, home = nothing, startup_file = nothing, handle_signals = nothing,
    sysimage_native_code = nothing, compiled_modules = nothing,
    depwarn = nothing, warn_overwrite = nothing,
    compile = nothing, cpu_target = nothing, optimize = nothing, debug = nothing,
    inline = nothing, check_bounds = nothing, math_mode = nothing,
    cc = nothing, cc_flags = nothing
)
`julia_program` needs to be a Julia script containing a `julia_main` function, e.g. like `examples/hello.jl`
`snoopfile` is optional and can be a Julia script which calls functions that you want to make sure to have precompiled
`builddir` is where the compiled artifacts will end up</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.build_shared_lib" href="#PackageCompiler.build_shared_lib"><code>PackageCompiler.build_shared_lib</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_shared_lib(
    julia_program, output_name = nothing;
    snoopfile = nothing, builddir = nothing, verbose = false, quiet = false,
    init_shared = false, copy_julialibs = true, copy_files = nothing, release = false, Release = false,
    sysimage = nothing, home = nothing, startup_file = nothing, handle_signals = nothing,
    sysimage_native_code = nothing, compiled_modules = nothing,
    depwarn = nothing, warn_overwrite = nothing,
    compile = nothing, cpu_target = nothing, optimize = nothing, debug = nothing,
    inline = nothing, check_bounds = nothing, math_mode = nothing,
    cc = nothing, cc_flags = nothing
)
`julia_program` needs to be a Julia script containing a `julia_main` function, e.g. like `examples/hello.jl`
`snoopfile` is optional and can be a Julia script which calls functions that you want to make sure to have precompiled
`builddir` is where the compiled artifacts will end up</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.compile_package-Tuple" href="#PackageCompiler.compile_package-Tuple"><code>PackageCompiler.compile_package</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">compile_package(packages...; kw_args...)</code></pre><p>with packages being either a string naming a package, or a tuple <code>(package_name, precompile_file)</code>. If no precompile file is given, it will use the packages <code>runtests.jl</code>, which is a good canditate for figuring out what functions to compile!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.compile_package-Tuple{Vararg{Tuple{String,String},N} where N}" href="#PackageCompiler.compile_package-Tuple{Vararg{Tuple{String,String},N} where N}"><code>PackageCompiler.compile_package</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">compile_package(packages::Tuple{String, String}...; force = false, reuse = false, debug = false, cpu_target = nothing)</code></pre><p>Compile a list of packages. Each package comes as a tuple of <code>(package_name, precompile_file)</code> where the precompile file should contain all function calls, that should get compiled into the system image. Usually the <code>runtests.jl</code> file is a good candidate, since it should run all important functions of a package.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.force_native_image!" href="#PackageCompiler.force_native_image!"><code>PackageCompiler.force_native_image!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">force_native_image!()</code></pre><p>Builds a clean system image, similar to a fresh Julia install. Can also be used to build a native system image for a downloaded cross compiled julia binary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.revert" href="#PackageCompiler.revert"><code>PackageCompiler.revert</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Reverts a forced compilation of the system image. This will restore any previously backed up system image files, or build a new, clean system image.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.static_julia-Tuple{Any}" href="#PackageCompiler.static_julia-Tuple{Any}"><code>PackageCompiler.static_julia</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">static_julia(juliaprog::String; kw_args...)</code></pre><p>compiles the Julia file at path <code>juliaprog</code> with keyword arguments:</p><pre><code class="language-none">cprog                            C program to compile (required only when building an executable, if not provided a minimal driver program is used)
verbose                          increase verbosity
quiet                            suppress non-error messages
builddir                         build directory
outname                          output files basename
snoopfile                        specify script calling functions to precompile
clean                            remove build directory
autodeps                         automatically build required dependencies
object                           build object file
shared                           build shared library
init_shared                      add `init_jl_runtime` and `exit_jl_runtime` to shared library for runtime initialization
executable                       build executable file
rmtemp                           remove temporary build files
copy_julialibs                   copy Julia libraries to build directory
copy_files                       copy user-specified files to build directory (either `nothing` or a string array)
release                          build in release mode, implies `-O3 -g0` unless otherwise specified
Release                          perform a fully automated release build, equivalent to `-atjr`
sysimage &lt;file&gt;                  start up with the given system image file
home &lt;dir&gt;                       set location of `julia` executable
startup_file {yes|no}            load `~/.julia/config/startup.jl`
handle_signals {yes|no}          enable or disable Julia&#39;s default signal handlers
sysimage_native_code {yes|no}    use native code from system image if available
compiled_modules {yes|no}        enable or disable incremental precompilation of modules
depwarn {yes|no|error}           enable or disable syntax and method deprecation warnings
warn_overwrite {yes|no}          enable or disable method overwrite warnings
compile {yes|no|all|min}         enable or disable JIT compiler, or request exhaustive compilation
cpu_target &lt;target&gt;              limit usage of CPU features up to &lt;target&gt; (implies default `--sysimage_native_code=no`)
optimize {0,1,2,3}               set the optimization level
debug &lt;level&gt;                    enable / set the level of debug info generation
inline {yes|no}                  control whether inlining is permitted
check_bounds {yes|no}            emit bounds checks always or never
math_mode {ieee,fast}            disallow or enable unsafe floating point optimizations
cc                               system C compiler
cc_flags &lt;flags&gt;                 pass custom flags to the system C compiler when building a shared library or executable (either `nothing` or a string array)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.build_sysimg" href="#PackageCompiler.build_sysimg"><code>PackageCompiler.build_sysimg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">build_sysimg(sysimg_path=default_sysimg_path(), cpu_target=&quot;native&quot;, userimg_path=nothing; force=false)</code></pre><p>Rebuild the system image. Store it in <code>sysimg_path</code>, which defaults to a file named <code>sys.ji</code> that sits in the same folder as <code>libjulia.{so,dylib}</code>, except on Windows where it defaults to <code>Sys.BINDIR/../lib/julia/sys.ji</code>. Use the cpu instruction set given by <code>cpu_target</code>. Valid CPU targets are the same as for the <code>-C</code> option to <code>julia</code>, or the <code>-march</code> option to <code>gcc</code>. Defaults to <code>native</code>, which means to use all CPU instructions available on the current processor. Include the user image file given by <code>userimg_path</code>, which should contain directives such as <code>using MyPackage</code> to include that package in the new system image. New system image will not replace an older image unless <code>force</code> is set to true.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.get_backup!" href="#PackageCompiler.get_backup!"><code>PackageCompiler.get_backup!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns the system image file stored in the backup folder. If there is no backup, this function will automatically generate a system image in the backup folder.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PackageCompiler.snoop_userimg-Tuple{Any,Vararg{Tuple{String,String},N} where N}" href="#PackageCompiler.snoop_userimg-Tuple{Any,Vararg{Tuple{String,String},N} where N}"><code>PackageCompiler.snoop_userimg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">snoop_userimg(userimg, packages::Tuple{String, String}...)

Traces all function calls in packages and writes out `precompile` statements into the file `userimg`</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
