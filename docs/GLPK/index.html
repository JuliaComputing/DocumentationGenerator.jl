<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GLPK.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GLPK.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.get_status-Tuple{GLPK.Optimizer}" href="#GLPK.get_status-Tuple{GLPK.Optimizer}"><code>GLPK.get_status</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_status(model::Optimizer)</code></pre><p>Get the status from GLPK depending on which method was used to solve the model.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.AbstractCallbackData" href="#GLPK.AbstractCallbackData"><code>GLPK.AbstractCallbackData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractCallbackData</code></pre><p>An abstract type to prevent recursive type definition of Optimizer and CallbackData, each of which need the other type in a field.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.CallbackData" href="#GLPK.CallbackData"><code>GLPK.CallbackData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CallbackData</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.CallbackFunction" href="#GLPK.CallbackFunction"><code>GLPK.CallbackFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CallbackFunction</code></pre><p>The attribute to set the callback function in GLPK. The function takes a single argument of type <code>CallbackData</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.__internal_callback__-Tuple{Ptr{Nothing},Ptr{Nothing}}" href="#GLPK.__internal_callback__-Tuple{Ptr{Nothing},Ptr{Nothing}}"><code>GLPK.__internal_callback__</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">__internal_callback__(tree::Ptr{Cvoid}, info::Ptr{Cvoid})</code></pre><p>Dummy callback function for internal use only. Responsible for updating the objective bound.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK._certificates_potentially_available-Tuple{GLPK.Optimizer}" href="#GLPK._certificates_potentially_available-Tuple{GLPK.Optimizer}"><code>GLPK._certificates_potentially_available</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_certificates_potentially_available(model::Optimizer)</code></pre><p>Return true if an infeasiblity certificate or an unbounded ray is potentially available (i.e., the model has been solved using either the Simplex or Exact methods).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK._throw_invalid_method-Tuple{GLPK.Optimizer}" href="#GLPK._throw_invalid_method-Tuple{GLPK.Optimizer}"><code>GLPK._throw_invalid_method</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_throw_invalid_method(instance::Optimizer)</code></pre><p>A helper function to throw an error when the method is set incorrectly. Mainly used to enforce type-stability in functions that have a run-time switch on the method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.add_lazy_constraint!-Union{Tuple{S}, Tuple{CallbackData,ScalarAffineFunction{Float64},S}} where S&lt;:Union{EqualTo{Float64}, GreaterThan{Float64}, LessThan{Float64}}" href="#GLPK.add_lazy_constraint!-Union{Tuple{S}, Tuple{CallbackData,ScalarAffineFunction{Float64},S}} where S&lt;:Union{EqualTo{Float64}, GreaterThan{Float64}, LessThan{Float64}}"><code>GLPK.add_lazy_constraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">add_lazy_constraint!(cb_data::GLPK.CallbackData, func::LQOI.Linear, set::S) where S &lt;: Union{LQOI.LE, LQOI.GE, LQOI.EQ}</code></pre><p>Add a lazy constraint to the model <code>cb_data.model</code>. This can only be called in a callback from <code>GLPK.IROWGEN</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.add_row!-Tuple{Prob,Array{Int64,1},Array{Float64,1},Int8,Real}" href="#GLPK.add_row!-Tuple{Prob,Array{Int64,1},Array{Float64,1},Int8,Real}"><code>GLPK.add_row!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">add_row!(problem::GLPK.Prob, columns::Vector{Int},
         coefficients::Vector{Float64}, sense::Cchar, rhs::Real)</code></pre><p>Helper function to add a row to the problem. Sense must be one of <code>&#39;E&#39;</code> (ax == b), <code>&#39;G&#39;</code> (ax &gt;= b), <code>&#39;L&#39;</code> (ax &lt;= b) , or <code>&#39;R&#39;</code> (b &lt;= ax).</p><p>If the sense is <code>&#39;R&#39;</code> the <code>rhs</code> should be the lower bound, and the bounds should be set in a new API call to enforce the upper bound.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.change_row_sense!-Tuple{GLPK.Optimizer,Int64,Any}" href="#GLPK.change_row_sense!-Tuple{GLPK.Optimizer,Int64,Any}"><code>GLPK.change_row_sense!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">change_row_sense!(model::Optimizer, row, sense)</code></pre><p>Convert a linear constraint into another type of linear constraint by changing the comparison sense.</p><p>Constraint types supported are &#39;E&#39; (equality), &#39;L&#39; (less-than), and &#39;G&#39; (greater-than).</p><p>For example, <code>ax &lt;= b</code> can become <code>ax &gt;= b</code> or <code>ax == b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.copy_function_result!-Tuple{Array{T,1} where T,Any,Prob}" href="#GLPK.copy_function_result!-Tuple{Array{T,1} where T,Any,Prob}"><code>GLPK.copy_function_result!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">copy_function_result!(dest::Vector, foo, model::GLPK.Prob)</code></pre><p>A helper function that loops through the indices in <code>dest</code> and stores the result of <code>foo(model, i)</code> for the <code>i</code>th index.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.get_col_bound_type-Tuple{Float64,Float64}" href="#GLPK.get_col_bound_type-Tuple{Float64,Float64}"><code>GLPK.get_col_bound_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_col_bound_type(lower::Float64, upper::Float64)</code></pre><p>Return the GLPK type of the variable bound given a lower bound of <code>lower</code> and an upper bound of <code>upper</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.get_infeasibility_ray-Tuple{GLPK.Optimizer,Array{Float64,1}}" href="#GLPK.get_infeasibility_ray-Tuple{GLPK.Optimizer,Array{Float64,1}}"><code>GLPK.get_infeasibility_ray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_infeasibility_ray(model::Optimizer, ray::Vector{Float64})</code></pre><p>Get the Farkas certificate of primal infeasiblity.</p><p>Can only be called when GLPK.simplex is used as the solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.get_unbounded_ray-Tuple{GLPK.Optimizer,Array{Float64,1}}" href="#GLPK.get_unbounded_ray-Tuple{GLPK.Optimizer,Array{Float64,1}}"><code>GLPK.get_unbounded_ray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_unbounded_ray(model::Optimizer, ray::Vector{Float64})</code></pre><p>Get the certificate of primal unboundedness.</p><p>Can only be called when GLPK.simplex is used as the solver.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.get_variable_types-Tuple{GLPK.Optimizer}" href="#GLPK.get_variable_types-Tuple{GLPK.Optimizer}"><code>GLPK.get_variable_types</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_variable_types(model::Optimizer)</code></pre><p>Return a vector of symbols (one element for each variable) of the variable type. The symbols are given by the key-value mapping in <code>GLPK.VARIABLE_TYPE_MAP</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.load_variable_primal!-Tuple{GLPK.CallbackData}" href="#GLPK.load_variable_primal!-Tuple{GLPK.CallbackData}"><code>GLPK.load_variable_primal!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">load_variable_primal!(cb_data::CallbackData)</code></pre><p>Load the variable primal solution in a callback.</p><p>This can only be called in a callback from <code>GLPK.IROWGEN</code>. After it is called, you can access the <code>VariablePrimal</code> attribute as usual.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.round_bounds_to_integer-Tuple{GLPK.Optimizer}" href="#GLPK.round_bounds_to_integer-Tuple{GLPK.Optimizer}"><code>GLPK.round_bounds_to_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">round_bounds_to_integer(model)::Tuple{Bool, Vector{Float64}, Vector{Float64}}</code></pre><p>GLPK does not allow integer variables with fractional bounds. Therefore, we round the bounds of binary and integer variables to integer values prior to solving.</p><p>Returns a tuple of the original bounds, along with a Boolean flag indicating if they need to be reset after solve.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.set_parameter-Tuple{Any,Symbol,Any}" href="#GLPK.set_parameter-Tuple{Any,Symbol,Any}"><code>GLPK.set_parameter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_parameter(param_store, key::Symbol, value)</code></pre><p>Set the field name <code>key</code> in a <code>param_store</code> type (that is one of <code>InteriorParam</code>, <code>IntoptParam</code>, or <code>SimplexParam</code>) to <code>value</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLPK.set_variable_bound-Tuple{GLPK.Optimizer,Int64,Float64,Float64}" href="#GLPK.set_variable_bound-Tuple{GLPK.Optimizer,Int64,Float64,Float64}"><code>GLPK.set_variable_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">set_variable_bound(model::Optimizer, column::Int, lower::Float64, upper::Float64)</code></pre><p>Set the bounds of the variable in column <code>column</code> to <code>[lower, upper]</code>.</p></div></div></section><footer><hr/></footer></article></body></html>
