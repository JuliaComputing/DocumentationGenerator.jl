<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generic sparse distributed multivariate polynomials Â· AbstractAlgebra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractAlgebra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">AbstractAlgebra.jl</a></li><li><a class="toctext" href="../constructors/">Constructing mathematical objects in AbstractAlgebra.jl</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="../rings/">Ring Interface</a></li><li><a class="toctext" href="../ncrings/">Noncommutative ring Interface</a></li><li><a class="toctext" href="../euclidean/">Euclidean Ring Interface</a></li><li><a class="toctext" href="../integer/">Integer ring</a></li><li><a class="toctext" href="../polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="toctext" href="../polynomial/">Generic univariate polynomials</a></li><li><a class="toctext" href="../ncpolynomial/">Generic univariate polynomials over a noncommutative ring</a></li><li><a class="toctext" href="../mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li class="current"><a class="toctext" href>Generic sparse distributed multivariate polynomials</a><ul class="internal"><li><a class="toctext" href="#Types-and-parent-objects-1">Types and parent objects</a></li><li><a class="toctext" href="#Polynomial-ring-constructors-1">Polynomial ring constructors</a></li></ul></li><li><a class="toctext" href="../series_rings/">Series Ring Interface</a></li><li><a class="toctext" href="../series/">Generic power series</a></li><li><a class="toctext" href="../puiseux/">Generic Puiseux series</a></li><li><a class="toctext" href="../residue_rings/">Residue Ring Interface</a></li><li><a class="toctext" href="../residue/">Generic residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li><a class="toctext" href="../fields/">Field Interface</a></li><li><a class="toctext" href="../fraction_fields/">Fraction Field Interface</a></li><li><a class="toctext" href="../fraction/">Generic fraction fields</a></li><li><a class="toctext" href="../rational/">Rational field</a></li><li><a class="toctext" href="../finfield/">Finite fields</a></li><li><a class="toctext" href="../real/">Real field</a></li><li><a class="toctext" href="../numberfield/">Number fields</a></li></ul></li><li><span class="toctext">Groups</span><ul><li><a class="toctext" href="../perm/">Permutations and Permutation groups</a></li><li><a class="toctext" href="../ytabs/">Partitions and Young tableaux</a></li></ul></li><li><span class="toctext">Matrices</span><ul><li><a class="toctext" href="../matrix_spaces/">Matrix Interface</a></li><li><a class="toctext" href="../matrix/">Generic matrices</a></li><li><a class="toctext" href="../matrix_algebras/">Generic matrix algebras</a></li></ul></li><li><span class="toctext">Maps</span><ul><li><a class="toctext" href="../map/">Map interface</a></li><li><a class="toctext" href="../functional_map/">Functional maps</a></li><li><a class="toctext" href="../map_cache/">Cached maps</a></li><li><a class="toctext" href="../map_with_inverse/">Map with inverse</a></li></ul></li><li><a class="toctext" href="../types/">Appendix A: Types in AbstractAlgebra.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href>Generic sparse distributed multivariate polynomials</a></li></ul></nav><hr/><div id="topbar"><span>Generic sparse distributed multivariate polynomials</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generic-sparse-distributed-multivariate-polynomials-1" href="#Generic-sparse-distributed-multivariate-polynomials-1">Generic sparse distributed multivariate polynomials</a></h1><p>AbstractAlgebra.jl provides a module, implemented in <code>src/generic/MPoly.jl</code> for generic sparse distributed multivariate polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.</p><p>This modules implements the Multivariate Polynomial interface, including the sparse distributed, random access part of the interface.</p><p>All of the generic functionality is part of a submodule of AbstractAlgebra called <code>Generic</code>. This is exported by default so that it is not necessary to qualify the function names with the submodule name.</p><p>Multivariates are implemented in this module using a Julia array of coefficients and a 2-dimensional Julia array of <code>UInt</code>s for the exponent vectors. Note that exponent <span>$n$</span> is represented by the <span>$n$</span>-th column of the exponent array, not the <span>$n$</span>-th row. This is because Julia uses a column major representation.</p><h2><a class="nav-anchor" id="Types-and-parent-objects-1" href="#Types-and-parent-objects-1">Types and parent objects</a></h2><p>Multivariate polynomials implemented in AbstractAlgebra.jl have type <code>Generic.MPoly{T}</code> where <code>T</code> is the type of elements of the coefficient ring.</p><p>The polynomials are implemented using a Julia array of coefficients and a 2-dimensional Julia array of <code>UInt</code>s for the exponent vectors. Note that exponent <span>$n$</span> is represented by the <span>$n$</span>-th column of the exponent array, not the <span>$n$</span>-th row. This is because Julia uses a column major representation. See the file <code>src/generic/GenericTypes.jl</code> for details.</p><p>The top bit of each <code>UInt</code> is reserved for overflow detection.</p><p>Parent objects of such polynomials have type <code>Generic.MPolyRing{T}</code>.</p><p>The string representation of the variables of the polynomial ring, the base/coefficient ring <span>$R$</span> and the ordering are stored in the parent object. </p><p>The polynomial element types belong to the abstract type <code>AbstractAlgebra.MPolyElem{T}</code> and the polynomial ring types belong to the abstract type <code>AbstractAlgebra.MPolyRing{T}</code>.</p><p>Note that both the generic polynomial ring type <code>Generic.MPolyRing{T}</code> and the abstract type it belongs to, <code>AbstractAlgebra.MPolyRing{T}</code> are both called <code>MPolyRing</code>. The  former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type <code>T</code>. The latter is an abstract type representing all multivariate polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).</p><h2><a class="nav-anchor" id="Polynomial-ring-constructors-1" href="#Polynomial-ring-constructors-1">Polynomial ring constructors</a></h2><p>In order to construct multivariate polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.</p><pre><code class="language-julia">PolynomialRing(R::AbstractAlgebra.Ring, S::Array{String, 1}; cached::Bool = true, ordering::Symbol=:lex)</code></pre><p>Given a base ring <code>R</code> and and array <code>S</code> of strings specifying how the generators (variables) should be printed, return a tuple <code>S, (x, ...)</code> representing the new polynomial ring <span>$S = R[x, \ldots]$</span> and a tuple of the generators <span>$(x, ...)$</span> of the ring. By default the parent object <code>S</code> will depend only on <code>R</code> and  <code>(x, ...)</code> and will be cached. Setting the optional argument <code>cached</code> to <code>false</code> will prevent the parent object  <code>S</code> from being cached.</p><p>The optional named argument <code>ordering</code> can be used to specify an ordering. The currently supported options are <code>:lex</code>, <code>:deglex</code> and `:degrevlex	.</p><p>Here are some examples of creating multivariate polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;]; ordering=:deglex)

f = R()
g = R(123)
h = R(BigInt(1234))
k = R(x + 1)
m = R(x + y + 1)
derivative(k,x)
derivative(k,y)</code></pre><p>All of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a <code>PolynomialRing</code> constructor to allow creation of their polynomial rings.</p><footer><hr/><a class="previous" href="../mpolynomial_rings/"><span class="direction">Previous</span><span class="title">Multivariate Polynomial Ring Interface</span></a><a class="next" href="../series_rings/"><span class="direction">Next</span><span class="title">Series Ring Interface</span></a></footer></article></body></html>
