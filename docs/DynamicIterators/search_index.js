var documenterSearchIndex = {"docs": [

{
    "location": "#DynamicIterators.BindOnce",
    "page": "Home",
    "title": "DynamicIterators.BindOnce",
    "category": "type",
    "text": "BindOnce(state, control)\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.DynamicIterator",
    "page": "Home",
    "title": "DynamicIterators.DynamicIterator",
    "category": "type",
    "text": "DynamicIterator\n\nDynamicIterators which extend the iterator protocol by keywords for the iterate function.\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.Evolution",
    "page": "Home",
    "title": "DynamicIterators.Evolution",
    "category": "type",
    "text": "Evolution\n\nEvolutions define\n\n    evolve(iter, value::T)::T\n\nand possibly\n\n    evolve(iter, key=>value)\n\nThey guarantee HasEltype() and eltype(iter) == T.\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.Evolve",
    "page": "Home",
    "title": "DynamicIterators.Evolve",
    "category": "type",
    "text": "evolve(f)\n\nCreate the DynamicIterator corresponding to the evolution\n\n    x = f(x)\n\nInteger keys default to increments. Integer control default to keys (and repetitions).\n\njulia> collect(take(from(Evolve(x->x + 1), 10), 5))\n5-element Array{Any,1}:\n 10\n 11\n 12\n 13\n 14\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.Start",
    "page": "Home",
    "title": "DynamicIterators.Start",
    "category": "type",
    "text": "Start(value) <: Message\n\nTransient message to start to iterate from the state corresponding to value.\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.Value",
    "page": "Home",
    "title": "DynamicIterators.Value",
    "category": "type",
    "text": "Value(value, state) <: Message\n\nTransient message to continue to iterate from state reacting to a forced change in the iterate value.\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.dyniterate-Tuple{Any,Steps}",
    "page": "Home",
    "title": "DynamicIterators.dyniterate",
    "category": "method",
    "text": "dyniterate(iter, state, (steps,)::Steps)\n\nAdvance the iterator steps times, and for negative numbers, if implemented, rewind the iterator -steps times.\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.synchronize-Tuple",
    "page": "Home",
    "title": "DynamicIterators.synchronize",
    "category": "method",
    "text": "synchronize\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.trace",
    "page": "Home",
    "title": "DynamicIterators.trace",
    "category": "function",
    "text": "trace(P, u::Pair, stop; register = x->true)\n\nTrace the trajectoy of a keyed Dynamic iterator as Trajectory.\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.Controlled",
    "page": "Home",
    "title": "DynamicIterators.Controlled",
    "category": "type",
    "text": "Controlled(C, P)\n\n\"Controlled\" iterator P with the state t of C calling\n\n(t => x) = evolve(P, t=>x, tᵒ)\n\nExample\n\n# Apply collatz twice each step using the default for Evolve\n\ncollatz(n) = n % 2 == 0 ? n÷2 : 3n + 1\ncollectfrom(Controlled(1:2:20, Evolve(collatz)), (1,14))\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.From",
    "page": "Home",
    "title": "DynamicIterators.From",
    "category": "type",
    "text": "from(P, x)\n\nAttach a starting value to a DynamicIterator.\n\nExample\n\ncollect(from(1:14, 10)) == [11, 12, 13, 14]\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.Mix",
    "page": "Home",
    "title": "DynamicIterators.Mix",
    "category": "type",
    "text": "mix(f, P, Q)\n\nMix two dynamic iterators by applying the mixing function f to their states:\n\nx, y = f(x, y)\n\nExample\n\ncollectfrom(Mix((x,y) -> (x+y, y), 1:0, 1:100), (1,1)))\n# last value 100*101/2 + 100\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.Mixture",
    "page": "Home",
    "title": "DynamicIterators.Mixture",
    "category": "type",
    "text": "mixture(I, Ps)\n\nevolve(M::Mixture, (i, x))\n\nChoose evolution in Ps[i] for x using iterate i of I.\n\n\n\n\n\n"
},

{
    "location": "#DynamicIterators.State",
    "page": "Home",
    "title": "DynamicIterators.State",
    "category": "type",
    "text": "State(state) <: Message\n\nPersistent message to iterate from the state.\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [DynamicIterators]\nOrder = [:type, :function]"
},

]}
