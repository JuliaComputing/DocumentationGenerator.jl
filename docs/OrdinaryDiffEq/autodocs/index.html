<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · OrdinaryDiffEq.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OrdinaryDiffEq.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.NLFunctional-Tuple{Any}" href="#OrdinaryDiffEq.NLFunctional-Tuple{Any}"><code>OrdinaryDiffEq.NLFunctional</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>(S::NLFunctional)(integrator) -&gt; (z, η, iter, fail_convergence)</p><p>Perform functional iteration that is used by implicit methods, where <code>z</code> is the solution, <code>η</code> is used to measure the iteration error (see <a href="#footnote-HW96">[HW96]</a>), <code>iter</code> is the number of iteration, and <code>fail_convergence</code> reports whether the algorithm succeed.  It solves</p><div>\[G(z) = dt⋅f(tmp + γ⋅z, p, t+c⋅h)
z = G(z)\]</div><p>by iterating</p><div>\[zᵏ⁺¹ = G(zᵏ).\]</div><div class="footnote" id="footnote-HW96"><a href="#footnote-HW96"><strong>[HW96]</strong></a><p>Ernst Hairer and Gerhard Wanner, &quot;Solving Ordinary Differential</p></div><p>Equations II, Springer Series in Computational Mathematics. ISBN 978-3-642-05221-7. Section IV.8. <a href="https://doi.org/10.1007/978-3-642-05221-7">doi:10.1007/978-3-642-05221-7</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.NLNewton-Tuple{Any}" href="#OrdinaryDiffEq.NLNewton-Tuple{Any}"><code>OrdinaryDiffEq.NLNewton</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>(S::NLNewton)(integrator) -&gt; (z, η, iter, fail_convergence)</p><p>Perform numerically stable modified NLNewton iteration that is specialized for implicit methods (see <a href="#footnote-HS96">[HS96]</a> and <a href="#footnote-HW96">[HW96]</a>), where <code>z</code> is the solution, <code>η</code> is used to measure the iteration error (see <a href="#footnote-HW96">[HW96]</a>), <code>iter</code> is the number of iteration, and <code>fail_convergence</code> reports whether the algorithm succeed. It solves</p><div>\[G(z) = dt⋅f(tmp + γ⋅z, p, t+c⋅h) - z = 0⃗\]</div><p>by iterating</p><div>\[W Δᵏ = dt⋅f(tmp + γ⋅zᵏ, p, t+c⋅h) - zᵏ
zᵏ⁺¹ = zᵏ + Δᵏ\]</div><p>where <code>W=M-dt⋅γJ</code>, <code>M</code> is the mass matrix, <code>dt</code> is the step size, <code>γ</code> is a constant, and <code>J</code> is the Jacobian matrix.</p><div class="footnote" id="footnote-HS96"><a href="#footnote-HS96"><strong>[HS96]</strong></a><p>M.E.Hoseaa and L.F.Shampine, &quot;Analysis and implementation of TR-BDF2&quot;,</p></div><p>Applied Numerical Mathematics, Volume 20, Issues 1–2, February 1996, Pages 21-37. <a href="https://doi.org/10.1016/0168-9274(95)00115-8">doi:10.1016/0168-9274(95)00115-8</a></p><div class="footnote" id="footnote-HW96"><a href="#footnote-HW96"><strong>[HW96]</strong></a><p>Ernst Hairer and Gerhard Wanner, &quot;Solving Ordinary Differential</p></div><p>Equations II, Springer Series in Computational Mathematics. ISBN 978-3-642-05221-7. Section IV.8. <a href="https://doi.org/10.1007/978-3-642-05221-7">doi:10.1007/978-3-642-05221-7</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>An Efficient Runge-Kutta (4,5) Pair by P.Bogacki and L.F.Shampine  Computers and Mathematics with Applications, Vol. 32, No. 6, 1996, pages 15 to 28</p><p>Called to add the extra k9, k10, k11 steps for the Order 5 interpolation when needed</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>By default, Hermite interpolant so update the derivative at the two ends</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>An Efficient Runge-Kutta (4,5) Pair by P.Bogacki and L.F.Shampine  Computers and Mathematics with Applications, Vol. 32, No. 6, 1996, pages 15 to 28</p><p>Called to add the extra k9, k10, k11 steps for the Order 5 interpolation when needed</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.addsteps!" href="#DiffEqBase.addsteps!"><code>DiffEqBase.addsteps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.constructDormandPrince" href="#OrdinaryDiffEq.constructDormandPrince"><code>OrdinaryDiffEq.constructDormandPrince</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>constructDormandPrince()</p><p>Constructs the tableau object for the Dormand-Prince Order 4/5 method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.ode_interpolant-Union{Tuple{TI}, Tuple{Any,Any,Any,Any,Any,Any,Any,Type{Val{TI}}}} where TI" href="#OrdinaryDiffEq.ode_interpolant-Union{Tuple{TI}, Tuple{Any,Any,Any,Any,Any,Any,Any,Type{Val{TI}}}} where TI"><code>OrdinaryDiffEq.ode_interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>ode<em>interpolant and ode</em>interpolant! dispatch</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Anas5ConstantCache" href="#OrdinaryDiffEq.Anas5ConstantCache"><code>OrdinaryDiffEq.Anas5ConstantCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An Optimized Runge-Kutta method for the solution of Orbital Problems by Z.A. Anastassi and T.E. Simos Journal of Computational and Applied Mathematics, Volume 175, Issue 1, 1 March 2005, Pages 1 to 9.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.BS3ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.BS3ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.BS3ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constructBogakiShampine3()</p><p>Constructs the tableau object for the Bogakai-Shampine Order 2/3 method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.BS3ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.BS3ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.BS3ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constructBogakiShampine3()</p><p>Constructs the tableau object for the Bogakai-Shampine Order 2/3 method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.BS5ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.BS5ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.BS5ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>An Efficient Runge-Kutta (4,5) Pair by P.Bogacki and L.F.Shampine  Computers and Mathematics with Applications, Vol. 32, No. 6, 1996, pages 15 to 28</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.BS5ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.BS5ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.BS5ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>An Efficient Runge-Kutta (4,5) Pair by P.Bogacki and L.F.Shampine  Computers and Mathematics with Applications, Vol. 32, No. 6, 1996, pages 15 to 28</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Feagin10ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.Feagin10ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.Feagin10ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constructFeagin10</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Feagin10ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.Feagin10ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.Feagin10ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constructFeagin10</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Feagin12ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.Feagin12ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.Feagin12ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constructFeagin12</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Feagin12ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.Feagin12ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.Feagin12ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constructFeagin12</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Feagin14ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.Feagin14ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.Feagin14ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constructFeagin14</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Feagin14ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.Feagin14ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.Feagin14ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>constructFeagin14</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.ODEIntegrator" href="#OrdinaryDiffEq.ODEIntegrator"><code>OrdinaryDiffEq.ODEIntegrator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ODEIntegrator</code></pre><p>Fundamental <code>struct</code> allowing interactively stepping through the numerical solving of a differential equation. The full documentation is hosted here: <a href="http://docs.juliadiffeq.org/latest/basics/integrator.html">http://docs.juliadiffeq.org/latest/basics/integrator.html</a>. This docstring describes basic functionality only!</p><p>Initialize using <code>integrator = init(prob::ODEProblem, alg; kwargs...)</code>. The keyword args which are accepted are the same <a href="http://docs.juliadiffeq.org/latest/basics/common_solver_opts.html#Common-Solver-Options-1">Common Solver Options</a> used by <code>solve</code>.</p><p>For reference, relevant fields of the <code>ODEIntegrator</code> are:</p><ul><li><code>t</code> - time of the proposed step</li><li><code>u</code> - value at the proposed step</li><li><code>opts</code> - common solver options</li><li><code>alg</code> - the algorithm associated with the solution</li><li><code>f</code> - the function being solved</li><li><code>sol</code> - the current state of the solution</li><li><code>tprev</code> - the last timepoint</li><li><code>uprev</code> - the value at the last timepoint</li></ul><p><code>opts</code> holds all of the common solver options, and can be mutated to change the solver characteristics. For example, to modify the absolute tolerance for the future timesteps, one can do:</p><pre><code class="language-julia">integrator.opts.abstol = 1e-9</code></pre><p>For more info see the linked documentation page.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.TanYam7ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.TanYam7ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.TanYam7ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>On the Optimization of Some Nine-Stage Seventh-order Runge-Kutta Method, by M. Tanaka, S. Muramatsu and S. Yamashita, Information Processing Society of Japan, Vol. 33, No. 12 (1992) pages 1512-1526.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.TanYam7ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.TanYam7ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.TanYam7ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>On the Optimization of Some Nine-Stage Seventh-order Runge-Kutta Method, by M. Tanaka, S. Muramatsu and S. Yamashita, Information Processing Society of Japan, Vol. 33, No. 12 (1992) pages 1512-1526.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.TsitPap8ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.TsitPap8ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.TsitPap8ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Cheap Error Estimation for Runge-Kutta methods, by Ch. Tsitouras and S.N. Papakostas,  Siam Journal on Scientific Computing, Vol. 20, Issue 6, Nov 1999.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.TsitPap8ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.TsitPap8ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.TsitPap8ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Cheap Error Estimation for Runge-Kutta methods, by Ch. Tsitouras and S.N. Papakostas,  Siam Journal on Scientific Computing, Vol. 20, Issue 6, Nov 1999.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Vern6ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.Vern6ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.Vern6ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>From Verner&#39;s Website</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Vern6ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.Vern6ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.Vern6ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>From Verner&#39;s Website</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Vern9ConstantCache-Tuple{Type,Type}" href="#OrdinaryDiffEq.Vern9ConstantCache-Tuple{Type,Type}"><code>OrdinaryDiffEq.Vern9ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>From Verner&#39;s Webiste</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Vern9ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.Vern9ConstantCache-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.Vern9ConstantCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>From Verner&#39;s Webiste</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.WOperator" href="#OrdinaryDiffEq.WOperator"><code>OrdinaryDiffEq.WOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WOperator(mass_matrix,gamma,J[;transform=false])</code></pre><p>A linear operator that represents the W matrix of an ODEProblem, defined as</p><div>\[W = MM - \gamma J\]</div><p>or, if <code>transform=true</code>:</p><div>\[W = \frac{1}{\gamma}MM - J\]</div><p>where <code>MM</code> is the mass matrix (a regular <code>AbstractMatrix</code> or a <code>UniformScaling</code>), <code>γ</code> is a real number proportional to the time step, and <code>J</code> is the Jacobian operator (must be a <code>AbstractDiffEqLinearOperator</code>). A <code>WOperator</code> can also be constructed using a <code>*DEFunction</code> directly as</p><pre><code class="language-none">WOperator(f,gamma[;transform=false])</code></pre><p><code>f</code> needs to have a jacobian and <code>jac_prototype</code>, but the prototype does not need to be a diffeq operator –- it will automatically be converted to one.</p><p><code>WOperator</code> supports lazy <code>*</code> and <code>mul!</code> operations, the latter utilizing an internal cache (can be specified in the constructor; default to regular <code>Vector</code>). It supports all of <code>AbstractDiffEqLinearOperator</code>&#39;s interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.BS5Interp-Tuple{Type,Type}" href="#OrdinaryDiffEq.BS5Interp-Tuple{Type,Type}"><code>OrdinaryDiffEq.BS5Interp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>An Efficient Runge-Kutta (4,5) Pair by P.Bogacki and L.F.Shampine  Computers and Mathematics with Applications, Vol. 32, No. 6, 1996, pages 15 to 28</p><p>Used in the lazy construction of the dense output</p><p>k9, k10, k11 are not computed until called in the dense routine</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.BS5Interp-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.BS5Interp-Union{Tuple{T2}, Tuple{T}, Tuple{Type{T},Type{T2}}} where T2&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.BS5Interp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>An Efficient Runge-Kutta (4,5) Pair by P.Bogacki and L.F.Shampine  Computers and Mathematics with Applications, Vol. 32, No. 6, 1996, pages 15 to 28</p><p>Used in the lazy construction of the dense output</p><p>k9, k10, k11 are not computed until called in the dense routine</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.BS5Interp_polyweights-Tuple{Type}" href="#OrdinaryDiffEq.BS5Interp_polyweights-Tuple{Type}"><code>OrdinaryDiffEq.BS5Interp_polyweights</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Coefficients for the polynomial bᵢΘ = ri1<em>Θ + ri2</em>Θ^2 + ri3*Θ^3 + ...</p><p>These coefficients are taken from RKSuite</p><p>Note that RKSuite has an error: r081 should be 0 and r011 should be 1. This is pretty easy to spot since the first order interpolation is linear from y₀.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.BS5Interp_polyweights-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.BS5Interp_polyweights-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.BS5Interp_polyweights</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Coefficients for the polynomial bᵢΘ = ri1<em>Θ + ri2</em>Θ^2 + ri3*Θ^3 + ...</p><p>These coefficients are taken from RKSuite</p><p>Note that RKSuite has an error: r081 should be 0 and r011 should be 1. This is pretty easy to spot since the first order interpolation is linear from y₀.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Tsit5Interp-Tuple{Type}" href="#OrdinaryDiffEq.Tsit5Interp-Tuple{Type}"><code>OrdinaryDiffEq.Tsit5Interp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Coefficients for the polynomial bᵢΘ = ri1<em>Θ + ri2</em>Θ^2 + ri3*Θ^3 + ...</p><p>These are the coefficients of the expanded form of the polynomials from</p><p>Runge–Kutta pairs of order 5(4) satisfying only the first column simplifying assumption</p><p>Ch. Tsitouras</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Tsit5Interp-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.Tsit5Interp-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.Tsit5Interp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Coefficients for the polynomial bᵢΘ = ri1<em>Θ + ri2</em>Θ^2 + ri3*Θ^3 + ...</p><p>These are the coefficients of the expanded form of the polynomials from</p><p>Runge–Kutta pairs of order 5(4) satisfying only the first column simplifying assumption</p><p>Ch. Tsitouras</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Vern6Interp_polyweights-Tuple{Type}" href="#OrdinaryDiffEq.Vern6Interp_polyweights-Tuple{Type}"><code>OrdinaryDiffEq.Vern6Interp_polyweights</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Coefficients for the polynomial bᵢΘ = ri1<em>Θ + ri2</em>Θ^2 + ri3*Θ^3 + ...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.Vern6Interp_polyweights-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}" href="#OrdinaryDiffEq.Vern6Interp_polyweights-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64, Dual{Tag{T,W},K,3} where K&lt;:Union{Float32, Float64} where W&lt;:Union{Float32, Float64} where T}"><code>OrdinaryDiffEq.Vern6Interp_polyweights</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Coefficients for the polynomial bᵢΘ = ri1<em>Θ + ri2</em>Θ^2 + ri3*Θ^3 + ...</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq._ode_interpolant-Tuple{Any,Any,Any,Any,Any,Union{DP8Cache, DP8ConstantCache},Nothing,Type{Val{0}}}" href="#OrdinaryDiffEq._ode_interpolant-Tuple{Any,Any,Any,Any,Any,Union{DP8Cache, DP8ConstantCache},Nothing,Type{Val{0}}}"><code>OrdinaryDiffEq._ode_interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq._ode_interpolant-Tuple{Any,Any,Any,Any,Any,Union{Rodas4Cache, Rodas4ConstantCache},Nothing,Type{Val{0}}}" href="#OrdinaryDiffEq._ode_interpolant-Tuple{Any,Any,Any,Any,Any,Union{Rodas4Cache, Rodas4ConstantCache},Nothing,Type{Val{0}}}"><code>OrdinaryDiffEq._ode_interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>From MATLAB ODE Suite by Shampine</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.alg_cache_expRK-Tuple{OrdinaryDiffEq.OrdinaryDiffEqExponentialAlgorithm,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}" href="#OrdinaryDiffEq.alg_cache_expRK-Tuple{OrdinaryDiffEq.OrdinaryDiffEqExponentialAlgorithm,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}"><code>OrdinaryDiffEq.alg_cache_expRK</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">alg_cache_expRK(alg,u,uEltypeNoUnits,uprev,f,t,dt,p,du1,tmp,dz,plist)</code></pre><p>Construct the non-standard caches (not uType or rateType) for ExpRK integrators.</p><p><code>plist</code> is a list of integers each corresponding to the order of a <code>phiv(!)</code> call in <code>perform_step!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.alg_cache_exprb-Tuple{OrdinaryDiffEq.OrdinaryDiffEqAdaptiveExponentialAlgorithm,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}" href="#OrdinaryDiffEq.alg_cache_exprb-Tuple{OrdinaryDiffEq.OrdinaryDiffEqAdaptiveExponentialAlgorithm,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}"><code>OrdinaryDiffEq.alg_cache_exprb</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">alg_cache_exprb(alg,uEltypeNoUnits,uprev,f,t,p,du1,tmp,dz,plist)</code></pre><p>Construct the non-standard caches (not uType or rateType) for Exprb integrators.</p><p><code>plist</code> is a list of integers each corresponding to the order of a <code>phiv(!)</code> call in <code>perform_step!</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.calc_J!-Tuple{Any,OrdinaryDiffEq.OrdinaryDiffEqMutableCache,Any}" href="#OrdinaryDiffEq.calc_J!-Tuple{Any,OrdinaryDiffEq.OrdinaryDiffEqMutableCache,Any}"><code>OrdinaryDiffEq.calc_J!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calc_J!(integrator,cache,is_compos)</code></pre><p>Interface for calculating the jacobian.</p><p>For constant caches, a new jacobian object is returned whereas for mutable caches <code>cache.J</code> is updated. In both cases, if <code>integrator.f</code> has a custom jacobian update function, then it will be called for the update. Otherwise, either ForwardDiff or finite difference will be used depending on the <code>jac_config</code> of the cache.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.calc_J-Tuple{Any,OrdinaryDiffEq.OrdinaryDiffEqConstantCache,Any}" href="#OrdinaryDiffEq.calc_J-Tuple{Any,OrdinaryDiffEq.OrdinaryDiffEqConstantCache,Any}"><code>OrdinaryDiffEq.calc_J</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calc_J(integrator,cache,is_compos)</code></pre><p>Interface for calculating the jacobian.</p><p>For constant caches, a new jacobian object is returned whereas for mutable caches <code>cache.J</code> is updated. In both cases, if <code>integrator.f</code> has a custom jacobian update function, then it will be called for the update. Otherwise, either ForwardDiff or finite difference will be used depending on the <code>jac_config</code> of the cache.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.calculate_residuals!-NTuple{6,Any}" href="#OrdinaryDiffEq.calculate_residuals!-NTuple{6,Any}"><code>OrdinaryDiffEq.calculate_residuals!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calculate_residuals!(out, u₀, u₁, α, ρ)</code></pre><p>Save element-wise residuals</p><div>\[\frac{ũ}{α+\max{|u₀|,|u₁|}*ρ}\]</div><p>in <code>out</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.calculate_residuals!-NTuple{7,Any}" href="#OrdinaryDiffEq.calculate_residuals!-NTuple{7,Any}"><code>OrdinaryDiffEq.calculate_residuals!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calculate_residuals!(out, ũ, u₀, u₁, α, ρ)</code></pre><p>Save element-wise residuals</p><div>\[\frac{ũ}{α+\max{|u₀|,|u₁|}*ρ}\]</div><p>in <code>out</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.calculate_residuals-NTuple{5,Any}" href="#OrdinaryDiffEq.calculate_residuals-NTuple{5,Any}"><code>OrdinaryDiffEq.calculate_residuals</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calculate_residuals(u₀, u₁, α, ρ)</code></pre><p>Calculate element-wise residuals</p><div>\[\frac{ũ}{α+\max{|u₀|,|u₁|}*ρ}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.calculate_residuals-NTuple{6,Any}" href="#OrdinaryDiffEq.calculate_residuals-NTuple{6,Any}"><code>OrdinaryDiffEq.calculate_residuals</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calculate_residuals(ũ, u₀, u₁, α, ρ)</code></pre><p>Calculate element-wise residuals</p><div>\[\frac{ũ}{α+\max{|u₀|,|u₁|}*ρ}\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.choosedeg!-Union{Tuple{T}, Tuple{T}} where T" href="#OrdinaryDiffEq.choosedeg!-Union{Tuple{T}, Tuple{T}} where T"><code>OrdinaryDiffEq.choosedeg!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">choosedeg!(cache) -&gt; nothing</code></pre><p>Calculate <code>ms[mdeg]</code> (the degree of the Chebyshev polynomial) and <code>cache.recind</code> (the index of recurrence parameters for that degree), where <code>recf[recind:(recind+ms[mdeg]-2)]</code> are the <code>μ,κ</code> pairs for the <code>mdeg</code> degree method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.expRK_operators-Tuple{Union{OrdinaryDiffEqAdaptiveExponentialAlgorithm, OrdinaryDiffEqExponentialAlgorithm},Any,Any}" href="#OrdinaryDiffEq.expRK_operators-Tuple{Union{OrdinaryDiffEqAdaptiveExponentialAlgorithm, OrdinaryDiffEqExponentialAlgorithm},Any,Any}"><code>OrdinaryDiffEq.expRK_operators</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">expRK_operators(alg,dt,A) -&gt; ops</code></pre><p>Compute operator(s) for an ExpRK algorithm. <code>dt</code> is the time step and <code>A</code> is the matrix form of the linear operator (from either a linear problem or a SplitODEProblem). All ExpRK methods that use caching operators should implement this method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.hermite_interpolant-Tuple{Any,Any,Any,Any,Any,Nothing,Type{Val{0}}}" href="#OrdinaryDiffEq.hermite_interpolant-Tuple{Any,Any,Any,Any,Any,Nothing,Type{Val{0}}}"><code>OrdinaryDiffEq.hermite_interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hairer Norsett Wanner Solving Ordinary Differential Euations I - Nonstiff Problems Page 190</p><p>Herimte Interpolation, chosen if no other dispatch for ode_interpolant</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.hermite_interpolant-Tuple{Any,Any,Any,Any,Any,Nothing,Type{Val{1}}}" href="#OrdinaryDiffEq.hermite_interpolant-Tuple{Any,Any,Any,Any,Any,Nothing,Type{Val{1}}}"><code>OrdinaryDiffEq.hermite_interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Herimte Interpolation, chosen if no other dispatch for ode_interpolant</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.hermite_interpolant-Tuple{Any,Any,Any,Any,Any,Nothing,Type{Val{2}}}" href="#OrdinaryDiffEq.hermite_interpolant-Tuple{Any,Any,Any,Any,Any,Nothing,Type{Val{2}}}"><code>OrdinaryDiffEq.hermite_interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Herimte Interpolation, chosen if no other dispatch for ode_interpolant</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.hermite_interpolant-Tuple{Any,Any,Any,Any,Any,Nothing,Type{Val{3}}}" href="#OrdinaryDiffEq.hermite_interpolant-Tuple{Any,Any,Any,Any,Any,Nothing,Type{Val{3}}}"><code>OrdinaryDiffEq.hermite_interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Herimte Interpolation, chosen if no other dispatch for ode_interpolant</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.linear_interpolant-Tuple{Any,Any,Any,Any,Nothing,Type{Val{1}}}" href="#OrdinaryDiffEq.linear_interpolant-Tuple{Any,Any,Any,Any,Nothing,Type{Val{1}}}"><code>OrdinaryDiffEq.linear_interpolant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Linear Interpolation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.ode_interpolation" href="#OrdinaryDiffEq.ode_interpolation"><code>OrdinaryDiffEq.ode_interpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ode_interpolation(tval::Number,ts,timeseries,ks)</p><p>Get the value at tval where the solution is known at the times ts (sorted), with values timeseries and derivatives ks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.ode_interpolation" href="#OrdinaryDiffEq.ode_interpolation"><code>OrdinaryDiffEq.ode_interpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ode_interpolation(tvals,ts,timeseries,ks)</p><p>Get the value at tvals where the solution is known at the times ts (sorted), with values timeseries and derivatives ks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.ode_interpolation!" href="#OrdinaryDiffEq.ode_interpolation!"><code>OrdinaryDiffEq.ode_interpolation!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ode_interpolation(tvals,ts,timeseries,ks)</p><p>Get the value at tvals where the solution is known at the times ts (sorted), with values timeseries and derivatives ks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.ode_interpolation!" href="#OrdinaryDiffEq.ode_interpolation!"><code>OrdinaryDiffEq.ode_interpolation!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ode_interpolation!(out,tval::Number,ts,timeseries,ks)</p><p>Get the value at tval where the solution is known at the times ts (sorted), with values timeseries and derivatives ks</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.reset_alg_dependent_opts!-Tuple{Any,Any,Any}" href="#OrdinaryDiffEq.reset_alg_dependent_opts!-Tuple{Any,Any,Any}"><code>OrdinaryDiffEq.reset_alg_dependent_opts!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If no user default, then this will change the default to the defaults for the second algorithm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OrdinaryDiffEq.ssp_coefficient-Tuple{Any}" href="#OrdinaryDiffEq.ssp_coefficient-Tuple{Any}"><code>OrdinaryDiffEq.ssp_coefficient</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ssp_coefficient(alg)</code></pre><p>Return the SSP coefficient of the ODE algorithm <code>alg</code>. If one time step of size <code>dt</code> with <code>alg</code> can be written as a convex combination of explicit Euler steps with step sizes <code>cᵢ * dt</code>, the SSP coefficient is the minimal value of <code>1/cᵢ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ssp_coefficient(SSPRK104())
6</code></pre></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
