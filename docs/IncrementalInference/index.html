<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · IncrementalInference.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IncrementalInference.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.addFactor!-Union{Tuple{T}, Tuple{R}, Tuple{FactorGraph,Array{ExVertex,1},R}} where T&lt;:AbstractString where R&lt;:Union{FunctorInferenceType, InferenceType}" href="#IncrementalInference.addFactor!-Union{Tuple{T}, Tuple{R}, Tuple{FactorGraph,Array{ExVertex,1},R}} where T&lt;:AbstractString where R&lt;:Union{FunctorInferenceType, InferenceType}"><code>IncrementalInference.addFactor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addFactor!(fgl, Xi, usrfnc; multihypo, ready, api, labels, uid, autoinit, threadmodel)
</code></pre><p>Add factor with user defined type &lt;: FunctorInferenceType to the factor graph object.  Define whether the automatic initialization of variables should be performed.  Use order sensitive <code>multihypo</code> keyword argument to define if any variables are related to data association uncertainty.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.addFactor!-Union{Tuple{T}, Tuple{R}, Tuple{FactorGraph,Array{Symbol,1},R}} where T&lt;:AbstractString where R&lt;:Union{FunctorInferenceType, InferenceType}" href="#IncrementalInference.addFactor!-Union{Tuple{T}, Tuple{R}, Tuple{FactorGraph,Array{Symbol,1},R}} where T&lt;:AbstractString where R&lt;:Union{FunctorInferenceType, InferenceType}"><code>IncrementalInference.addFactor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addFactor!(fgl, xisyms, usrfnc; multihypo, ready, api, labels, uid, autoinit, threadmodel)
</code></pre><p>Add factor with user defined type &lt;: FunctorInferenceType to the factor graph object.  Define whether the automatic initialization of variables should be performed.  Use order sensitive <code>multihypo</code> keyword argument to define if any variables are related to data association uncertainty.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.addNode!-Tuple{FactorGraph,Symbol,Type{#s57} where #s57&lt;:InferenceVariable}" href="#IncrementalInference.addNode!-Tuple{FactorGraph,Symbol,Type{#s57} where #s57&lt;:InferenceVariable}"><code>IncrementalInference.addNode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addNode!(fg, lbl, softtype; N, autoinit, ready, dontmargin, labels, api, uid, smalldata)
</code></pre><p>Add a node (variable) to a graph. Use this over the other dispatches.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.addNode!-Union{Tuple{T}, Tuple{FactorGraph,Symbol,T}} where T&lt;:InferenceVariable" href="#IncrementalInference.addNode!-Union{Tuple{T}, Tuple{FactorGraph,Symbol,T}} where T&lt;:InferenceVariable"><code>IncrementalInference.addNode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addNode!(fg, lbl, softtype; N, autoinit, ready, dontmargin, labels, api, uid, smalldata)
</code></pre><p>Add a node (variable) to a graph. Use this over the other dispatches.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.allnums-Union{Tuple{S}, Tuple{S}} where S&lt;:AbstractString" href="#IncrementalInference.allnums-Union{Tuple{S}, Tuple{S}} where S&lt;:AbstractString"><code>IncrementalInference.allnums</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allnums(str)
</code></pre><p>Test if all elements of the string is a number:  Ex, &quot;123&quot; is true, &quot;1_2&quot; is false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.approxConv-Tuple{FactorGraph,Symbol,Symbol}" href="#IncrementalInference.approxConv-Tuple{FactorGraph,Symbol,Symbol}"><code>IncrementalInference.approxConv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">approxConv(fgl, fct, towards; api, N)
</code></pre><p>Draw samples from the approximate convolution of <code>towards</code> symbol using factor <code>fct</code> relative to the other variables.  In addition the <code>api</code> can be adjusted to recover the data from elsewhere (likely to be replaced/removed in the future).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.batchSolve!-Tuple{FactorGraph}" href="#IncrementalInference.batchSolve!-Tuple{FactorGraph}"><code>IncrementalInference.batchSolve!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">batchSolve!(fgl; drawpdf, show, N, recursive, dbg)
</code></pre><p>Perform multimodal incremental smoothing and mapping (mm-iSAM) computations over given factor graph <code>fgl::FactorGraph</code> on the local computer.  A pdf of the Bayes (Junction) tree will be generated in the working folder with <code>drawpdf=true</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.childCliqs-Tuple{BayesTree,ExVertex}" href="#IncrementalInference.childCliqs-Tuple{BayesTree,ExVertex}"><code>IncrementalInference.childCliqs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">childCliqs(treel, cliq)
</code></pre><p>Return a vector of child cliques to <code>cliq</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.convert2packedfunctionnode" href="#IncrementalInference.convert2packedfunctionnode"><code>IncrementalInference.convert2packedfunctionnode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convert2packedfunctionnode(fgl, fsym)
convert2packedfunctionnode(fgl, fsym, api)
</code></pre><p>Encode complicated function node type to related &#39;Packed&lt;type&gt;&#39; format assuming a user supplied convert function .</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.decodefg-Tuple{FactorGraph}" href="#IncrementalInference.decodefg-Tuple{FactorGraph}"><code>IncrementalInference.decodefg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">decodefg(fgs; api)
</code></pre><p>Unpack PackedFunctionNodeData formats back to regular FunctonNodeData.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.doautoinit!-Tuple{FactorGraph,Array{ExVertex,1}}" href="#IncrementalInference.doautoinit!-Tuple{FactorGraph,Array{ExVertex,1}}"><code>IncrementalInference.doautoinit!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">doautoinit!(fgl, Xi; api, singles, N)
</code></pre><p>initialize destination variable nodes based on this factor in factor graph, fg, generally called during addFactor!. Destination factor is first (singletons) or second (dim 2 pairwise) variable vertex in Xi.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.doautoinit!-Tuple{FactorGraph,Array{Symbol,1}}" href="#IncrementalInference.doautoinit!-Tuple{FactorGraph,Array{Symbol,1}}"><code>IncrementalInference.doautoinit!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">doautoinit!(fgl, xsyms; api, singles, N)
</code></pre><p>Initialize destination variable nodes based on this factor in factor graph, fg, generally called during addFactor!.  Destination factor is first (singletons) or second (dim 2 pairwise) variable vertex in Xi.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.dwnMsg-Tuple{ExVertex}" href="#IncrementalInference.dwnMsg-Tuple{ExVertex}"><code>IncrementalInference.dwnMsg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dwnMsg(cliq)
</code></pre><p>Return the last down message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.emptyFactorGraph-Tuple{}" href="#IncrementalInference.emptyFactorGraph-Tuple{}"><code>IncrementalInference.emptyFactorGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">emptyFactorGraph(; reference)
</code></pre><p>Construct an empty FactorGraph object with the minimum amount of information / memory populated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.encodefg-Tuple{FactorGraph}" href="#IncrementalInference.encodefg-Tuple{FactorGraph}"><code>IncrementalInference.encodefg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">encodefg(fgl; api)
</code></pre><p>Make a full memory copy of the graph and encode all composite function node types – assuming that convert methods for &#39;Packed&lt;type&gt;&#39; formats exist.  The same converters are used for database persistence with CloudGraphs.jl.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.evalFactor2-Tuple{FactorGraph,ExVertex,Int64}" href="#IncrementalInference.evalFactor2-Tuple{FactorGraph,ExVertex,Int64}"><code>IncrementalInference.evalFactor2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evalFactor2(fgl, fct, solvefor; N, dbg)
</code></pre><p>Single entry point for evaluating factors from factor graph, using multiple dispatch to locate the correct <code>evalPotentialSpecific</code> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.fifoFreeze!-Tuple{FactorGraph}" href="#IncrementalInference.fifoFreeze!-Tuple{FactorGraph}"><code>IncrementalInference.fifoFreeze!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fifoFreeze!(fgl)
</code></pre><p>Freeze nodes that are older than the quasi fixed-lag length defined by <code>fg.qfl</code>, according to <code>fg.fifo</code> ordering.</p><p>Future:</p><ul><li>Allow different freezing strategies beyond fifo.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.findRelatedFromPotential" href="#IncrementalInference.findRelatedFromPotential"><code>IncrementalInference.findRelatedFromPotential</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">findRelatedFromPotential(fg, idfct, vertid, N)
findRelatedFromPotential(fg, idfct, vertid, N, dbg)
</code></pre><p>Compute proposal belief on <code>vertid</code> through <code>idfct</code> representing some constraint in factor graph. Always full dimension variable node – partial constraints will only influence subset of variable dimensions. The remaining dimensions will keep pre-existing variable values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCurrentWorkspaceFactors-Tuple{}" href="#IncrementalInference.getCurrentWorkspaceFactors-Tuple{}"><code>IncrementalInference.getCurrentWorkspaceFactors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getCurrentWorkspaceFactors()
</code></pre><p>Return all factors currently registered in the workspace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCurrentWorkspaceVariables-Tuple{}" href="#IncrementalInference.getCurrentWorkspaceVariables-Tuple{}"><code>IncrementalInference.getCurrentWorkspaceVariables</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getCurrentWorkspaceVariables()
</code></pre><p>Return all variables currently registered in the workspace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getKDE-Tuple{ExVertex}" href="#IncrementalInference.getKDE-Tuple{ExVertex}"><code>IncrementalInference.getKDE</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getKDE(v)
</code></pre><p>Get KernelDensityEstimate kde estimate stored in variable node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getNumPts-Tuple{ExVertex}" href="#IncrementalInference.getNumPts-Tuple{ExVertex}"><code>IncrementalInference.getNumPts</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getNumPts(v)
</code></pre><p>Get the number of points used for the current marginal belief estimate represtation for a particular variable in the factor graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getVal-Tuple{ExVertex}" href="#IncrementalInference.getVal-Tuple{ExVertex}"><code>IncrementalInference.getVal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getVal(v)
</code></pre><p>Convenience function to get point values sampled i.i.d from marginal of <code>lbl</code> variable in the current factor graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getVertKDE-Tuple{ExVertex}" href="#IncrementalInference.getVertKDE-Tuple{ExVertex}"><code>IncrementalInference.getVertKDE</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getVertKDE(v)
</code></pre><p>Get KernelDensityEstimate kde estimate stored in variable node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.initializeNode!-Tuple{FactorGraph,Symbol}" href="#IncrementalInference.initializeNode!-Tuple{FactorGraph,Symbol}"><code>IncrementalInference.initializeNode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initializeNode!(fgl, sym; N, api)
</code></pre><p>Initialize the belief of a variable node in the factor graph struct.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.landmarks-Tuple{FactorGraph,Symbol}" href="#IncrementalInference.landmarks-Tuple{FactorGraph,Symbol}"><code>IncrementalInference.landmarks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">landmarks(fgl::FactorGraph, vsym::Symbol)</code></pre><p>Return Vector{Symbol} of landmarks attached to vertex vsym in fgl.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.loadjld-Tuple{}" href="#IncrementalInference.loadjld-Tuple{}"><code>IncrementalInference.loadjld</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">loadjld(; file)
</code></pre><p>Opposite of savejld(fg, gt=gt, file=&quot;tempfg.jl&quot;) to load data from file. This function uses the unpacking converters for converting all PackedInferenceType to FunctorInferenceType.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.localProduct-Tuple{FactorGraph,Symbol}" href="#IncrementalInference.localProduct-Tuple{FactorGraph,Symbol}"><code>IncrementalInference.localProduct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">localProduct(fgl, sym; N, dbg, api)
</code></pre><p>Using factor graph object <code>fg</code>, project belief through connected factors (convolution with conditional) to variable <code>sym</code> followed by a approximate functional product.</p><p>Return: product belief, full proposals, partial dimension proposals, labels</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.ls-Tuple{FactorGraph,Array{Symbol,1}}" href="#IncrementalInference.ls-Tuple{FactorGraph,Array{Symbol,1}}"><code>IncrementalInference.ls</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ls(fgl, lbls; api, ring)
</code></pre><p>Experimental union of elements version of ls(::FactorGraph, ::Symbol).  Not mean&#39;t to replace broadcasting <code>ls.(fg, [:x1;:x2])</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.ls-Tuple{FactorGraph,Symbol}" href="#IncrementalInference.ls-Tuple{FactorGraph,Symbol}"><code>IncrementalInference.ls</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ls(fgl, lbl; api, ring)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.ls-Tuple{FactorGraph}" href="#IncrementalInference.ls-Tuple{FactorGraph}"><code>IncrementalInference.ls</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ls(fgl; key1, key2)
</code></pre><p>List the nodes in a factor graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">ls(fg)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.lsRear" href="#IncrementalInference.lsRear"><code>IncrementalInference.lsRear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lsRear(fgl)
lsRear(fgl, n)
</code></pre><p>Return array of all variable nodes connected to the last <code>n</code> many poses (<code>:x*</code>).</p><p>Example:</p><pre><code class="language-julia"># Shallow copy the tail end of poses from a factor graph `fg1`
vars = lsRear(fg1, 5)
fg1_r5 = subgraphFromVerts(fg1, vars)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.lsf-Tuple{FactorGraph,Symbol}" href="#IncrementalInference.lsf-Tuple{FactorGraph,Symbol}"><code>IncrementalInference.lsf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">lsf(fgl, lbl; api)
</code></pre><p>List factors in a factor graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">lsf(fg)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.manualinit!-Tuple{FactorGraph,Symbol,Array{Symbol,1}}" href="#IncrementalInference.manualinit!-Tuple{FactorGraph,Symbol,Array{Symbol,1}}"><code>IncrementalInference.manualinit!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">manualinit!(fgl, sym, usefcts)
</code></pre><p>Workaround function when first-version (factor graph based) auto initialization fails.  Usually occurs when using factors that have high connectivity to multiple variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.numericRootGenericRandomizedFnc!-Union{Tuple{CommonConvWrapper{T}}, Tuple{T}} where T&lt;:FunctorPairwise" href="#IncrementalInference.numericRootGenericRandomizedFnc!-Union{Tuple{CommonConvWrapper{T}}, Tuple{T}} where T&lt;:FunctorPairwise"><code>IncrementalInference.numericRootGenericRandomizedFnc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">numericRootGenericRandomizedFnc!(ccwl; perturb, testshuffle)
</code></pre><p>Solve free variable x by root finding residual function fgr.usrfnc(x, res) randomly shuffle x dimensions if underconstrained by measurement z dimensions small random perturbation used to prevent trivial solver cases, div by 0 etc. result stored in fgr.Y ccw.X must be set to memory ref the param[varidx] being solved, at creation of ccw</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.parentCliq-Tuple{BayesTree,ExVertex}" href="#IncrementalInference.parentCliq-Tuple{BayesTree,ExVertex}"><code>IncrementalInference.parentCliq</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parentCliq(treel, cliq)
</code></pre><p>Return <code>cliq</code>&#39;s parent clique.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.printgraphmax-Tuple{FactorGraph}" href="#IncrementalInference.printgraphmax-Tuple{FactorGraph}"><code>IncrementalInference.printgraphmax</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">printgraphmax(fgl)
</code></pre><p>Print the maximum point values form all variables approximate marginals in the factor graph. The full marginal can be recovered for example <code>X0 = getVertKDE(fg, :x0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.savejld-Tuple{FactorGraph}" href="#IncrementalInference.savejld-Tuple{FactorGraph}"><code>IncrementalInference.savejld</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">savejld(fgl; file, groundtruth)
</code></pre><p>Save mostly complete Factor Graph type by converting complicated FunctionNodeData types to &#39;Packed&#39; types using user supplied converters. Ground truth can also be saved and recovered by the associated loadjld(file=&quot;tempfg.jld2&quot;) method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setDwnMsg!-Tuple{ExVertex,Dict{Symbol,BallTreeDensity}}" href="#IncrementalInference.setDwnMsg!-Tuple{ExVertex,Dict{Symbol,BallTreeDensity}}"><code>IncrementalInference.setDwnMsg!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setDwnMsg!(cliql, msgs)
</code></pre><p>Set the downward passing message for Bayes (Junction) tree clique <code>cliql</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setUpMsg!-Tuple{ExVertex,Dict{Symbol,BallTreeDensity}}" href="#IncrementalInference.setUpMsg!-Tuple{ExVertex,Dict{Symbol,BallTreeDensity}}"><code>IncrementalInference.setUpMsg!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setUpMsg!(cliql, msgs)
</code></pre><p>Set the upward passing message for Bayes (Junction) tree clique <code>cliql</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.shuffleXAltD!-Tuple{CommonConvWrapper,Array{Float64,1}}" href="#IncrementalInference.shuffleXAltD!-Tuple{CommonConvWrapper,Array{Float64,1}}"><code>IncrementalInference.shuffleXAltD!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">shuffleXAltD!(ccwl, X)
</code></pre><p>Shuffle incoming X into random positions in fr.Y. Shuffled fr.Y will be placed back into fr.X[:,fr.gwp.particleidx] upon fr.gwp.usrfnc(x, res).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.subgraphFromVerts-Tuple{FactorGraph,Union{Array{String,1}, Array{Symbol,1}}}" href="#IncrementalInference.subgraphFromVerts-Tuple{FactorGraph,Union{Array{String,1}, Array{Symbol,1}}}"><code>IncrementalInference.subgraphFromVerts</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">subgraphFromVerts(fgl, verts; neighbors)
</code></pre><p>Explore all shortest paths combinations in verts, add neighbors and reference subgraph using unique index into graph data structure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.treeProductUp-Tuple{FactorGraph,BayesTree,Symbol,Symbol}" href="#IncrementalInference.treeProductUp-Tuple{FactorGraph,BayesTree,Symbol,Symbol}"><code>IncrementalInference.treeProductUp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">treeProductUp(fg, tree, cliq, sym; N, dbg)
</code></pre><p>Calculate a fresh–-single step–-approximation to the variable <code>sym</code> in clique <code>cliq</code> as though during the upward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variable based on the structure of variables, factors, and incoming messages to this clique. Which clique to be used is defined by frontal variable symbols (<code>cliq</code> in this case) – see <code>whichCliq(...)</code> for more details.  The <code>sym</code> symbol indicates which symbol of this clique to be calculated.  <strong>Note</strong> that the <code>sym</code> variable must appear in the clique where <code>cliq</code> is a frontal variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.upMsg-Tuple{ExVertex}" href="#IncrementalInference.upMsg-Tuple{ExVertex}"><code>IncrementalInference.upMsg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">upMsg(cliq)
</code></pre><p>Return the last up message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.whichCliq-Union{Tuple{T}, Tuple{BayesTree,T}} where T&lt;:AbstractString" href="#IncrementalInference.whichCliq-Union{Tuple{T}, Tuple{BayesTree,T}} where T&lt;:AbstractString"><code>IncrementalInference.whichCliq</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">whichCliq(bt, frt)
</code></pre><p>Return the Graphs.ExVertex node object that represents a clique in the Bayes (Junction) tree, as defined by one of the frontal variables <code>frt</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.wipeBuildNewTree!-Tuple{FactorGraph}" href="#IncrementalInference.wipeBuildNewTree!-Tuple{FactorGraph}"><code>IncrementalInference.wipeBuildNewTree!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">wipeBuildNewTree!(fg; ordering, drawpdf, show, filepath, viewerapp)
</code></pre><p>Build a completely new Bayes (Junction) tree, after first wiping clean all temporary state in fg from a possibly pre-existing tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.writeGraphPdf-Union{Tuple{FactorGraph}, Tuple{AS}} where AS&lt;:AbstractString" href="#IncrementalInference.writeGraphPdf-Union{Tuple{FactorGraph}, Tuple{AS}} where AS&lt;:AbstractString"><code>IncrementalInference.writeGraphPdf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">writeGraphPdf(fgl; viewerapp, filepath, engine, show)
</code></pre><p>Export a dot and pdf file drawn by Graphviz showing the factor graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KernelDensityEstimate.kde!-Tuple{EasyMessage}" href="#KernelDensityEstimate.kde!-Tuple{EasyMessage}"><code>KernelDensityEstimate.kde!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">kde!(em)
</code></pre><p>Construct a BallTreeDensity KDE object from an IIF.EasyMessage object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.addNewVarVertInGraph!-Tuple{FactorGraph,ExVertex,Int64,Symbol,Int64,Any}" href="#IncrementalInference.addNewVarVertInGraph!-Tuple{FactorGraph,ExVertex,Int64,Symbol,Int64,Any}"><code>IncrementalInference.addNewVarVertInGraph!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addNewVarVertInGraph!(fgl, vert, id, lbl, ready, smalldata)
</code></pre><p>Initialize a new Graphs.ExVertex which will be added to some factor graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.approxConvOnElements!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Union{UnitRange{Int64}, Array{Int64,1}},Type{MultiThreaded}}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}" href="#IncrementalInference.approxConvOnElements!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Union{UnitRange{Int64}, Array{Int64,1}},Type{MultiThreaded}}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}"><code>IncrementalInference.approxConvOnElements!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">approxConvOnElements!(ccwl, elements, ?)
</code></pre><p>Perform the nonlinear numerical operations to approximate the convolution with a particular user defined likelihood function (conditional), which as been prepared in the <code>frl</code> object.  This function uses root finding to enforce a non-linear function constraint.</p><p>Notes:</p><ul><li>remember this is a deepcopy of original sfidx, since we are generating a proposal distribution and not directly replacing the existing variable belief estimate</li></ul><p>Future work:</p><ul><li>once Threads.@threads have been optmized JuliaLang/julia#19967, also see area4 branch</li><li>improve handling of n and particleidx, especially considering future multithreading support</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.approxConvOnElements!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Union{UnitRange{Int64}, Array{Int64,1}},Type{SingleThreaded}}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}" href="#IncrementalInference.approxConvOnElements!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Union{UnitRange{Int64}, Array{Int64,1}},Type{SingleThreaded}}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}"><code>IncrementalInference.approxConvOnElements!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">approxConvOnElements!(ccwl, elements, ?)
</code></pre><p>Perform the nonlinear numerical operations to approximate the convolution with a particular user defined likelihood function (conditional), which as been prepared in the <code>frl</code> object.  This function uses root finding to enforce a non-linear function constraint.</p><p>Notes:</p><ul><li>remember this is a deepcopy of original sfidx, since we are generating a proposal distribution and not directly replacing the existing variable belief estimate</li></ul><p>Future work:</p><ul><li>once Threads.@threads have been optmized JuliaLang/julia#19967, also see area4 branch</li><li>improve handling of n and particleidx, especially considering future multithreading support</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.approxConvOnElements!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Union{UnitRange{Int64}, Array{Int64,1}}}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}" href="#IncrementalInference.approxConvOnElements!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Union{UnitRange{Int64}, Array{Int64,1}}}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}"><code>IncrementalInference.approxConvOnElements!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">approxConvOnElements!(ccwl, elements)
</code></pre><p>Perform the nonlinear numerical operations to approximate the convolution with a particular user defined likelihood function (conditional), which as been prepared in the <code>frl</code> object.  This function uses root finding to enforce a non-linear function constraint.</p><p>Notes:</p><ul><li>remember this is a deepcopy of original sfidx, since we are generating a proposal distribution and not directly replacing the existing variable belief estimate</li></ul><p>Future work:</p><ul><li>once Threads.@threads have been optmized JuliaLang/julia#19967, also see area4 branch</li><li>improve handling of n and particleidx, especially considering future multithreading support</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.assembleHypothesesElements!-Tuple{Categorical,Int64,Int64,Int64}" href="#IncrementalInference.assembleHypothesesElements!-Tuple{Categorical,Int64,Int64,Int64}"><code>IncrementalInference.assembleHypothesesElements!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">assembleHypothesesElements!(mh, maxlen, sfidx, lenXi)
</code></pre><p>This function explicitly codes that marginalization of a discrete categorical selection variable for ambiguous data association situations.  Improved implementations should implicitly induce the same behaviour through summation (integration) when marginalizing any number of discrete variables.  This function populates <code>allelements</code> with particle indices associated with particular multihypothesis selection while <code>activehypo</code> simultaneously contains the hypothesis index and factor graph variables associated with that hypothesis selection.  The return value <code>certainidx</code> are the hypotheses that are not in question.</p><pre><code class="language-none"># `allelements` example BearingRange [:x1, 0.5:l1a, 0.5:l1b]
# sfidx = (1=:x1,2=:l1a,3=:l1b)
if solvefor :x1, then allelem = [mhidx.==:l1a; mhidx.==l1b]
if solvefor :l1a, then allelem = [mhidx.==:l1a] and ARR[solvefor][:,mhidx.==:l1b]=ARR[:l1b][:,mhidx.==:l1b]
if solvefor :l1b, then allelem = [mhidx.==:l1b] and ARR[solvefor][:,mhidx.==:l1a]=ARR[:l1a][:,mhidx.==:l1a]
if solvefor 1, then allelem = [mhidx.==2; mhidx.==3]
if solvefor 2, then allelem = [mhidx.==2] and ARR[solvefor][:,mhidx.==3]=ARR[3][:,mhidx.==3]
if solvefor 3, then allelem = [mhidx.==3] and ARR[solvefor][:,mhidx.==2]=ARR[2][:,mhidx.==2]

# `activehypo` in example mh=[1.0;0.5;0.5]
sfidx=1, mhidx=2:  ah = [1;2]
sfidx=1, mhidx=3:  ah = [1;3]
sfidx=2, mhidx=2:  ah = [1;2]
sfidx=2, mhidx=3:  2 should take a value from 3
sfidx=3, mhidx=2:  3 should take a value from 2
sfidx=3, mhidx=3:  ah = [1;3]

# `activehypo` in example mh=[1.0;0.33;0.33;0.34]
sfidx=1, mhidx=2:  ah = [1;2]
sfidx=1, mhidx=3:  ah = [1;3]
sfidx=1, mhidx=4:  ah = [1;4]

sfidx=2, mhidx=2:  ah = [1;2]
sfidx=2, mhidx=3:  2 should take a value from 3
sfidx=2, mhidx=4:  2 should take a value from 4

sfidx=3, mhidx=2:  3 should take a value from 2
sfidx=3, mhidx=3:  ah = [1;3]
sfidx=3, mhidx=4:  3 should take a value from 4

sfidx=4, mhidx=2:  4 should take a value from 2
sfidx=4, mhidx=3:  4 should take a value from 3
sfidx=4, mhidx=4:  ah = [1;4]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.assembleNullHypothesis-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Int64,Float64}} where T" href="#IncrementalInference.assembleNullHypothesis-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Int64,Float64}} where T"><code>IncrementalInference.assembleNullHypothesis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">assembleNullHypothesis(ccwl, maxlen, spreadfactor)
</code></pre><p>Prepare data required for null hypothesis cases during convolution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.cliqGibbs-Tuple{FactorGraph,ExVertex,Int64,Array{NBPMessage,1},Int64,Bool}" href="#IncrementalInference.cliqGibbs-Tuple{FactorGraph,ExVertex,Int64,Array{NBPMessage,1},Int64,Bool}"><code>IncrementalInference.cliqGibbs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cliqGibbs(fg, cliq, vertid, inmsgs, N, dbg)
</code></pre><p>Perform one step of the minibatch clique Gibbs operation for solving the Chapman-Kolmogov trasit integral – here involving separate approximate functional convolution and product operations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.computeAcrossHypothesis!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Any,Any,Any,Any}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}" href="#IncrementalInference.computeAcrossHypothesis!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Any,Any,Any,Any}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}"><code>IncrementalInference.computeAcrossHypothesis!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">computeAcrossHypothesis!(ccwl, allelements, activehypo, certainidx, sfidx)
</code></pre><p>Common function to compute across a single user defined multi-hypothesis ambiguity per factor.  This function dispatches both <code>FunctorPairwise</code> and <code>FunctorPairwiseMinimize</code> factors.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.computeAcrossNullHypothesis!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Any,Any,Any}} where T&lt;:FunctorPairwiseNH" href="#IncrementalInference.computeAcrossNullHypothesis!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Any,Any,Any}} where T&lt;:FunctorPairwiseNH"><code>IncrementalInference.computeAcrossNullHypothesis!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">computeAcrossNullHypothesis!(ccwl, allelements, nhc, ENT)
</code></pre><p>Do true and null hypothesis computations based on data structures prepared earlier – specific to <code>FunctorPairwiseNH</code>.  This function will be merged into a standard case for <code>FunctorPairwise/Minimize</code> in the future.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.downMsgPassingRecursive-Tuple{ExploreTreeType}" href="#IncrementalInference.downMsgPassingRecursive-Tuple{ExploreTreeType}"><code>IncrementalInference.downMsgPassingRecursive</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">downMsgPassingRecursive(inp; N, dbg, drawpdf)
</code></pre><p>Pass NBPMessages back down the tree – pre order tree traversal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.evalPotentialSpecific-Union{Tuple{T}, Tuple{Array{ExVertex,1},CommonConvWrapper{T},Int64}} where T&lt;:FunctorSingleton" href="#IncrementalInference.evalPotentialSpecific-Union{Tuple{T}, Tuple{Array{ExVertex,1},CommonConvWrapper{T},Int64}} where T&lt;:FunctorSingleton"><code>IncrementalInference.evalPotentialSpecific</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evalPotentialSpecific(Xi, ccwl, solvefor; N, dbg)
</code></pre><p>Multiple dispatch wrapper for evaluating the <code>ccwl::CommonConvWrapper{&lt;: FunctorSingleton}</code> types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.evalPotentialSpecific-Union{Tuple{T}, Tuple{Array{ExVertex,1},CommonConvWrapper{T},Int64}} where T&lt;:FunctorSingletonNH" href="#IncrementalInference.evalPotentialSpecific-Union{Tuple{T}, Tuple{Array{ExVertex,1},CommonConvWrapper{T},Int64}} where T&lt;:FunctorSingletonNH"><code>IncrementalInference.evalPotentialSpecific</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evalPotentialSpecific(Xi, ccwl, solvefor; N, spreadfactor, dbg)
</code></pre><p>Multiple dispatch wrapper for evaluating the <code>ccwl::CommonConvWrapper{&lt;: FunctorSingletonNH}</code> types. Planned changes will fold null hypothesis in as a standard feature and no longer appear as a separate <code>InferenceType</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.evalPotentialSpecific-Union{Tuple{T}, Tuple{Array{ExVertex,1},CommonConvWrapper{T},Int64}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}" href="#IncrementalInference.evalPotentialSpecific-Union{Tuple{T}, Tuple{Array{ExVertex,1},CommonConvWrapper{T},Int64}} where T&lt;:Union{FunctorPairwise, FunctorPairwiseMinimize}"><code>IncrementalInference.evalPotentialSpecific</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evalPotentialSpecific(Xi, ccwl, solvefor; N, dbg)
</code></pre><p>Multiple dispatch wrapper for <code>&lt;:FunctorPairwise</code> types, to prepare and execute the general approximate convolution with user defined factor residual functions.  This method also supports multihypothesis operations as one mechanism to introduce new modality into the proposal beliefs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.fmcmc!" href="#IncrementalInference.fmcmc!"><code>IncrementalInference.fmcmc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fmcmc!(fgl, cliq, fmsgs, IDs, N, MCMCIter)
fmcmc!(fgl, cliq, fmsgs, IDs, N, MCMCIter, dbg)
</code></pre><p>Iterate successive approximations of clique marginal beliefs by means of the stipulated proposal convolutions and products of the functional objects for tree clique <code>cliq</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.packFromLocalPotentials!" href="#IncrementalInference.packFromLocalPotentials!"><code>IncrementalInference.packFromLocalPotentials!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">packFromLocalPotentials!(fgl, dens, wfac, cliq, vertid, N)
packFromLocalPotentials!(fgl, dens, wfac, cliq, vertid, N, dbg)
</code></pre><p>Add all potentials associated with this clique and vertid to dens.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.prepareCommonConvWrapper!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Array{ExVertex,1},Int64,Int64}} where T&lt;:FunctorInferenceType" href="#IncrementalInference.prepareCommonConvWrapper!-Union{Tuple{T}, Tuple{CommonConvWrapper{T},Array{ExVertex,1},Int64,Int64}} where T&lt;:FunctorInferenceType"><code>IncrementalInference.prepareCommonConvWrapper!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">prepareCommonConvWrapper!(ccwl, Xi, solvefor, N)
</code></pre><p>Prepare a common functor computation object <code>prepareCommonConvWrapper{T}</code> containing the user factor functor along with additional variables and information using during approximate convolution computations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.prepareparamsarray!-Tuple{Array{Array{Float64,2},1},Array{ExVertex,1},Int64,Int64}" href="#IncrementalInference.prepareparamsarray!-Tuple{Array{Array{Float64,2},1},Array{ExVertex,1},Int64,Int64}"><code>IncrementalInference.prepareparamsarray!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">prepareparamsarray!(ARR, Xi, N, solvefor)
</code></pre><p>Prepare the particle arrays <code>ARR</code> to be used for approximate convolution.  This function ensures that ARR has te same dimensions among all the parameters.  Function returns with ARR[sfidx] pointing at newly allocated deepcopy of the existing values in getVal(Xi[.index==solvefor]).  Return values <code>sfidx</code> is the element in ARR where <code>Xi.index==solvefor</code> and <code>maxlen</code> is length of all (possibly resampled) <code>ARR</code> contained particles.  Note <code>Xi</code> is order sensitive.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.prodmultiplefullpartials-Tuple{Array{BallTreeDensity,1},Dict{Int64,Array{BallTreeDensity,1}},Int64,Int64}" href="#IncrementalInference.prodmultiplefullpartials-Tuple{Array{BallTreeDensity,1},Dict{Int64,Array{BallTreeDensity,1}},Int64,Int64}"><code>IncrementalInference.prodmultiplefullpartials</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">prodmultiplefullpartials(dens, partials, Ndims, N)
</code></pre><p>Multiply various full and partial dimension constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.prodmultipleonefullpartials-Tuple{Array{BallTreeDensity,1},Dict{Int64,Array{BallTreeDensity,1}},Int64,Int64}" href="#IncrementalInference.prodmultipleonefullpartials-Tuple{Array{BallTreeDensity,1},Dict{Int64,Array{BallTreeDensity,1}},Int64,Int64}"><code>IncrementalInference.prodmultipleonefullpartials</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">prodmultipleonefullpartials(dens, partials, Ndims, N)
</code></pre><p>Multiply a single full and several partial dimension constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.productpartials!-Tuple{Array{Float64,2},BallTreeDensity,Dict{Int64,Array{BallTreeDensity,1}}}" href="#IncrementalInference.productpartials!-Tuple{Array{Float64,2},BallTreeDensity,Dict{Int64,Array{BallTreeDensity,1}}}"><code>IncrementalInference.productpartials!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">productpartials!(pGM, dummy, partials)
</code></pre><p>Multiply different dimensions from partial constraints individually.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setfreeze!-Tuple{FactorGraph,Symbol}" href="#IncrementalInference.setfreeze!-Tuple{FactorGraph,Symbol}"><code>IncrementalInference.setfreeze!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setfreeze!(fgl, sym)
</code></pre><p>Set variable(s) <code>sym</code> of factor graph to be marginalized – i.e. not be updated by inference computation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.treeProductDwn-Tuple{FactorGraph,BayesTree,Symbol,Symbol}" href="#IncrementalInference.treeProductDwn-Tuple{FactorGraph,BayesTree,Symbol,Symbol}"><code>IncrementalInference.treeProductDwn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">treeProductDwn(fg, tree, cliq, sym; N, dbg)
</code></pre><p>Calculate a fresh–-single step–-approximation to the variable <code>sym</code> in clique <code>cliq</code> as though during the downward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variable based on the structure of variables, factors, and incoming messages to this clique. Which clique to be used is defined by frontal variable symbols (<code>cliq</code> in this case) – see <code>whichCliq(...)</code> for more details.  The <code>sym</code> symbol indicates which symbol of this clique to be calculated.  <strong>Note</strong> that the <code>sym</code> variable must appear in the clique where <code>cliq</code> is a frontal variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.upGibbsCliqueDensity" href="#IncrementalInference.upGibbsCliqueDensity"><code>IncrementalInference.upGibbsCliqueDensity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">upGibbsCliqueDensity(inp)
upGibbsCliqueDensity(inp, N)
upGibbsCliqueDensity(inp, N, dbg)
</code></pre><p>Perform computations required for the upward message passing during belief propation on the Bayes (Junction) tree. This function is usually called as part via remote_call for multiprocess dispatch.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.updateFGBT!-Tuple{FactorGraph,BayesTree,Int64,IncrementalInference.DownReturnBPType}" href="#IncrementalInference.updateFGBT!-Tuple{FactorGraph,BayesTree,Int64,IncrementalInference.DownReturnBPType}"><code>IncrementalInference.updateFGBT!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">updateFGBT!(fg, bt, cliqID, ddt; dbg, fillcolor)
</code></pre><p>Update cliq <code>cliqID</code> in Bayes (Juction) tree <code>bt</code> according to contents of <code>ddt</code> – intended use is to update main clique after a downward belief propagation computation has been completed per clique.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.updateFGBT!-Tuple{FactorGraph,BayesTree,Int64,IncrementalInference.UpReturnBPType}" href="#IncrementalInference.updateFGBT!-Tuple{FactorGraph,BayesTree,Int64,IncrementalInference.UpReturnBPType}"><code>IncrementalInference.updateFGBT!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">updateFGBT!(fg, bt, cliqID, urt; dbg, fillcolor)
</code></pre><p>Update cliq <code>cliqID</code> in Bayes (Juction) tree <code>bt</code> according to contents of <code>urt</code> – intended use is to update main clique after a upward belief propagation computation has been completed per clique.</p></div></div></section><footer><hr/></footer></article></body></html>
