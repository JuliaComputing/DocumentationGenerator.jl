<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Homebrew.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Homebrew.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.BrewPkg" href="#Homebrew.BrewPkg"><code>Homebrew.BrewPkg</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>BrewPkg</code></p><p>A simple type to give us some nice ways of representing our packages to the user</p><p>It contains important information such as the <code>name</code> of the package, the <code>tap</code> it came from, the <code>version</code> of the package and whether it was <code>translated</code> or not</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,Homebrew.BrewPkg}" href="#Base.show-Tuple{IO,Homebrew.BrewPkg}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>show(io::IO, b::BrewPkg)</code></p><p>Writes a <code>BrewPkg</code> to <code>io</code>, showing tap, name and version number</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.__init__-Tuple{}" href="#Homebrew.__init__-Tuple{}"><code>Homebrew.__init__</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>__init__()</code></p><p>Initialization function.  Calls <code>install_brew()</code> to ensure that everything we need is downloaded/installed, then calls <code>update_env()</code> to set the environment properly so that packages being installed can find their binaries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.add-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.add-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.add</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>add(pkg::Union{AbstractString,BrewPkg}; verbose::Bool=false, keep_translations::Bool=false)</code></p><p>Install package <code>pkg</code> and all dependencies, using bottles only, unlinking any previous versions if necessary, and linking the new ones in place. Will attempt to install non-relocatable bottles from <code>Homebrew/core</code> by translating formulae and forcing <code>cellar :any</code> into the formulae.</p><p>Automatically deletes all translated formulae before adding formulae and after, unless <code>keep_translations</code> is set to <code>true</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.add_flags-Tuple{Cmd,Dict{Cmd,Bool}}" href="#Homebrew.add_flags-Tuple{Cmd,Dict{Cmd,Bool}}"><code>Homebrew.add_flags</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>add_flags(cmd::AbstractString, flags::Dict{String,Bool})</code></p><p>Given a mapping of flags to Bools, return [cmd, flag1, flag2...] if the respective Bools are true.  Useful for adding <code>--verbose</code> and <code>--force</code> flags onto the end of commands</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.brew-Tuple{Cmd}" href="#Homebrew.brew-Tuple{Cmd}"><code>Homebrew.brew</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>brew(cmd::Cmd; no_stderr=false, no_stdout=false, verbose=false, force=false, quiet=false)</code></p><p>Run command <code>cmd</code> using the configured brew binary, optionally suppressing stdout and stderr, and providing flags such as <code>--verbose</code> to the brew binary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.brewchomp-Tuple{Cmd}" href="#Homebrew.brewchomp-Tuple{Cmd}"><code>Homebrew.brewchomp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>brewchomp(cmd::Cmd; no_stderr=false, no_stdout=false, verbose=false, force=false, quiet=false))</code></p><p>Run command <code>cmd</code> using the configured brew binary, optionally suppressing stdout and stderr, and providing flags such as <code>--verbose</code> to the brew binary.</p><p>This function uses <code>readchomp()</code>, as opposed to <code>brew()</code> which uses <code>run()</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.cleanup-Tuple{}" href="#Homebrew.cleanup-Tuple{}"><code>Homebrew.cleanup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>cleanup()</code></p><p>Cleans up old installed versions of formulae, as well as purging all downloaded bottles</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.clt_installed-Tuple{}" href="#Homebrew.clt_installed-Tuple{}"><code>Homebrew.clt_installed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>clt_installed()</code></p><p>Checks whether the command-line tools are installed, as reported by xcode-select</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.delete_all_translated_formulae-Tuple{}" href="#Homebrew.delete_all_translated_formulae-Tuple{}"><code>Homebrew.delete_all_translated_formulae</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>delete_all_translated_formulae(;verbose::Bool=false)</code></p><p>Delete all translated formulae from the <code>staticfloat/juliatranslated</code> tap. This is useful for debugging misbehaving formulae during translation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.delete_translated_formula-Tuple{AbstractString}" href="#Homebrew.delete_translated_formula-Tuple{AbstractString}"><code>Homebrew.delete_translated_formula</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>delete_translated_formula(name::AbstractString; verbose::Bool=false)</code></p><p>Delete a translated formula from the <code>staticfloat/juliatranslated</code> tap.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.deps_sorted-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.deps_sorted-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.deps_sorted</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>deps_sorted(pkg::Union{AbstractString,BrewPkg}; build_deps::Bool)</code></p><p>Return a sorted <code>Vector{BrewPkg}</code> of all dependencies (direct and indirect) such that each entry in the list appears after all of its own dependencies.</p><p>If <code>build_deps</code> is <code>true</code> include formula depependencies marked as <code>:build</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.deps_tree-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.deps_tree-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.deps_tree</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>deps_tree(pkg::Union{AbstractString,BrewPkg}; build_deps::Bool=false)</code></p><p>Return a dictionary mapping every dependency (both direct and indirect) of <code>pkg</code> to a <code>Vector{BrewPkg}</code> of all of its dependencies.  Used in <code>deps_sorted()</code>.</p><p>If <code>build_deps</code> is <code>true</code> include formula depependencies marked as <code>:build</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.direct_deps-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.direct_deps-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.direct_deps</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>direct_deps(pkg::Union{AbstractString,BrewPkg}; build_deps::Bool=false)</code></p><p>Return a list of all direct dependencies of <code>pkg</code> as a <code>Vector{BrewPkg}</code> If <code>build_deps</code> is <code>true</code> include formula depependencies marked as <code>:build</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.download_and_unpack-Tuple{AbstractString,AbstractString}" href="#Homebrew.download_and_unpack-Tuple{AbstractString,AbstractString}"><code>Homebrew.download_and_unpack</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>download_and_unpack(url::AbstractString, target_dir::AbstractString)</code></p><p>Download a tarball from <code>url</code> and unpack it into <code>target_dir</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.formula_path-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.formula_path-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.formula_path</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>formula_path(pkg::Union{AbstractString,BrewPkg})</code></p><p>Returns the absolute path on-disk of the given package <code>pkg</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.formula_tap-Tuple{AbstractString}" href="#Homebrew.formula_tap-Tuple{AbstractString}"><code>Homebrew.formula_tap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>formula_tap(name::AbstractString)</code></p><p>Given a formula <code>name</code>, return the formula name and the tap it is from, replacing &quot;&quot; for &quot;Homebrew/core&quot;, as we don&#39;t care about that particular prefix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.fullname-Tuple{Homebrew.BrewPkg}" href="#Homebrew.fullname-Tuple{Homebrew.BrewPkg}"><code>Homebrew.fullname</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>fullname(pkg::BrewPkg)</code></p><p>Return the fully-qualified name for a package, dropping &quot;Homebrew/core&quot;</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.git_installed-Tuple{}" href="#Homebrew.git_installed-Tuple{}"><code>Homebrew.git_installed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>git_installed()</code></p><p>Checks whether <code>git</code> is truly installed or not, dealing with stubs in /usr/bin Also ensure that the version is new enough (e.g. &gt;= 2.0.0.0) that it will work with <code>git fetch --unshallow</code> on Homebrew.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.has_bottle-Tuple{AbstractString}" href="#Homebrew.has_bottle-Tuple{AbstractString}"><code>Homebrew.has_bottle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>has_bottle(name::AbstractString)</code></p><p>Checks if a given formula has a bottle at all</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.has_relocatable_bottle-Tuple{AbstractString}" href="#Homebrew.has_relocatable_bottle-Tuple{AbstractString}"><code>Homebrew.has_relocatable_bottle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>has_relocatable_bottle(name::AbstractString)</code></p><p>Checks to see if a given formula has a bottle that can be installed anywhere</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.info-Tuple{AbstractString}" href="#Homebrew.info-Tuple{AbstractString}"><code>Homebrew.info</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>info(name::AbstractString)</code></p><p>Returns information about a particular package name as a BrewPkg.  This is our basic <code>String</code> -&gt; <code>BrewPkg</code> converter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.info-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString" href="#Homebrew.info-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString"><code>Homebrew.info</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>info(names::Vector{String})</code></p><p>For each name in <code>names</code>, returns information about that particular package name as a BrewPkg.  This is our batched <code>String</code> -&gt; <code>BrewPkg</code> converter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.insert_after_dependencies-Tuple{Dict,Array{Homebrew.BrewPkg,1},AbstractString}" href="#Homebrew.insert_after_dependencies-Tuple{Dict,Array{Homebrew.BrewPkg,1},AbstractString}"><code>Homebrew.insert_after_dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>insert_after_dependencies(tree::Dict, sorted_deps::Vector{BrewPkg}, name::AbstractString)</code></p><p>Given a mapping from names to dependencies in <code>tree</code>, and a list of sorted dependencies in <code>sorted_deps</code>, insert a new dependency <code>name</code> into <code>sorted_deps</code> after all dependencies of <code>name</code>.  If a dependency of <code>name</code> is not already in <code>sorted_deps</code>, then recursively add that dependency as well.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.install_and_link-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.install_and_link-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.install_and_link</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>install_and_link(pkg::Union{AbstractString,BrewPkg}; verbose=false)</code></p><p>Installs, and links package <code>pkg</code>.  Used by <code>add()</code>.  Don&#39;t call manually unless you really know what you&#39;re doing, as this doesn&#39;t deal with dependencies, and so can trigger compilation when you don&#39;t want it to.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.install_brew-Tuple{}" href="#Homebrew.install_brew-Tuple{}"><code>Homebrew.install_brew</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>install_brew()</code></p><p>Ensures that Homebrew is installed as desired, that our basic Taps are available and that we have whatever binary tools we need, such as <code>install_name_tool</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.installed-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.installed-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.installed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>installed(pkg::Union{AbstractString,BrewPkg})</code></p><p>Return true if the given package <code>pkg</code> is a directory in the Cellar, showing that it has been installed (but possibly not linked, see <code>linked()</code>)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.json-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.json-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.json</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>json(pkg::Union{AbstractString,BrewPkg})</code></p><p>Return the full JSON object for <code>pkg</code>, the result of <code>brew info --json=v1 $pkg</code>. If <code>brew info</code> fails, throws an error.  If <code>brew info</code> returns an empty object, (e.g. &quot;[]&quot;), this returns an empty Dict.</p><p>Note that running <code>brew info --json=v1</code> is somewhat expensive, so we cache the results in a global dictionary, and batching larger requests with the vectorized <code>json()</code> function similarly increases performance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.json-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString" href="#Homebrew.json-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString"><code>Homebrew.json</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>json(names::Vector{AbstractString})</code></p><p>For each package name in <code>names</code>, return the full JSON object for <code>name</code>, the result of <code>brew info --json=v1 $name</code>, stored in a dictionary keyed by the names passed into this function. If <code>brew info</code> fails, throws an error. If <code>brew info</code> returns an empty object &quot;[]&quot;, that object is represented by an empty dictionary.</p><p>Note that running <code>brew info --json=v1</code> is somewhat expensive, so we cache the results in a global dictionary, and batching larger requests with this function similarly increases performance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.link-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.link-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.link</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>link(pkg::Union{AbstractString,BrewPkg}; verbose=false, force=true)</code></p><p>Link package <code>name</code> into the global namespace, uses <code>--force</code> if <code>force == true</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.linked-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.linked-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.linked</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>linked(pkg::Union{AbstractString,BrewPkg})</code></p><p>Returns true if the given package <code>pkg</code> is linked to LinkedKegs, signifying all files installed by this package have been linked into the global prefix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.list-Tuple{}" href="#Homebrew.list-Tuple{}"><code>Homebrew.list</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>list()</code></p><p>Returns a list of all installed packages as a <code>Vector{BrewPkg}</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.outdated-Tuple{}" href="#Homebrew.outdated-Tuple{}"><code>Homebrew.outdated</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>outdated()</code></p><p>Returns a list of all installed packages that are out of date as a <code>Vector{BrewPkg}</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.postinstall-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.postinstall-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.postinstall</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>postinstall(pkg::Union{AbstractString,BrewPkg}; verbose=false)</code></p><p>Runs <code>brew postinstall</code> against package <code>pkg</code>, useful for debugging complicated formulae when a bottle doesn&#39;t install right and you want to re-run postinstall.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.prefix-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.prefix-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.prefix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>prefix(pkg::Union{AbstractString,BrewPkg})</code></p><p>Returns the prefix for a particular package&#39;s latest installed version.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.prefix-Tuple{}" href="#Homebrew.prefix-Tuple{}"><code>Homebrew.prefix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>prefix()</code></p><p>Returns <code>brew_prefix</code>, the location where all Homebrew files are stored.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.read_formula-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.read_formula-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.read_formula</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>read_formula(pkg::Union{AbstractString,BrewPkg})</code></p><p>Returns the string contents of a package&#39;s formula.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.refresh!-Tuple{}" href="#Homebrew.refresh!-Tuple{}"><code>Homebrew.refresh!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>refresh!(;verbose=false)</code></p><p>Forcibly remove all packages and add them again.  This should only be used to fix a broken installation, normal operation should never need to use this.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.rm-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.rm-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.rm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>rm(pkg::Union{AbstractString,BrewPkg}; verbose::Bool=false, force::Bool=true)</code></p><p>Remove package <code>pkg</code>, use <code>--force</code> if <code>force</code> == <code>true</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.rm-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Union{AbstractString, BrewPkg}" href="#Homebrew.rm-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Union{AbstractString, BrewPkg}"><code>Homebrew.rm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>rm(pkgs::Vector{String or BrewPkg}; verbose::Bool=false, force::Bool=true)</code></p><p>Remove packages <code>pkgs</code>, use <code>--force</code> if <code>force</code> == <code>true</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.tap-Tuple{AbstractString}" href="#Homebrew.tap-Tuple{AbstractString}"><code>Homebrew.tap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>tap(tap_name::AbstractString; full::Bool=true, verbose::Bool=false)</code></p><p>Runs <code>brew tap $tap_name</code> if the tap does not already exist.  If <code>full</code> is <code>true</code> adds the flag <code>--full</code> to clone a full tap instead of Homebrew&#39;s default shallow.</p><p>If <code>git</code> is not available, manually tap it with curl and tar.  This tap will be unshallowed at the next <code>brew update</code> when <code>git</code> is available.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.tap_exists-Tuple{AbstractString}" href="#Homebrew.tap_exists-Tuple{AbstractString}"><code>Homebrew.tap_exists</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>tap_exists(tap_name::AbstractString)</code></p><p>Check to see if a tap called <code>tap_name</code> (ex: <code>&quot;staticfloat/juliadeps&quot;</code>) exists</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.translate_formula-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.translate_formula-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.translate_formula</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>translate_formula(pkg::Union{AbstractString,BrewPkg}; verbose::Bool=false)</code></p><p>Given a formula <code>name</code>, return the fully-qualified name of a translated formula if it is translatable.  Translation copies a <code>Homebrew/core</code> formula to <code>staticfloat/juliatranslated</code>, adding appropriate <code>cellar :any</code> and <code>root_url</code> lines to any bottle stanzas.  This allows us to transparently install non-cellar-any formulae from <code>Homebrew/core</code>.</p><p>This function is fairly strict, bailing out at every possible opportunity, and returning the original name.  If a formula is non-translatable, it&#39;s possible it needs manual intervention, check out the staticfloat/juliadeps tap for examples.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.unlink-Tuple{Union{AbstractString, BrewPkg}}" href="#Homebrew.unlink-Tuple{Union{AbstractString, BrewPkg}}"><code>Homebrew.unlink</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>unlink(pkg::Union{AbstractString,BrewPkg}; verbose::Bool=false, quiet::Bool=true)</code></p><p>Unlink package <code>pkg</code> from the global namespace, uses <code>--quiet</code> if <code>quiet == true</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.update-Tuple{}" href="#Homebrew.update-Tuple{}"><code>Homebrew.update</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>update(;verbose::Bool=false)</code></p><p>Runs <code>brew update</code> to update Homebrew itself and all taps.  Then runs <code>upgrade()</code> to upgrade all formulae that have fallen out of date.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.update_env-Tuple{}" href="#Homebrew.update_env-Tuple{}"><code>Homebrew.update_env</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>update_env()</code></p><p>Updates environment variables PATH and HOMEBREW<em>CACHE, and modifies DL</em>LOAD_PATH to point to our Homebrew installation, allowing us to use things inside of Homebrew transparently. This causes BinDeps to find the binaries during Pkg.build() time, writing the absolute path into <code>deps/deps.jl</code>.  Because the paths are written into <code>deps/deps.jl</code>, packages do not need to load in the entire Homebrew package just to find their dependencies.</p><p>HOMEBREW_CACHE stores our bottle download cache in a separate place, separating ourselves from other Homebrew installations so we don&#39;t conflict with anyone</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.update_tag-Tuple{}" href="#Homebrew.update_tag-Tuple{}"><code>Homebrew.update_tag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>update_tag(;verbose::Bool = false)</code></p><p>We maintain our own &quot;stable&quot; tag that overrides Homebrew so that we can update at our own pace along with them.  Make sure to call <code>update_env()</code> before calling this, as calling our <code>git</code> doesn&#39;t work properly otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.upgrade-Tuple{}" href="#Homebrew.upgrade-Tuple{}"><code>Homebrew.upgrade</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>upgrade(;verbose::Bool=false)</code></p><p>Iterate over all packages returned from <code>outdated()</code>, removing the old version and adding a new one.  Note that we do not simply call <code>brew upgrade</code> here, as we have special logic inside of <code>add()</code> to install from our tap before trying to install from mainline Homebrew.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homebrew.write_formula-Tuple{AbstractString,AbstractString}" href="#Homebrew.write_formula-Tuple{AbstractString,AbstractString}"><code>Homebrew.write_formula</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>write_formula(name::AbstractString, formula::AbstractString)</code></p><p>Write out fully-qualified formula <code>name</code> with contents <code>formula</code> to disk. Note that writing out without a tap name is not allowed; we won&#39;t write new formulae out to <code>Homebrew/core</code>, only to taps.</p></div></div></section><footer><hr/></footer></article></body></html>
