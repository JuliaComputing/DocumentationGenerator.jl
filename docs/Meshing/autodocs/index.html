<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Meshing.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Meshing.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.marching_cubes-Union{Tuple{SignedDistanceField{3,ST,FT}}, Tuple{M}, Tuple{FT}, Tuple{ST}, Tuple{SignedDistanceField{3,ST,FT},Any}, Tuple{SignedDistanceField{3,ST,FT},Any,Type{M}}, Tuple{SignedDistanceField{3,ST,FT},Any,Type{M},Any}} where M&lt;:GeometryTypes.AbstractMesh where FT where ST" href="#Meshing.marching_cubes-Union{Tuple{SignedDistanceField{3,ST,FT}}, Tuple{M}, Tuple{FT}, Tuple{ST}, Tuple{SignedDistanceField{3,ST,FT},Any}, Tuple{SignedDistanceField{3,ST,FT},Any,Type{M}}, Tuple{SignedDistanceField{3,ST,FT},Any,Type{M},Any}} where M&lt;:GeometryTypes.AbstractMesh where FT where ST"><code>Meshing.marching_cubes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>marching_cubes(sdf::SignedDistanceField, [iso = 0.0,] [MT = HomogenousMesh{Point{3,Float64},Face{3,Int}}])</code></p><p>Construct a <code>HomogenousMesh</code> from a <code>SignedDistanceField</code> using the marching cubes algorithm. This method is faster than Marching Tetrahedra and generates fewer vertices and faces (about 1/4 as many). However it may generate non-manifold meshes, while Marching Tetrahedra guarentees a manifold mesh.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.VoxelIndices" href="#Meshing.VoxelIndices"><code>Meshing.VoxelIndices</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Voxel corner and edge indexing conventions</p><pre><code class="language-none">    Z
    |

    5------5------6              Extra edges not drawn
   /|            /|              -----------
  8 |           6 |              - face diagonals
 /  9          /  10                - 13: 1 to 3
8------7------7   |                 - 14: 1 to 8
|   |         |   |                 - 15: 1 to 6
|   1------1--|---2  -- Y           - 16: 5 to 7
12 /          11 /                  - 17: 2 to 7
| 4           | 2                   - 18: 4 to 7
|/            |/                 - body diagonal
4------3------3                     - 19: 1 to 7</code></pre><p>/  X</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing._correct_vertices!-Tuple{Any,GeometryTypes.SignedDistanceField}" href="#Meshing._correct_vertices!-Tuple{Any,GeometryTypes.SignedDistanceField}"><code>Meshing._correct_vertices!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The marchingTetrahedra function returns vertices on the (1-based) indices of the SDF&#39;s data, ignoring its actual bounds. This function adjusts the vertices in place so that they correspond to points within the SDF bounds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.getVertId-Union{Tuple{IType}, Tuple{S}, Tuple{T}, Tuple{IType,IType,IType,IType,IType,IType,Array{T,1},Real,Dict{IType,Point{3,S}},Real,VoxelIndices{IType}}} where IType&lt;:Integer where S&lt;:Real where T&lt;:Real" href="#Meshing.getVertId-Union{Tuple{IType}, Tuple{S}, Tuple{T}, Tuple{IType,IType,IType,IType,IType,IType,Array{T,1},Real,Dict{IType,Point{3,S}},Real,VoxelIndices{IType}}} where IType&lt;:Integer where S&lt;:Real where T&lt;:Real"><code>Meshing.getVertId</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Gets the vertex ID, adding it to the vertex dictionary if not already present.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.hasFaces-Tuple{Array{#s833,1} where #s833&lt;:Real,Real}" href="#Meshing.hasFaces-Tuple{Array{#s833,1} where #s833&lt;:Real,Real}"><code>Meshing.hasFaces</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Checks if a voxel has faces. Should be false for most voxels. This function should be made as fast as possible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.marchingTetrahedra-Union{Tuple{IT}, Tuple{T}, Tuple{AbstractArray{T,3},Real,Real,Type{IT}}} where IT&lt;:Integer where T&lt;:Real" href="#Meshing.marchingTetrahedra-Union{Tuple{IT}, Tuple{T}, Tuple{AbstractArray{T,3},Real,Real,Type{IT}}} where IT&lt;:Integer where T&lt;:Real"><code>Meshing.marchingTetrahedra</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Given a 3D array and an isovalue, extracts a mesh represention of the an approximate isosurface by the method of marching tetrahedra.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.procVox-Union{Tuple{IType}, Tuple{S}, Tuple{T}, Tuple{Array{T,1},Real,IType,IType,IType,IType,IType,Dict{IType,Point{3,S}},Array{Face{3,IType},1},Real,VoxelIndices{IType}}} where IType&lt;:Integer where S&lt;:Real where T&lt;:Real" href="#Meshing.procVox-Union{Tuple{IType}, Tuple{S}, Tuple{T}, Tuple{Array{T,1},Real,IType,IType,IType,IType,IType,Dict{IType,Point{3,S}},Array{Face{3,IType},1},Real,VoxelIndices{IType}}} where IType&lt;:Integer where S&lt;:Real where T&lt;:Real"><code>Meshing.procVox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Processes a voxel, adding any new vertices and faces to the given containers as necessary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.tetIx-Union{Tuple{IType}, Tuple{IType,Array{#s835,1} where #s835&lt;:Real,Real,VoxelIndices{IType}}} where IType&lt;:Integer" href="#Meshing.tetIx-Union{Tuple{IType}, Tuple{IType,Array{#s835,1} where #s835&lt;:Real,Real,VoxelIndices{IType}}} where IType&lt;:Integer"><code>Meshing.tetIx</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Determines which case in the triangle table we are dealing with</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.vertId-Union{Tuple{IType}, Tuple{IType,IType,IType,IType,IType,IType,VoxelIndices{IType}}} where IType&lt;:Integer" href="#Meshing.vertId-Union{Tuple{IType}, Tuple{IType,IType,IType,IType,IType,IType,VoxelIndices{IType}}} where IType&lt;:Integer"><code>Meshing.vertId</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Determines a unique integer ID associated with the edge. This is used as a key in the vertex dictionary. It needs to be both unambiguous (no two edges get the same index) and unique (every edge gets the same ID regardless of which of its neighboring voxels is asking for it) in order for vertex sharing to be implemented properly.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.vertPos-Union{Tuple{IType}, Tuple{T}, Tuple{IType,IType,IType,IType,Array{T,1},Real,Real,VoxelIndices{IType}}} where IType&lt;:Integer where T&lt;:Real" href="#Meshing.vertPos-Union{Tuple{IType}, Tuple{T}, Tuple{IType,IType,IType,IType,Array{T,1},Real,Real,VoxelIndices{IType}}} where IType&lt;:Integer where T&lt;:Real"><code>Meshing.vertPos</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Assuming an edge crossing, determines the point in space at which it occurs. eps represents the &quot;bump&quot; factor to keep vertices away from voxel corners (thereby preventing degeneracies).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Meshing.voxEdgeId-Union{Tuple{IType}, Tuple{IType,IType,VoxelIndices{IType}}} where IType&lt;:Integer" href="#Meshing.voxEdgeId-Union{Tuple{IType}, Tuple{IType,IType,VoxelIndices{IType}}} where IType&lt;:Integer"><code>Meshing.voxEdgeId</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Given a sub-tetrahedron case and a tetrahedron edge ID, determines the corresponding voxel edge ID.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
