var documenterSearchIndex = {"docs": [

{
    "location": "#GaloisFields.GaloisField",
    "page": "Home",
    "title": "GaloisFields.GaloisField",
    "category": "function",
    "text": "F = GaloisField(p)\nF,α = GaloisField(p, :β => [1, 0, 1])\nF,α = GaloisField(p, n, :β)\n\nReturn a type representing a finite field.\n\nThe single-argument signature returns the finite field ℤpℤ.\n\nThe two-arguments signature returns an algebraic extension of that field, with minimum polynomial given by the second argument: a dense representation of the univariate, monic polynomial, with ascending degree.\n\nThe three-arguments signature returns an algebraic extension of that field, with minimum polynomial equal to the Conway polynomial  for (pn). The GaloisFields package ships with a database of Conway  polynomials and will raise an error if it does not contain an entry for  (pn).\n\nNote that in the latter two cases, the variable name (e.g. β above) is part of the type. This lets you define identifications between isomorphic (sub)fields. For example, with the following definition\n\nF = @GaloisField! 𝔽₂ β^2 + β + 1\nG = @GaloisField! 𝔽₂ γ^2 + γ + 1\n\nthe fields F and G are isomorphic, but not canonically. We might define\n\n@GaloisFields.identify β => γ + 1\n@GaloisFields.identify γ => β + 1\n\nto allow for conversions like\n\nG(β)\nconvert(F, γ + 1)\n\nIn the Conway case, you do not have to define your own identifications, as the Conway polynomials satisfy compatibility relations that allow us to use certain distinguished inclusions between them.\n\n\n\n\n\n"
},

{
    "location": "#GaloisFields.char-Tuple{Type{#s35} where #s35<:(Rational{#s34} where #s34<:Integer)}",
    "page": "Home",
    "title": "GaloisFields.char",
    "category": "method",
    "text": "p = char(GaloisField(3)) # returns 3\n\nReturn the characteristic of a finite field, or 0 for <:Integer or <:Rational{<Integer}.\n\n\n\n\n\n"
},

{
    "location": "#GaloisFields.AbstractExtensionField",
    "page": "Home",
    "title": "GaloisFields.AbstractExtensionField",
    "category": "type",
    "text": "abstract type AbstractExtensionField <: AbstractGaloisField end\n\nA type representing a finite extension of an underlying finite field.\n\n\n\n\n\n"
},

{
    "location": "#GaloisFields.AbstractGaloisField",
    "page": "Home",
    "title": "GaloisFields.AbstractGaloisField",
    "category": "type",
    "text": "abstract type AbstractGaloisField <: Number end\n\nA type representing finite fields.\n\n\n\n\n\n"
},

{
    "location": "#GaloisFields.ExtensionField",
    "page": "Home",
    "title": "GaloisFields.ExtensionField",
    "category": "type",
    "text": "F = ExtensionField{F <: AbstractGaloisField, N, α, MinPoly}\n\nAlgebraic extension of a finite field F of degree N.\n\n\n\n\n\n"
},

{
    "location": "#GaloisFields.PrimeField",
    "page": "Home",
    "title": "GaloisFields.PrimeField",
    "category": "type",
    "text": "PrimeField{I<:Integer, p}\n\nA type representing an element in ℤ/pℤ.\n\n\n\n\n\n"
},

{
    "location": "#GaloisFields.Reduced",
    "page": "Home",
    "title": "GaloisFields.Reduced",
    "category": "type",
    "text": "Reduced()\n\nA helper singleton used for asserting that an input value has already been reduced mod p.\n\n\n\n\n\n"
},

{
    "location": "#GaloisFields.defaultshow-Tuple{Any,Any}",
    "page": "Home",
    "title": "GaloisFields.defaultshow",
    "category": "method",
    "text": "defaultshow(io, t)\n\nOverloading display of types can be a bit hairy; I\'ve seen a declaration like\n\nshow(..., ::Type{<:Val{B}}) where B\n\nbeing called for non-concrete types. (I haven\'t dug deep enough to find a nice minimal example.)\n\nThat\'s why all show overloads for types do\n\n!isconcretetype(t) && return defaultshow(io, t)\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [GaloisFields]\nOrder = [:type, :function]"
},

]}
