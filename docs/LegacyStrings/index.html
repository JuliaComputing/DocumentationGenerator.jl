<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LegacyStrings.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LegacyStrings.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegacyStrings.utf16" href="#LegacyStrings.utf16"><code>LegacyStrings.utf16</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">utf16(::Union{Ptr{UInt16},Ptr{Int16}} [, length])</code></pre><p>Create a string from the address of a NUL-terminated UTF-16 string. A copy is made; the pointer can be safely freed. If <code>length</code> is specified, the string does not have to be NUL-terminated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegacyStrings.utf16-Tuple{Any}" href="#LegacyStrings.utf16-Tuple{Any}"><code>LegacyStrings.utf16</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">utf16(s)</code></pre><p>Create a UTF-16 string from a byte array, array of <code>UInt16</code>, or any other string type. (Data must be valid UTF-16. Conversions of byte arrays check for a byte-order marker in the first two bytes, and do not include it in the resulting string.)</p><p>Note that the resulting <code>UTF16String</code> data is terminated by the NUL codepoint (16-bit zero), which is not treated as a character in the string (so that it is mostly invisible in Julia); this allows the string to be passed directly to external functions requiring NUL-terminated data. This NUL is appended automatically by the <code>utf16(s)</code> conversion function. If you have a <code>UInt16</code> array <code>A</code> that is already NUL-terminated valid UTF-16 data, then you can instead use <code>UTF16String(A)</code> to construct the string without making a copy of the data and treating the NUL as a terminator rather than as part of the string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegacyStrings.utf32" href="#LegacyStrings.utf32"><code>LegacyStrings.utf32</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">utf32(::Union{Ptr{Char},Ptr{UInt32},Ptr{Int32}} [, length])</code></pre><p>Create a string from the address of a NUL-terminated UTF-32 string. A copy is made; the pointer can be safely freed. If <code>length</code> is specified, the string does not have to be NUL-terminated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegacyStrings.utf32-Tuple{Any}" href="#LegacyStrings.utf32-Tuple{Any}"><code>LegacyStrings.utf32</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">utf32(s)</code></pre><p>Create a UTF-32 string from a byte array, array of <code>Char</code> or <code>UInt32</code>, or any other string type. (Conversions of byte arrays check for a byte-order marker in the first four bytes, and do not include it in the resulting string.)</p><p>Note that the resulting <code>UTF32String</code> data is terminated by the NUL codepoint (32-bit zero), which is not treated as a character in the string (so that it is mostly invisible in Julia); this allows the string to be passed directly to external functions requiring NUL-terminated data. This NUL is appended automatically by the <code>utf32(s)</code> conversion function. If you have a <code>Char</code> or <code>UInt32</code> array <code>A</code> that is already NUL-terminated UTF-32 data, then you can instead use <code>UTF32String(A)</code> to construct the string without making a copy of the data and treating the NUL as a terminator rather than as part of the string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegacyStrings.checkstring" href="#LegacyStrings.checkstring"><code>LegacyStrings.checkstring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Validates and calculates number of characters in a UTF-8,UTF-16 or UTF-32 encoded vector/string</p><p>This function checks the bounds of the start and end positions Use <code>unsafe_checkstring</code> to avoid that overhead if the bounds have already been checked</p><p>Input Arguments:</p><ul><li><code>dat</code>    UTF-8 (<code>Vector{UInt8}</code>), UTF-16 (<code>Vector{UInt16}</code>) or UTF-32 (<code>Vector{UInt32}</code>, <code>AbstractString</code>) encoded string</li></ul><p>Optional Input Arguments:</p><ul><li><code>startpos</code> start position (defaults to 1)</li><li><code>endpos</code>   end position   (defaults to <code>lastindex(dat)</code>)</li></ul><p>Keyword Arguments:</p><ul><li><code>accept_long_null</code>  = <code>true</code>  # Modified UTF-8 (<code>\0</code> represented as <code>b&quot;\xc0\x80&quot;</code>)</li><li><code>accept_surrogates</code> = <code>true</code>  # <code>CESU-8</code></li><li><code>accept_long_char</code>  = <code>false</code> # Accept arbitrary long encodings</li></ul><p>Returns:</p><ul><li>(total characters, flags, 4-byte, 3-byte, 2-byte)</li></ul><p>Throws:</p><ul><li><code>UnicodeError</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegacyStrings.encode_to_utf16-Tuple{Any,Any}" href="#LegacyStrings.encode_to_utf16-Tuple{Any,Any}"><code>LegacyStrings.encode_to_utf16</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Converts an already validated UTF-32 encoded vector of <code>UInt32</code> to a <code>UTF16String</code></p><p>Input Arguments:</p><ul><li><code>dat</code> <code>Vector{UInt32}</code> of UTF-32 encoded data</li><li><code>len</code> length of output in 16-bit words</li></ul><p>Returns:</p><ul><li><code>UTF16String</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegacyStrings.encode_to_utf8-Union{Tuple{T}, Tuple{Type{T},Any,Any}} where T&lt;:Union{UInt16, UInt32}" href="#LegacyStrings.encode_to_utf8-Union{Tuple{T}, Tuple{Type{T},Any,Any}} where T&lt;:Union{UInt16, UInt32}"><code>LegacyStrings.encode_to_utf8</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Converts an already validated vector of <code>UInt16</code> or <code>UInt32</code> to a <code>UTF8String</code></p><p>Input Arguments:</p><ul><li><code>dat</code> Vector of code units (<code>UInt16</code> or <code>UInt32</code>), explicit <code> </code> is not converted</li><li><code>len</code> length of output in bytes</li></ul><p>Returns:</p><ul><li><code>UTF8String</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegacyStrings.unsafe_checkstring" href="#LegacyStrings.unsafe_checkstring"><code>LegacyStrings.unsafe_checkstring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Validates and calculates number of characters in a UTF-8,UTF-16 or UTF-32 encoded vector/string</p><p>Warning: this function does not check the bounds of the start or end positions Use <code>checkstring</code> to make sure the bounds are checked</p><p>Input Arguments:</p><ul><li><code>dat</code>    UTF-8 (<code>Vector{UInt8}</code>), UTF-16 (<code>Vector{UInt16}</code>) or UTF-32 (<code>Vector{UInt32}</code>, <code>AbstractString</code>) encoded string</li></ul><p>Optional Input Arguments:</p><ul><li><code>pos</code>    start position (defaults to 1)</li><li><code>endpos</code> end position   (defaults to <code>lastindex(dat)</code>)</li></ul><p>Keyword Arguments:</p><ul><li><code>accept_long_null</code>  = <code>true</code>  # Modified UTF-8 (<code>\0</code> represented as <code>b&quot;\xc0\x80&quot;</code>)</li><li><code>accept_surrogates</code> = <code>true</code>  # <code>CESU-8</code></li><li><code>accept_long_char</code>  = <code>false</code> # Accept arbitrary long encodings</li></ul><p>Returns:</p><ul><li>(total characters, flags, 4-byte, 3-byte, 2-byte)</li></ul><p>Throws:</p><ul><li><code>UnicodeError</code></li></ul></div></div></section><footer><hr/></footer></article></body></html>
