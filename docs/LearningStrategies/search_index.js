var documenterSearchIndex = {"docs": [

{
    "location": "#LearningStrategies.Breaker",
    "page": "Home",
    "title": "LearningStrategies.Breaker",
    "category": "type",
    "text": "Breaker(f)\n\nStop learning when f(model, i) returns true.\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.Converged",
    "page": "Home",
    "title": "LearningStrategies.Converged",
    "category": "type",
    "text": "Converged(f; tol = 1e-6, every = 1)\n\nStop learning when norm(f(model) - lastf) ≦ tol.  f must return a Vector{Float64}.\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.ConvergedTo",
    "page": "Home",
    "title": "LearningStrategies.ConvergedTo",
    "category": "type",
    "text": "ConvergedTo(f, goal; tol=1e-6, every=1)\n\nStop learning when ‖f(model) - goal‖ ≦ tol.\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.IterFunction",
    "page": "Home",
    "title": "LearningStrategies.IterFunction",
    "category": "type",
    "text": "IterFunction(f)\nIterFunction(f, b)\nIterFunction(b, f)\n\nCall f(model, i) every b iterations at hook call. Default value of b is 1.\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.LearningStrategy",
    "page": "Home",
    "title": "LearningStrategies.LearningStrategy",
    "category": "type",
    "text": "A LearningStrategy should implement at least one of the following methods:\n\nsetup!(strat, model, data)\ncleanup!(strat, model)\nhook(strat, model, i)\nfinished(strat, model, data, i)\nupdate!(model, strat, item)\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.MaxIter",
    "page": "Home",
    "title": "LearningStrategies.MaxIter",
    "category": "type",
    "text": "MaxIter(n)\n\nStop learning after n iterations.\n\nWrapping MaxIter with Verbose:\n\njulia> learn!(nothing, Verbose(MaxIter(5)), 1:100)\nINFO: MaxIter: 1/5\nINFO: MaxIter: 2/5\nINFO: MaxIter: 3/5\nINFO: MaxIter: 4/5\nINFO: MaxIter: 5/5\nINFO: MaxIter(5) finished\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.MetaStrategy",
    "page": "Home",
    "title": "LearningStrategies.MetaStrategy",
    "category": "type",
    "text": "MetaStrategy(strats::LearningStrategy...)\n\nA collection of learning strategies in a type-stable way.\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.TimeLimit",
    "page": "Home",
    "title": "LearningStrategies.TimeLimit",
    "category": "type",
    "text": "TimeLimit(s)\n\nStop learning after s seconds.\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.Tracer",
    "page": "Home",
    "title": "LearningStrategies.Tracer",
    "category": "type",
    "text": "Tracer{T}(::Type{T}, f, b=1)\n\nStore f(model, i) every b iterations.\n\nTo extract the data Tracer collected, collect(tracer). Note that this operation will copy.\n\njulia> t = Tracer(Int, (model, i) -> @show(i))\nTracer(1, #5, 0-element Array{Int64,1})\n\njulia> learn!(nothing, strategy(MaxIter(3), t))\ni = 1\ni = 2\ni = 3\n\njulia> collect(t)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.Verbose",
    "page": "Home",
    "title": "LearningStrategies.Verbose",
    "category": "type",
    "text": "Verbose(s::LearningStrategy)\nVerbose(s::LearningStrategy, io::IO)\n\nAllow the LearningStrategy s to print output.\n\nWill automatically print when finished(s, args...) == true.\nOther methods should be overloaded to add printout.\nFor example: update!(model, v::Verbose{MyStrategy}, item) = ...\n\n\n\n\n\n"
},

{
    "location": "#LearnBase.learn!-Tuple{Any,LearningStrategy,Any}",
    "page": "Home",
    "title": "LearnBase.learn!",
    "category": "method",
    "text": "learn!(model, strategy, data) -> model\n\nLearn a model from data using strategy. New models/strategies/data types should overload at least one of the following:\n\nsetup!\nupdate!\nhook\nfinished\ncleanup!\n\nlearn! Implementation:\n\nfunction learn!(model, s::LearningStrategy, data)\n    setup!(s, model[, data])\n    for (i, item) in enumerate(data)\n        update!(model, s[, i], item)\n        hook(s, model[, data], i)\n        finished(s, model[, data], i) && break\n    end\n    cleanup!(s, model)\nend\n\n\n\n\n\n"
},

{
    "location": "#LearningStrategies.strategy-Tuple{Vararg{LearningStrategy,N} where N}",
    "page": "Home",
    "title": "LearningStrategies.strategy",
    "category": "method",
    "text": "strategy(s::LearningStrategy...)\nstrategy(ms::MetaStrategy, s::LearningStrategy...)\n\nCreate a MetaStrategy from LearningStrategies or add a LearningStrategy to an existing MetaStrategy.\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [LearningStrategies]\nOrder = [:type, :function]"
},

]}
