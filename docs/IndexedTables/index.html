<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · IndexedTables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IndexedTables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.All" href="#IndexedTables.All"><code>IndexedTables.All</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">All(cols::Union{Symbol, Int}...)</code></pre><p>Select the union of the selections in <code>cols</code>. If <code>cols == ()</code>, select all columns.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], [0, 0, 0, 0], names=[:a,:b,:c,:d])
select(t, All(:a, (:b, :c)))
select(t, All())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Between" href="#IndexedTables.Between"><code>IndexedTables.Between</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Between(first, last)</code></pre><p>Select the columns between <code>first</code> and <code>last</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], 1:4, &#39;a&#39;:&#39;d&#39;, names=[:a,:b,:c,:d])
select(t, Between(:b, :d))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ColDict-Tuple{Any}" href="#IndexedTables.ColDict-Tuple{Any}"><code>IndexedTables.ColDict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">d = ColDict(t)</code></pre><p>Create a mutable dictionary of columns in <code>t</code>.</p><p>To get the immutable iterator of the same type as <code>t</code> call <code>d[]</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.IndexedTable" href="#IndexedTables.IndexedTable"><code>IndexedTables.IndexedTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A tabular data structure that extends <a href="@ref"><code>Columns</code></a>.  Create an <code>IndexedTable</code> with the  <a href="#IndexedTables.table"><code>table</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Keys" href="#IndexedTables.Keys"><code>IndexedTables.Keys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Keys()</code></pre><p>Select the primary keys.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], names=[:a,:b,:c], pkey = (:a, :b))
select(t, Keys())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.NDSparse-Tuple" href="#IndexedTables.NDSparse-Tuple"><code>IndexedTables.NDSparse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>NDSparse(columns...; names=Symbol[...], kwargs...)</code></p><p>Construct an NDSparse array from columns. The last argument is the data column, and the rest are index columns. The <code>names</code> keyword argument optionally specifies names for the index columns (dimensions).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Not" href="#IndexedTables.Not"><code>IndexedTables.Not</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Not(cols::Union{Symbol, Int}...)</code></pre><p>Select the complementary of the selection in <code>cols</code>. <code>Not</code> can accept several arguments, in which case it returns the complementary of the union of the selections.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], names=[:a,:b,:c], pkey = (:a, :b))
select(t, Not(:a))
select(t, Not(:a, (:a, :b)))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.aggregate!-Tuple{Any,NDSparse}" href="#IndexedTables.aggregate!-Tuple{Any,NDSparse}"><code>IndexedTables.aggregate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">aggregate!(f::Function, arr::NDSparse)</code></pre><p>Combine adjacent rows with equal indices using the given 2-argument reduction function, in place.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.asofjoin-Tuple{NDSparse,NDSparse}" href="#IndexedTables.asofjoin-Tuple{NDSparse,NDSparse}"><code>IndexedTables.asofjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">asofjoin(left::NDSparse, right::NDSparse)</code></pre><p>Join rows from <code>left</code> with the &quot;most recent&quot; value from <code>right</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">using Dates
akey1 = [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;]
akey2 = [Date(2017,11,11), Date(2017,11,12), Date(2017,11,11), Date(2017,11,12)]
avals = collect(1:4)

bkey1 = [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;]
bkey2 = [Date(2017,11,12), Date(2017,11,13), Date(2017,11,10), Date(2017,11,13)]
bvals = collect(5:8)

a = ndsparse((akey1, akey2), avals)
b = ndsparse((bkey1, bkey2), bvals)

asofjoin(a, b)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.collect_columns-Tuple{Any}" href="#IndexedTables.collect_columns-Tuple{Any}"><code>IndexedTables.collect_columns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">collect_columns(itr)</code></pre><p>Collect an iterable as a <code>Columns</code> object if it iterates <code>Tuples</code> or <code>NamedTuples</code>, as a normal <code>Array</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-none">s = [(1,2), (3,4)]
collect_columns(s)

s2 = Iterators.filter(isodd, 1:8)
collect_columns(s2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.colnames" href="#IndexedTables.colnames"><code>IndexedTables.colnames</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">colnames(itr)</code></pre><p>Returns the names of the &quot;columns&quot; in <code>itr</code>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">colnames(1:3)
colnames(Columns([1,2,3], [3,4,5]))
colnames(table([1,2,3], [3,4,5]))
colnames(Columns(x=[1,2,3], y=[3,4,5]))
colnames(table([1,2,3], [3,4,5], names=[:x,:y]))
colnames(ndsparse(Columns(x=[1,2,3]), Columns(y=[3,4,5])))
colnames(ndsparse(Columns(x=[1,2,3]), [3,4,5]))
colnames(ndsparse(Columns(x=[1,2,3]), [3,4,5]))
colnames(ndsparse(Columns([1,2,3], [4,5,6]), Columns(x=[6,7,8])))
colnames(ndsparse(Columns(x=[1,2,3]), Columns([3,4,5],[6,7,8])))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.columns" href="#IndexedTables.columns"><code>IndexedTables.columns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">columns(itr, select::Selection = All())</code></pre><p>Select one or more columns from an iterable of rows as a tuple of vectors.</p><p><code>select</code> specifies which columns to select. Refer to the <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a> function for the  available selection options and syntax.</p><p><code>itr</code> can be <code>NDSparse</code>, <code>Columns</code>, <code>AbstractVector</code>, or their distributed counterparts.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:2, 3:4; names = [:x, :y])

columns(t)
columns(t, :x)
columns(t, (:x,))
columns(t, (:y, :x =&gt; -))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.columns-Tuple{Any,Any}" href="#IndexedTables.columns-Tuple{Any,Any}"><code>IndexedTables.columns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>columns(itr, which)</code></p><p>Returns a vector or a tuple of vectors from the iterator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertdim-Tuple{NDSparse,Union{Int64, Symbol},Any}" href="#IndexedTables.convertdim-Tuple{NDSparse,Union{Int64, Symbol},Any}"><code>IndexedTables.convertdim</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>convertdim(x::NDSparse, d::DimName, xlate; agg::Function, vecagg::Function, name)</code></p><p>Apply function or dictionary <code>xlate</code> to each index in the specified dimension. If the mapping is many-to-one, <code>agg</code> or <code>vecagg</code> is used to aggregate the results. If <code>agg</code> is passed, it is used as a 2-argument reduction function over the data. If <code>vecagg</code> is passed, it is used as a vector-to-scalar function to aggregate the data. <code>name</code> optionally specifies a new name for the translated dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.dimlabels-Tuple{NDSparse}" href="#IndexedTables.dimlabels-Tuple{NDSparse}"><code>IndexedTables.dimlabels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>dimlabels(t::NDSparse)</code></p><p>Returns an array of integers or symbols giving the labels for the dimensions of <code>t</code>. <code>ndims(t) == length(dimlabels(t))</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.dropmissing" href="#IndexedTables.dropmissing"><code>IndexedTables.dropmissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dropmissing(t        )
dropmissing(t, select)</code></pre><p>Drop rows of table <code>t</code> which contain missing values (either <code>Missing</code> or <code>DataValue</code>),  optionally only using the columns in <code>select</code>.  Column types will be converted to  non-missing types.  For example:</p><ul><li><code>Vector{Union{Int, Missing}}</code> -&gt; <code>Vector{Int}</code></li><li><code>DataValueArray{Int}</code> -&gt; Vector{Int}</li></ul><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.1,0.5,missing,0.7], [2,missing,4,5], [missing,6,missing,7], names=[:t,:x,:y])
dropmissing(t)
dropmissing(t, (:t, :x))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.flatten" href="#IndexedTables.flatten"><code>IndexedTables.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">flatten(t::Table, col=length(columns(t)))</code></pre><p>Flatten <code>col</code> column which may contain a vector of vectors while repeating the other fields. If column argument is not provided, default to last column.</p><p><strong>Examples:</strong></p><pre><code class="language-none">x = table([1,2], [[3,4], [5,6]], names=[:x, :y])
flatten(x, 2)

t1 = table([3,4],[5,6], names=[:a,:b])
t2 = table([7,8], [9,10], names=[:a,:b])
x = table([1,2], [t1, t2], names=[:x, :y]);
flatten(x, :y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.flush!-Tuple{NDSparse}" href="#IndexedTables.flush!-Tuple{NDSparse}"><code>IndexedTables.flush!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>flush!(arr::NDSparse)</code></p><p>Commit queued assignment operations, by sorting and merging the internal temporary buffer.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupby" href="#IndexedTables.groupby"><code>IndexedTables.groupby</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupby(f, t, by = pkeynames(t); select, flatten=false)</code></pre><p>Apply <code>f</code> to the <code>select</code>-ed columns (see <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a>) in groups defined by the  unique values of <code>by</code>. </p><p>If <code>f</code> returns a vector, split it into multiple columns with <code>flatten = true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using Statistics

t=table([1,1,1,2,2,2], [1,1,2,2,1,1], [1,2,3,4,5,6], names=[:x,:y,:z])

groupby(mean, t, :x, select=:z)
groupby(identity, t, (:x, :y), select=:z)
groupby(mean, t, (:x, :y), select=:z)

groupby((mean, std, var), t, :y, select=:z)
groupby((q25=z-&gt;quantile(z, 0.25), q50=median, q75=z-&gt;quantile(z, 0.75)), t, :y, select=:z)

# apply different aggregation functions to different columns
groupby((ymean = :y =&gt; mean, zmean = :z =&gt; mean), t, :x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupjoin-Tuple{Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}" href="#IndexedTables.groupjoin-Tuple{Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}"><code>IndexedTables.groupjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">groupjoin(left, right; kw...)
groupjoin(f, left, right; kw...)</code></pre><p>Join <code>left</code> and <code>right</code> creating groups of values with matching keys.</p><p>For keyword argument options, see <a href="#Base.join-Tuple{Any,Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}"><code>join</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">l = table([1,1,1,2], [1,2,2,1], [1,2,3,4], names=[:a,:b,:c], pkey=(:a, :b))
r = table([0,1,1,2], [1,2,2,1], [1,2,3,4], names=[:a,:b,:d], pkey=(:a, :b))

groupjoin(l, r)
groupjoin(l, r; how = :left)
groupjoin(l, r; how = :outer)
groupjoin(l, r; how = :anti)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupreduce" href="#IndexedTables.groupreduce"><code>IndexedTables.groupreduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">groupreduce(f, t, by = pkeynames(t); select)</code></pre><p>Calculate a <a href="#Base.reduce-Tuple{Any,IndexedTable}"><code>reduce</code></a> operation <code>f</code> over table <code>t</code> on groups defined by the values  in selection <code>by</code>.  The result is put in a table keyed by the unique <code>by</code> values.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,1,2,2,2], 1:6, names=[:x, :y])
groupreduce(+,        t, :x; select = :y)
groupreduce((sum=+,), t, :x; select = :y)  # change output column name to :sum

t2 = table([1,1,1,2,2,2], [1,1,2,2,3,3], 1:6, names = [:x, :y, :z])
groupreduce(+, t2, (:x, :y), select = :z)

# different reducers for different columns
groupreduce((sumy = :y =&gt; +, sumz = :z =&gt; +), t2, :x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcol-Tuple{Any,Integer,Any,Any}" href="#IndexedTables.insertcol-Tuple{Any,Integer,Any,Any}"><code>IndexedTables.insertcol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">insertcol(t, position::Integer, name, x)</code></pre><p>Insert a column <code>x</code> named <code>name</code> at <code>position</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcol(t, 2, :w, [0,1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcolafter-NTuple{4,Any}" href="#IndexedTables.insertcolafter-NTuple{4,Any}"><code>IndexedTables.insertcolafter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">insertcolafter(t, after, name, col)</code></pre><p>Insert a column <code>col</code> named <code>name</code> after <code>after</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcolafter(t, :t, :w, [0,1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcolbefore-NTuple{4,Any}" href="#IndexedTables.insertcolbefore-NTuple{4,Any}"><code>IndexedTables.insertcolbefore</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">insertcolbefore(t, before, name, col)</code></pre><p>Insert a column <code>col</code> named <code>name</code> before <code>before</code>. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
insertcolbefore(t, :x, :w, [0,1])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.map_rows-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.map_rows-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.map_rows</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map_rows(f, c...)</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise. Collect output as <code>Columns</code> if <code>f</code> returns <code>Tuples</code> or <code>NamedTuples</code> with constant fields, as <code>Array</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-none">map_rows(i -&gt; (exp = exp(i), log = log(i)), 1:5)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ncols" href="#IndexedTables.ncols"><code>IndexedTables.ncols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ncols(itr)</code></pre><p>Returns the number of columns in <code>itr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">ncols([1,2,3]) == 1
ncols(rows(([1,2,3],[4,5,6]))) == 2</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.ndsparse" href="#IndexedTables.ndsparse"><code>IndexedTables.ndsparse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ndsparse(keys, values; kw...)</code></pre><p>Construct an NDSparse array with the given <code>keys</code> and <code>values</code> columns. On construction,  the keys and data are sorted in lexicographic order of the <code>keys</code>.</p><p><strong>Keyword Argument Options:</strong></p><ul><li><code>agg = nothing</code> – Function to aggregate values with duplicate keys.</li><li><code>presorted = false</code> – Are the key columns already sorted?</li><li><code>copy = true</code> – Should the columns in <code>keys</code> and <code>values</code> be copied?</li><li><code>chunks = nothing</code> – Provide an integer to distribute data into <code>chunks</code> chunks.<ul><li>A good choice is <code>nworkers()</code> (after <code>using Distributed</code>)</li><li>See also: <a href="@ref"><code>distribute</code></a></li></ul></li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">x = ndsparse([&quot;a&quot;,&quot;b&quot;], [3,4])
keys(x)
values(x)
x[&quot;a&quot;]

# Dimensions are named if constructed with a named tuple of columns 
x = ndsparse((index = 1:10,), rand(10))
x[1]

# Multiple dimensions by passing a (named) tuple of columns
x = ndsparse((x = 1:10, y = 1:2:20), rand(10))
x[1, 1]

# Value columns can also have names via named tuples
x = ndsparse(1:10, (x=rand(10), y=rand(10)))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pkeynames-Tuple{IndexedTables.AbstractIndexedTable}" href="#IndexedTables.pkeynames-Tuple{IndexedTables.AbstractIndexedTable}"><code>IndexedTables.pkeynames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pkeynames(t::Table)</code></pre><p>Names of the primary key columns in <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,2], [3,4]);
pkeynames(t)

t = table([1,2], [3,4], pkey=1);
pkeynames(t)

t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2));
pkeynames(t)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pkeynames-Tuple{NDSparse}" href="#IndexedTables.pkeynames-Tuple{NDSparse}"><code>IndexedTables.pkeynames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pkeynames(t::NDSparse)</code></pre><p>Names of the primary key columns in <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">x = ndsparse([1,2],[3,4])
pkeynames(x)

x = ndsparse((x=1:10, y=1:2:20), rand(10))
pkeynames(x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pkeys-Tuple{IndexedTable}" href="#IndexedTables.pkeys-Tuple{IndexedTable}"><code>IndexedTables.pkeys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pkeys(itr::IndexedTable)</code></pre><p>Primary keys of the table. If Table doesn&#39;t have any designated primary key columns (constructed without <code>pkey</code> argument) then a default key of tuples <code>(1,):(n,)</code> is generated.</p><p><strong>Example</strong></p><pre><code class="language-none">a = table([&quot;a&quot;,&quot;b&quot;], [3,4]) # no pkey
pkeys(a)

a = table([&quot;a&quot;,&quot;b&quot;], [3,4], pkey=1)
pkeys(a)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.popcol-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.popcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.popcol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">popcol(t, cols...)</code></pre><p>Remove the column(s) <code>cols</code> from the table. Returns a new table.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
popcol(t, :x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pushcol-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.pushcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.pushcol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pushcol(t, name, x)</code></pre><p>Push a column <code>x</code> to the end of the table. <code>name</code> is the name for the new column. Returns a new table.</p><pre><code class="language-none">pushcol(t, map::Pair...)</code></pre><p>Push many columns at a time.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
pushcol(t, :z, [1//2, 3//4])
pushcol(t, :z =&gt; [1//2, 3//4])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reducedim_vec-Tuple{Any,NDSparse,Any}" href="#IndexedTables.reducedim_vec-Tuple{Any,NDSparse,Any}"><code>IndexedTables.reducedim_vec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>reducedim_vec(f::Function, arr::NDSparse, dims)</code></p><p>Like <code>reduce</code>, except uses a function mapping a vector of values to a scalar instead of a 2-argument scalar function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reindex" href="#IndexedTables.reindex"><code>IndexedTables.reindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reindex(t::IndexedTable, by)
reindex(t::IndexedTable, by, select)</code></pre><p>Reindex table <code>t</code> with new primary key <code>by</code>, optionally keeping a subset of columns via <code>select</code>.  For <a href="#IndexedTables.NDSparse-Tuple"><code>NDSparse</code></a>, use <a href="#IndexedTables.selectkeys-Tuple{NDSparse,Any}"><code>selectkeys</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2))

t2 = reindex(t, (:y, :z))

pkeynames(t2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.renamecol-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.renamecol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.renamecol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">renamecol(t, col, newname)</code></pre><p>Set <code>newname</code> as the new name for column <code>col</code> in <code>t</code>. Returns a new table.</p><pre><code class="language-none">renamecol(t, map::Pair...)</code></pre><p>Rename multiple columns at a time.</p><p><strong>Example</strong></p><pre><code class="language-none">t = table([0.01, 0.05], [2,1], names=[:t, :x])
renamecol(t, :t, :time)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.rows" href="#IndexedTables.rows"><code>IndexedTables.rows</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rows(itr, select = All())</code></pre><p>Select one or more fields from an iterable of rows as a vector of their values.  Refer to  the <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a> function for selection options and syntax.</p><p><code>itr</code> can be <a href="#IndexedTables.NDSparse-Tuple"><code>NDSparse</code></a>, <a href="@ref"><code>Columns</code></a>, <code>AbstractVector</code>, or their distributed counterparts.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,2],[3,4], names=[:x,:y])
rows(t)
rows(t, :x)
rows(t, (:x,))
rows(t, (:y, :x =&gt; -))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}" href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>IndexedTables.select</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">select(t::Table, which::Selection)</code></pre><p>Select all or a subset of columns, or a single column from the table.</p><p><code>Selection</code> is a type union of many types that can select from a table. It can be:</p><ol><li><code>Integer</code> – returns the column at this position.</li><li><code>Symbol</code> – returns the column with this name.</li><li><code>Pair{Selection =&gt; Function}</code> – selects and maps a function over the selection, returns the result.</li><li><code>AbstractArray</code> – returns the array itself. This must be the same length as the table.</li><li><code>Tuple</code> of <code>Selection</code> – returns a table containing a column for every selector in the tuple. The tuple may also contain the type <code>Pair{Symbol, Selection}</code>, which the selection a name. The most useful form of this when introducing a new column.</li><li><code>Regex</code> – returns the columns with names that match the regular expression.</li><li><code>Type</code> – returns columns with elements of the given type.</li></ol><p><strong>Examples:</strong></p><pre><code class="language-none">t = table(1:10, randn(10), rand(Bool, 10); names = [:x, :y, :z])

# select the :x vector
select(t, 1)
select(t, :x)

# map a function to the :y vector
select(t, 2 =&gt; abs)
select(t, :y =&gt; x -&gt; x &gt; 0 ? x : -x)

# select the table of :x and :z
select(t, (:x, :z))
select(t, r&quot;(x|z)&quot;)

# map a function to the table of :x and :y
select(t, (:x, :y) =&gt; row -&gt; row[1] + row[2])
select(t, (1, :y) =&gt; row -&gt; row.x + row.y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.selectkeys-Tuple{NDSparse,Any}" href="#IndexedTables.selectkeys-Tuple{NDSparse,Any}"><code>IndexedTables.selectkeys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">selectkeys(x::NDSparse, sel)</code></pre><p>Return an <code>NDSparse</code> with a subset of keys.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.selectvalues-Tuple{NDSparse,Any}" href="#IndexedTables.selectvalues-Tuple{NDSparse,Any}"><code>IndexedTables.selectvalues</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">selectvalues(x::NDSparse, sel)</code></pre><p>Return an <code>NDSparse</code> with a subset of values</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.setcol-Tuple{Any,Vararg{Any,N} where N}" href="#IndexedTables.setcol-Tuple{Any,Vararg{Any,N} where N}"><code>IndexedTables.setcol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setcol(t::Table, col::Union{Symbol, Int}, x::Selection)</code></pre><p>Sets a <code>x</code> as the column identified by <code>col</code>. Returns a new table.</p><pre><code class="language-none">setcol(t::Table, map::Pair{}...)</code></pre><p>Set many columns at a time.</p><p><strong>Examples:</strong></p><pre><code class="language-none">t = table([1,2], [3,4], names=[:x, :y])

# change second column to [5,6]
setcol(t, 2 =&gt; [5,6])
setcol(t, :y , :y =&gt; x -&gt; x + 2)

# add [5,6] as column :z 
setcol(t, :z =&gt; 5:6)
setcol(t, :z, :y =&gt; x -&gt; x + 2)

# replacing the primary key results in a re-sorted copy
t = table([0.01, 0.05], [1,2], [3,4], names=[:t, :x, :y], pkey=:t)
t2 = setcol(t, :t, [0.1,0.05])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.stack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}" href="#IndexedTables.stack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>IndexedTables.stack</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stack(t, by = pkeynames(t); select = Not(by), variable = :variable, value = :value)`</code></pre><p>Reshape a table from the wide to the long format. Columns in <code>by</code> are kept as indexing columns. Columns in <code>select</code> are stacked. In addition to the id columns, two additional columns labeled  <code>variable</code> and <code>value</code> are added, containing the column identifier and the stacked columns. See also <a href="#IndexedTables.unstack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>unstack</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:4, names = [:x], pkey=:x)
t = pushcol(t, :xsquare, :x =&gt; x -&gt; x^2)
t = pushcol(t, :xcube  , :x =&gt; x -&gt; x^3)

stack(t)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.summarize" href="#IndexedTables.summarize"><code>IndexedTables.summarize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">summarize(f, t, by = pkeynames(t); select = Not(by), stack = false, variable = :variable)</code></pre><p>Apply summary functions column-wise to a table. Return a <code>NamedTuple</code> in the non-grouped case and a table in the grouped case. Use <code>stack=true</code> to stack results of the same summary function  for different columns.</p><p><strong>Examples</strong></p><pre><code class="language-none">using Statistics

t = table([1, 2, 3], [1, 1, 1], names = [:x, :y])

summarize((mean, std), t)
summarize((m = mean, s = std), t)
summarize(mean, t; stack=true)
summarize((mean, std), t; select = :y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.table" href="#IndexedTables.table"><code>IndexedTables.table</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">table(cols; kw...)</code></pre><p>Create a table from a (named) tuple of AbstractVectors.</p><pre><code class="language-none">table(cols::AbstractVector...; names::Vector{Symbol}, kw...)</code></pre><p>Create a table from the provided <code>cols</code>, optionally with <code>names</code>.</p><pre><code class="language-none">table(cols::Columns; kw...)</code></pre><p>Construct a table from a vector of tuples. See <a href="#IndexedTables.rows"><code>rows</code></a> and <a href="@ref"><code>Columns</code></a>.</p><pre><code class="language-none">table(t::Union{IndexedTable, NDSparse}; kw...)</code></pre><p>Copy a Table or NDSparse to create a new table. The same primary keys as the input are used.</p><pre><code class="language-none">table(x; kw...)</code></pre><p>Create an <code>IndexedTable</code> from any object <code>x</code> that follows the <code>Tables.jl</code> interface.</p><p><strong>Keyword Argument Options:</strong></p><ul><li><code>pkey</code>: select columns to sort by and be the primary key.</li><li><code>presorted = false</code>: is the data pre-sorted by primary key columns? </li><li><code>copy = true</code>: creates a copy of the input vectors if <code>true</code>. Irrelevant if <code>chunks</code> is specified.</li><li><code>chunks::Integer</code>: distribute the table.  Options are:<ul><li><code>Int</code> – (number of chunks) a safe bet is <code>nworkers()</code> after <code>using Distributed</code>.</li><li><code>Vector{Int}</code> – Number of elements in each of the <code>length(chunks)</code> chunks.</li></ul></li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">table(rand(10), rand(10), names = [:x, :y], pkey = :x)

table(rand(Bool, 20), rand(20), rand(20), pkey = [1,2])

table((x = 1:10, y = randn(10)))

table([(1,2), (3,4)])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.unstack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}" href="#IndexedTables.unstack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>IndexedTables.unstack</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unstack(t, by = pkeynames(t); variable = :variable, value = :value)</code></pre><p>Reshape a table from the long to the wide format. Columns in <code>by</code> are kept as indexing columns. Keyword arguments <code>variable</code> and <code>value</code> denote which column contains the column identifier and which the corresponding values.  See also <a href="#IndexedTables.stack-Union{Tuple{D}, Tuple{D}, Tuple{D,Any}} where D&lt;:Union{IndexedTable, NDSparse}"><code>stack</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:4, [1, 4, 9, 16], [1, 8, 27, 64], names = [:x, :xsquare, :xcube], pkey = :x);

long = stack(t)

unstack(long)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.update!-Union{Tuple{N}, Tuple{Union{Function, Type},NDSparse,Vararg{Any,N}}} where N" href="#IndexedTables.update!-Union{Tuple{N}, Tuple{Union{Function, Type},NDSparse,Vararg{Any,N}}} where N"><code>IndexedTables.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>update!(f::Function, arr::NDSparse, indices...)</code></p><p>Replace data values <code>x</code> with <code>f(x)</code> at each location that matches the given indices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.where-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N" href="#IndexedTables.where-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N"><code>IndexedTables.where</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>where(arr::NDSparse, indices...)</code></p><p>Returns an iterator over data items where the given indices match. Accepts the same index arguments as <code>getindex</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Perm" href="#IndexedTables.Perm"><code>IndexedTables.Perm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A permutation</p><p><strong>Fields:</strong></p><ul><li><code>columns</code>: The columns being indexed as a vector of integers (column numbers)</li><li><code>perm</code>: the permutation - an array or iterator which has the sorted permutation</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcast-Tuple{Function,NDSparse,NDSparse}" href="#Base.Broadcast.broadcast-Tuple{Function,NDSparse,NDSparse}"><code>Base.Broadcast.broadcast</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">broadcast(f, A::NDSparse, B::NDSparse; dimmap::Tuple{Vararg{Int}})
A .* B</code></pre><p>Compute an inner join of <code>A</code> and <code>B</code> using function <code>f</code>, where the dimensions of <code>B</code> are a subset of the dimensions of <code>A</code>. Values from <code>B</code> are repeated over the extra dimensions.</p><p><code>dimmap</code> optionally specifies how dimensions of <code>A</code> correspond to dimensions of <code>B</code>. It is a tuple where <code>dimmap[i]==j</code> means the <code>i</code>th dimension of <code>A</code> matches the <code>j</code>th dimension of <code>B</code>. Extra dimensions that do not match any dimensions of <code>j</code> should have <code>dimmap[i]==0</code>.</p><p>If <code>dimmap</code> is not specified, it is determined automatically using index column names and types.</p><p><strong>Example</strong></p><pre><code class="language-none">a = ndsparse(([1,1,2,2], [1,2,1,2]), [1,2,3,4])
b = ndsparse([1,2], [1/1, 1/2])
broadcast(*, a, b)</code></pre><p><code>dimmap</code> maps dimensions that should be broadcasted:</p><pre><code class="language-none">broadcast(*, a, b, dimmap=(0,1))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{IndexedTable},Any,Any}" href="#Base.convert-Tuple{Type{IndexedTable},Any,Any}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert(IndexedTable, pkeys, vals; kwargs...)</code></pre><p>Construct a table with <code>pkeys</code> as primary keys and <code>vals</code> as corresponding non-indexed items. keyword arguments will be forwarded to <a href="#IndexedTables.table"><code>table</code></a> constructor.</p><p><strong>Example</strong></p><pre><code class="language-none">convert(IndexedTable, Columns(x=[1,2],y=[3,4]), Columns(z=[1,2]), presorted=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter-Tuple{Any,Union{IndexedTable, NDSparse}}" href="#Base.filter-Tuple{Any,Union{IndexedTable, NDSparse}}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">filter(f, t::Union{IndexedTable, NDSparse}; select)</code></pre><p>Iterate over <code>t</code> and Return the rows for which <code>f(row)</code> returns true.  <code>select</code> determines  the rows that are given as arguments to <code>f</code> (see <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a>).</p><p><code>f</code> can also be a tuple of <code>column =&gt; function</code> pairs.  Returned rows will be those for which all conditions are true.</p><p><strong>Example</strong></p><pre><code class="language-none"># filter iterates over ROWS of a IndexedTable
t = table(rand(100), rand(100), rand(100), names = [:x, :y, :z])
filter(r -&gt; r.x + r.y + r.z &lt; 1, t)

# filter iterates over VALUES of an NDSparse
x = ndsparse(1:100, randn(100))
filter(val -&gt; val &gt; 0, x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join-Tuple{Any,Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}" href="#Base.join-Tuple{Any,Union{IndexedTable, NDSparse},Union{IndexedTable, NDSparse}}"><code>Base.join</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">join(left, right; kw...)
join(f, left, right; kw...)</code></pre><p>Join tables <code>left</code> and <code>right</code>.</p><p>If a function <code>f(leftrow, rightrow)</code> is provided, the returned table will have a single  output column.  See the Examples below.</p><p>If the same key occurs multiple times in either table, each <code>left</code> row will get matched  with each <code>right</code> row, resulting in <code>n_occurrences_left * n_occurrences_right</code> output rows.</p><p><strong>Options (keyword arguments)</strong></p><ul><li><code>how = :inner</code> <ul><li>Join method to use. Described below.</li></ul></li><li><code>lkey = pkeys(left)</code> <ul><li>Fields from <code>left</code> to match on (see <a href="#IndexedTables.pkeys-Tuple{IndexedTable}"><code>pkeys</code></a>).</li></ul></li><li><code>rkey = pkeys(right)</code> <ul><li>Fields from <code>right</code> to match on.</li></ul></li><li><code>lselect = Not(lkey)</code> <ul><li>Output columns from <code>left</code> (see <a href="#IndexedTables.Not"><code>Not</code></a>)</li></ul></li><li><code>rselect = Not(rkey)</code><ul><li>Output columns from <code>right</code>.</li></ul></li><li><code>missingtype = Missing</code> <ul><li>Type of missing values that can be created through <code>:left</code> and <code>:outer</code> joins.</li><li>Other supported option is <code>DataValue</code>.</li></ul></li></ul><p><strong>Join methods (<code>how = :inner</code>)</strong></p><ul><li><code>:inner</code> – rows with matching keys in both tables</li><li><code>:left</code> – all rows from <code>left</code>, plus matched rows from <code>right</code> (missing values can occur)</li><li><code>:outer</code> – all rows from both tables (missing values can occur)</li><li><code>:anti</code> – rows in <code>left</code> WITHOUT matching keys in <code>right</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">a = table((x = 1:10,   y = rand(10)), pkey = :x)
b = table((x = 1:2:20, z = rand(10)), pkey = :x)

join(a, b; how = :inner)
join(a, b; how = :left)
join(a, b; how = :outer)
join(a, b; how = :anti)

join((l, r) -&gt; l.y + r.z, a, b)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys-Tuple{NDSparse,Vararg{Any,N} where N}" href="#Base.keys-Tuple{NDSparse,Vararg{Any,N} where N}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>keys(x::NDSparse[, select::Selection])</code></p><p>Get the keys of an <code>NDSparse</code> object. Same as <a href="#IndexedTables.rows"><code>rows</code></a> but acts only on the index columns of the <code>NDSparse</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,IndexedTables.AbstractIndexedTable}" href="#Base.map-Tuple{Any,IndexedTables.AbstractIndexedTable}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map(f, t::IndexedTable; select)</code></pre><p>Apply <code>f</code> to every item in <code>t</code> selected by <code>select</code> (see also the <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a> function).   Returns a new table if <code>f</code> returns a tuple or named tuple.  If not, returns a vector.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,2], [3,4], names=[:x, :y])

polar = map(p -&gt; (r = hypot(p.x, p.y), θ = atan(p.y, p.x)), t)

back2t = map(p -&gt; (x = p.r * cos(p.θ), y = p.r * sin(p.θ)), polar)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,NDSparse}" href="#Base.map-Tuple{Any,NDSparse}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map(f, x::NDSparse; select = values(x))</code></pre><p>Apply <code>f</code> to every value of <code>select</code> selected from <code>x</code> (see <a href="#IndexedTables.select-Tuple{IndexedTables.AbstractIndexedTable,Any}"><code>select</code></a>).</p><p>Apply <code>f</code> to every data value in <code>x</code>. <code>select</code> selects fields passed to <code>f</code>. By default, the data values are selected.</p><p>If the return value of <code>f</code> is a tuple or named tuple the result will contain many data columns.</p><p><strong>Examples</strong></p><pre><code class="language-none">x = ndsparse((t=[0.01, 0.05],), (x=[1,2], y=[3,4]))

polar = map(row -&gt; (r = hypot(row.x, row.y), θ = atan(row.y, row.x)), x)

back2x = map(row -&gt; (x = row.r * cos(row.θ), y = row.r * sin(row.θ)), polar)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge-Tuple{Union{IndexedTable, NDSparse},Any}" href="#Base.merge-Tuple{Union{IndexedTable, NDSparse},Any}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">merge(a::IndexedTable, b::IndexedTable; pkey)</code></pre><p>Merge rows of <code>a</code> with rows of <code>b</code> and remain ordered by the primary key(s).  <code>a</code> and <code>b</code> must have the same column names.</p><pre><code class="language-none">merge(a::NDSparse, a::NDSparse; agg)</code></pre><p>Merge rows of <code>a</code> with rows of <code>b</code>.  To keep unique keys, the value from <code>b</code> takes priority. A provided function <code>agg</code> will aggregate values from <code>a</code> and <code>b</code> that have the same key(s).</p><p><strong>Example:</strong></p><pre><code class="language-none">a = table((x = 1:5, y = rand(5)); pkey = :x)
b = table((x = 6:10, y = rand(5)); pkey = :x)
merge(a, b)

a = ndsparse([1,3,5], [1,2,3])
b = ndsparse([2,3,4], [4,5,6])
merge(a, b)
merge(a, b; agg = (x,y) -&gt; x)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pairs-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N" href="#Base.pairs-Union{Tuple{N}, Tuple{NDSparse,Vararg{Any,N}}} where N"><code>Base.pairs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>pairs(arr::NDSparse, indices...)</code></p><p>Similar to <code>where</code>, but returns an iterator giving <code>index=&gt;value</code> pairs. <code>index</code> will be a tuple.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reduce-Tuple{Any,IndexedTable}" href="#Base.reduce-Tuple{Any,IndexedTable}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reduce(f, t::IndexedTable; select::Selection)</code></pre><p>Apply reducer function <code>f</code> pair-wise to the selection <code>select</code> in <code>t</code>.  The reducer <code>f</code>  can be:</p><ol><li>A function</li><li>An OnlineStat</li><li>A (named) tuple of functions and/or OnlineStats</li><li>A (named) tuple of (selector =&gt; function) or (selector =&gt; OnlineStat) pairs</li></ol><p><strong>Examples</strong></p><pre><code class="language-none">t = table(1:5, 6:10, names = [:t, :x])

reduce(+, t, select = :t)
reduce((a, b) -&gt; (t = a.t + b.t, x = a.x + b.x), t)

using OnlineStats
reduce(Mean(), t, select = :t)
reduce((Mean(), Variance()), t, select = :t)

y = reduce((min, max), t, select=:x)
reduce((sum = +, prod = *), t, select=:x)

# combining reduction and selection
reduce((xsum = :x =&gt; +, negtsum = (:t =&gt; -) =&gt; +), t)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reduce-Tuple{Any,NDSparse}" href="#Base.reduce-Tuple{Any,NDSparse}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reduce(f, x::NDSparse; dims)</code></pre><p>Drop the <code>dims</code> dimension(s) and aggregate values with <code>f</code>.</p><pre><code class="language-none">x = ndsparse((x=[1,1,1,2,2,2],
              y=[1,2,2,1,2,2],
              z=[1,1,2,1,1,2]), [1,2,3,4,5,6])
              
reduce(+, x; dims=1)
reduce(+, x; dims=(1,3))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort!-Tuple{IndexedTable,Vararg{Any,N} where N}" href="#Base.sort!-Tuple{IndexedTable,Vararg{Any,N} where N}"><code>Base.sort!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sort!(t    ; kw...)
sort!(t, by; kw...)</code></pre><p>Sort rows of <code>t</code> by <code>by</code> in place. All of <code>Base.sort</code> keyword arguments can be used.</p><p><strong>Examples</strong></p><pre><code class="language-none">t = table([1,1,1,2,2,2], [1,1,2,2,1,1], [1,2,3,4,5,6], names=[:x,:y,:z]);
sort!(t, :z, rev = true)
t</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort-Tuple{IndexedTable,Vararg{Any,N} where N}" href="#Base.sort-Tuple{IndexedTable,Vararg{Any,N} where N}"><code>Base.sort</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sort(t    ; select, kw...)
sort(t, by; select, kw...)</code></pre><p>Sort rows by <code>by</code>. All of <code>Base.sort</code> keyword arguments can be used.</p><p><strong>Examples</strong></p><pre><code class="language-none">t=table([1,1,1,2,2,2], [1,1,2,2,1,1], [1,2,3,4,5,6],
sort(t, :z; select = (:y, :z), rev = true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.values-Tuple{NDSparse,Vararg{Any,N} where N}" href="#Base.values-Tuple{NDSparse,Vararg{Any,N} where N}"><code>Base.values</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>values(x::NDSparse[, select::Selection])</code></p><p>Get the values of an <code>NDSparse</code> object. Same as <a href="#IndexedTables.rows"><code>rows</code></a> but acts only on the value columns of the <code>NDSparse</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.arrayof-Tuple{Any}" href="#IndexedTables.arrayof-Tuple{Any}"><code>IndexedTables.arrayof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">arrayof(T)</code></pre><p>Returns the type of <code>Columns</code> or <code>Vector</code> suitable to store values of type T. Nested tuples beget nested Columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.best_perm_estimate-Tuple{Any,Any}" href="#IndexedTables.best_perm_estimate-Tuple{Any,Any}"><code>IndexedTables.best_perm_estimate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns: (n, perm) where n is the number of columns in the beginning of <code>cols</code>, <code>perm</code> is one possible permutation of those first <code>n</code> columns.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertmissing-Tuple{IndexedTable,Type{Missing}}" href="#IndexedTables.convertmissing-Tuple{IndexedTable,Type{Missing}}"><code>IndexedTables.convertmissing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convertmissing(tbl, missingtype)</code></pre><p>Convert the missing value representation in <code>tbl</code> to be of type <code>missingtype</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">using IndexedTables, DataValues
t = table([1,2,missing], [1,missing,3])
IndexedTables.convertmissing(t, DataValue)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.excludecols-Tuple{Any,Any}" href="#IndexedTables.excludecols-Tuple{Any,Any}"><code>IndexedTables.excludecols</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">excludecols(itr, cols) -&gt; Tuple of Int</code></pre><p>Names of all columns in <code>itr</code> except <code>cols</code>. <code>itr</code> can be any of <code>Table</code>, <code>NDSparse</code>, <code>Columns</code>, or <code>AbstractVector</code></p><p><strong>Examples</strong></p><pre><code class="language-none">using IndexedTables: excludecols

t = table([2,1],[1,3],[4,5], names=[:x,:y,:z], pkey=(1,2))

excludecols(t, (:x,))
excludecols(t, (2,))
excludecols(t, pkeynames(t))
excludecols([1,2,3], (1,))</code></pre></div></div></section><footer><hr/></footer></article></body></html>
