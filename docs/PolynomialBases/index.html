<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PolynomialBases.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PolynomialBases.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.ClenshawCurtis" href="#PolynomialBases.ClenshawCurtis"><code>PolynomialBases.ClenshawCurtis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ClenshawCurtis{T}</code></pre><p>The nodal basis corresponding to the Clenshaw Curtis quadrature in [-1,1] with scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.ClenshawCurtis" href="#PolynomialBases.ClenshawCurtis"><code>PolynomialBases.ClenshawCurtis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ClenshawCurtis(p::Int, T=Float64)</code></pre><p>Generate the <code>ClenshawCurtis</code> basis of degree <code>p</code> with scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.ClosedNewtonCotes" href="#PolynomialBases.ClosedNewtonCotes"><code>PolynomialBases.ClosedNewtonCotes</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ClosedNewtonCotes{T}</code></pre><p>The nodal basis corresponding to the closed Newton Cotes quadrature in [-1,1] with scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.ClosedNewtonCotes" href="#PolynomialBases.ClosedNewtonCotes"><code>PolynomialBases.ClosedNewtonCotes</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ClosedNewtonCotes(p::Int, T=Float64)</code></pre><p>Generate the <code>ClosedNewtonCotes</code> basis of degree <code>p</code> with scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.GaussJacobi" href="#PolynomialBases.GaussJacobi"><code>PolynomialBases.GaussJacobi</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GaussJacobi{T&lt;:Real}</code></pre><p>The nodal basis corresponding to Jacobi Gauss quadrature in [-1,1] with parameters <code>α</code>, <code>β</code> and scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.GaussJacobi" href="#PolynomialBases.GaussJacobi"><code>PolynomialBases.GaussJacobi</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GaussJacobi(p::Int, α, β, T=Float64)</code></pre><p>Generate the <code>JacobiLegendre</code> basis of degree <code>p</code> with parameters <code>α</code>, <code>β</code> and scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.GaussLegendre" href="#PolynomialBases.GaussLegendre"><code>PolynomialBases.GaussLegendre</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GaussLegendre{T}</code></pre><p>The nodal basis corresponding to Legendre Gauss quadrature in [-1,1] with scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.GaussLegendre" href="#PolynomialBases.GaussLegendre"><code>PolynomialBases.GaussLegendre</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GaussLegendre(p::Int, T=Float64)</code></pre><p>Generate the <code>GaussLegendre</code> basis of degree <code>p</code> with scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.LobattoLegendre" href="#PolynomialBases.LobattoLegendre"><code>PolynomialBases.LobattoLegendre</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LobattoLegendre{T}</code></pre><p>The nodal basis corresponding to Legendre Gauss Lobatto quadrature in [-1,1] with scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.LobattoLegendre" href="#PolynomialBases.LobattoLegendre"><code>PolynomialBases.LobattoLegendre</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LobattoLegendre(p::Int, T=Float64)</code></pre><p>Generate the <code>LobattoLegendre</code> basis of degree <code>p</code> with scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.change_basis!-Union{Tuple{Domain}, Tuple{Any,NodalBasis{Domain},Any,NodalBasis{Domain}}} where Domain&lt;:PolynomialBases.AbstractDomain" href="#PolynomialBases.change_basis!-Union{Tuple{Domain}, Tuple{Any,NodalBasis{Domain},Any,NodalBasis{Domain}}} where Domain&lt;:PolynomialBases.AbstractDomain"><code>PolynomialBases.change_basis!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">change_basis!(ret, dest_basis::NodalBasis{Domain},
              values, src_basis::NodalBasis{Domain}) where {Domain&lt;:AbstractDomain}</code></pre><p>Perform the change of basis for the coefficients <code>values</code> from <code>src_basis</code> to <code>dest_basis</code> and store the resulting coefficients in <code>ret</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.change_basis-Union{Tuple{Domain}, Tuple{NodalBasis{Domain},Any,NodalBasis{Domain}}} where Domain&lt;:PolynomialBases.AbstractDomain" href="#PolynomialBases.change_basis-Union{Tuple{Domain}, Tuple{NodalBasis{Domain},Any,NodalBasis{Domain}}} where Domain&lt;:PolynomialBases.AbstractDomain"><code>PolynomialBases.change_basis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function change_basis(dest_basis::NodalBasis{Domain},
                      values, src_basis::NodalBasis{Domain}) where {Domain&lt;:AbstractDomain}</code></pre><p>Perform the change of basis for the coefficients <code>values</code> from <code>src_basis</code> to <code>dest_basis</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.compute_coefficients!-Tuple{AbstractArray{T,1} where T,Any,NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.compute_coefficients!-Tuple{AbstractArray{T,1} where T,Any,NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.compute_coefficients!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">compute_coefficients!(uval::AbstractVector, u, basis::NodalBasis{Line})</code></pre><p>Compute the nodal values of the function <code>u</code> at the nodes corresponding to the nodal basis <code>basis</code> and store the result in <code>uval</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.compute_coefficients-Tuple{Any,NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.compute_coefficients-Tuple{Any,NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.compute_coefficients</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">compute_coefficients(u, basis::NodalBasis{Line})</code></pre><p>Compute the nodal values of the function <code>u</code> at the nodes corresponding to the nodal basis <code>basis</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.derivative_at-Tuple{Real,Any,Any,Any}" href="#PolynomialBases.derivative_at-Tuple{Real,Any,Any,Any}"><code>PolynomialBases.derivative_at</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">derivative_at(x::Real, values, nodes, baryweights)</code></pre><p>Compute the derivative of the function represented by <code>values</code> on the <code>nodes</code> at <code>x</code> using the corresponding barycentric weights <code>baryweights</code>. [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 36].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.derivative_matrix-Tuple{Any,Any}" href="#PolynomialBases.derivative_matrix-Tuple{Any,Any}"><code>PolynomialBases.derivative_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">derivative_matrix(nodes, baryweights)</code></pre><p>Compute the derivative matrix corresponding to <code>nodes</code> and <code>baryweights</code>. [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 37].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.evaluate_coefficients" href="#PolynomialBases.evaluate_coefficients"><code>PolynomialBases.evaluate_coefficients</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluate_coefficients(u, basis::NodalBasis{Line}, npoints=2*length(basis.nodes))</code></pre><p>Evaluate the coefficients <code>u</code> of the nodal basis <code>basis</code> at <code>npoints</code> equally spaced nodes. Returns <code>xplot, uplot</code>, where <code>xplot</code> contains the equally spaced nodes and <code>uplot</code> the corresponding values of <code>u</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.evaluate_coefficients!-Tuple{Any,Any,Any,NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.evaluate_coefficients!-Tuple{Any,Any,Any,NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.evaluate_coefficients!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">evaluate_coefficients!(xplot, uplot, u, basis::NodalBasis{Line})</code></pre><p>Evaluate the coefficients <code>u</code> of the nodal basis <code>basis</code> at <code>npoints</code> equally spaced nodes and store the result in <code>xplot, uplot</code>. Returns <code>xplot, uplot</code>, where <code>xplot</code> contains the equally spaced nodes and <code>uplot</code> the corresponding values of <code>u</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.gegenbauer-Tuple{Any,Integer,Any}" href="#PolynomialBases.gegenbauer-Tuple{Any,Integer,Any}"><code>PolynomialBases.gegenbauer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gegenbauer(x, p::Integer)</code></pre><p>Evaluate the Gegenbauer polynomial with parameter <code>α</code> of degree <code>p</code> at <code>x</code> using the three term recursion.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.hahn-Tuple{Any,Integer,Any,Any,Any}" href="#PolynomialBases.hahn-Tuple{Any,Integer,Any,Any,Any}"><code>PolynomialBases.hahn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hahn(x, p::Integer, α, β, N::Integer)</code></pre><p>Evaluate the Hahn polynomial with parameters <code>α</code>, <code>β</code>, <code>N</code> of degree <code>p</code> at <code>x</code> using the three term recursion [Öffner, Zweidimensionale klassische und diskrete orthogonale Polynome, Chapter 5].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.hermite-Tuple{Any,Integer}" href="#PolynomialBases.hermite-Tuple{Any,Integer}"><code>PolynomialBases.hermite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hermite(x, p::Integer)</code></pre><p>Evaluate the Hermite polynomial of degree <code>p</code> at <code>x</code> using the three term recursion.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.integrate-Tuple{Any,Any,AbstractArray{T,1} where T}" href="#PolynomialBases.integrate-Tuple{Any,Any,AbstractArray{T,1} where T}"><code>PolynomialBases.integrate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">integrate(func, u, weights)</code></pre><p>Map the function <code>func</code> to the coefficients <code>u</code> and integrate with respect to the quadrature rule given by <code>weights</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.interpolate-Tuple{Real,Any,Any,Any}" href="#PolynomialBases.interpolate-Tuple{Real,Any,Any,Any}"><code>PolynomialBases.interpolate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interpolate(x::Real, nodes, values, baryweights)</code></pre><p>Interpolate the function represented by <code>values</code> on the <code>nodes</code> using the corresponding barycentric weights <code>baryweights</code>. [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 31].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.interpolation_matrix-Tuple{Any,Any,Any}" href="#PolynomialBases.interpolation_matrix-Tuple{Any,Any,Any}"><code>PolynomialBases.interpolation_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interpolation_matrix(destination, source, baryweights)</code></pre><p>Compute the matrix performing interpolation from <code>src</code> to <code>dest</code>, where <code>baryweights</code> are the barycentric weights corresponding to <code>src</code>. [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 32].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.jacobi-Tuple{Any,Integer,Any,Any}" href="#PolynomialBases.jacobi-Tuple{Any,Integer,Any,Any}"><code>PolynomialBases.jacobi</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">jacobi(x, p::Integer, α, β)</code></pre><p>Evaluate the Legendre polynomial with parameters <code>α</code>, <code>β</code> of degree <code>p</code> at <code>x</code> using the three term recursion [Karniadakis and Sherwin, Spectral/hp Element Methods for CFD, Appendix A].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.jacobi_vandermonde-Tuple{AbstractArray{T,1} where T,Any,Any}" href="#PolynomialBases.jacobi_vandermonde-Tuple{AbstractArray{T,1} where T,Any,Any}"><code>PolynomialBases.jacobi_vandermonde</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">jacobi_vandermonde(nodes, α, β)</code></pre><p>Computes the Vandermonde matrix with respect to the Jacobi polynomials with parameters <code>α</code>, <code>β</code> and the nodal basis on <code>nodes</code>. The Vandermonde matrix <code>V</code> is the transformation matrix from the modal Jacobi basis to the nodal Lagrange basis associated with <code>nodes</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.laguerre-Tuple{Any,Integer,Any}" href="#PolynomialBases.laguerre-Tuple{Any,Integer,Any}"><code>PolynomialBases.laguerre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">laguerre(x, p::Integer, α)</code></pre><p>Evaluate the generalised Laguerre polynomial with parameter <code>α</code> of degree <code>p</code> at <code>x</code> using the three term recursion.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.laguerre-Tuple{Any,Integer}" href="#PolynomialBases.laguerre-Tuple{Any,Integer}"><code>PolynomialBases.laguerre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">laguerre(x, p::Integer)</code></pre><p>Evaluate the Laguerre polynomial of degree <code>p</code> at <code>x</code> using the three term recursion.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.legendre-Tuple{Any,Integer}" href="#PolynomialBases.legendre-Tuple{Any,Integer}"><code>PolynomialBases.legendre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">legendre(x, p::Integer)</code></pre><p>Evaluate the Legendre polynomial of degree <code>p</code> at <code>x</code> using the three term recursion [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 20].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.legendre_D" href="#PolynomialBases.legendre_D"><code>PolynomialBases.legendre_D</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">legendre_D(p, T=Float64)</code></pre><p>Computes the derivative matrix in the modal Legendre basis up to degree <code>p</code> using the scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.legendre_M" href="#PolynomialBases.legendre_M"><code>PolynomialBases.legendre_M</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">legendre_M(p, T=Float64)</code></pre><p>Computes the diagonal mass matrix in the modal Legendre basis up to degree <code>p</code> using the scalar type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.legendre_vandermonde-Tuple{AbstractArray{T,1} where T}" href="#PolynomialBases.legendre_vandermonde-Tuple{AbstractArray{T,1} where T}"><code>PolynomialBases.legendre_vandermonde</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">legendre_vandermonde(nodes)</code></pre><p>Computes the Vandermonde matrix with respect to the Legendre polynomials and the nodal basis on <code>nodes</code>. The Vandermonde matrix <code>V</code> is the transformation matrix from the modal Legendre basis to the nodal Lagrange basis associated with <code>nodes</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.map_from_canonical!-Tuple{Any,Any,Any,Any,NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.map_from_canonical!-Tuple{Any,Any,Any,Any,NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.map_from_canonical!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map_from_canonical!(x, ξ, xmin, xmax, basis::NodalBasis{Line})</code></pre><p>Map the given canonical coordinate <code>ξ</code> in the interval [-1, 1] to the corresponding coordinate <code>x</code> in the interval [<code>xmin</code>, <code>xmax</code>], updating <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.map_from_canonical-Tuple{Any,Any,Any,NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.map_from_canonical-Tuple{Any,Any,Any,NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.map_from_canonical</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map_from_canonical(ξ, xmin, xmax, basis::NodalBasis{Line})</code></pre><p>Map the given canonical coordinate <code>ξ</code> in the interval [-1, 1] to the corresponding coordinate <code>x</code> in the interval [<code>xmin</code>, <code>xmax</code>].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.map_to_canonical!-Tuple{Any,Any,Any,Any,NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.map_to_canonical!-Tuple{Any,Any,Any,Any,NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.map_to_canonical!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map_to_canonical!(ξ, x, xmin, xmax, basis::NodalBasis{Line})</code></pre><p>Map the given coordinate <code>x</code> in the interval [<code>xmin</code>, <code>xmax</code>] to the corresponding canonical coordinate <code>ξ</code> in the interval [-1, 1], updating <code>ξ</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.map_to_canonical-Tuple{Any,Any,Any,NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.map_to_canonical-Tuple{Any,Any,Any,NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.map_to_canonical</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">map_to_canonical(x, xmin, xmax, basis::NodalBasis{Line})</code></pre><p>Map the given coordinate <code>x</code> in the interval [<code>xmin</code>, <code>xmax</code>] to the corresponding canonical coordinate <code>ξ</code> in the interval [-1, 1].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.utility_matrices-Tuple{NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.utility_matrices-Tuple{NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.utility_matrices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">utility_matrices(basis::NodalBasis{Line})</code></pre><p>Return the matrices</p><ul><li><code>D</code>, derivative matrix</li><li><code>M</code>, mass matrix</li><li><code>R</code>, restriction matrix (interpolation to the boundaries)</li><li><code>B</code>, boundary normal matrix</li><li><code>MinvRtB = M \ R&#39; * B</code></li></ul><p>used in the formulation of flux reconstruction / correction procedure via reconstruction using summation-by-parts operators, cf. Ranocha, Öffner, Sonar (2016) Summation-by-parts operators for correction procedure via reconstruction, Journal of Computational Physics 311, 299-328.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.barycentric_weights-Tuple{AbstractArray{T,1} where T}" href="#PolynomialBases.barycentric_weights-Tuple{AbstractArray{T,1} where T}"><code>PolynomialBases.barycentric_weights</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">barycentric_weights{T&lt;:Real}(x::AbstractVector{T})</code></pre><p>Compute the barycentric weights corresponding to the nodes <code>x</code>. [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 30].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.degree-Tuple{NodalBasis{PolynomialBases.Line}}" href="#PolynomialBases.degree-Tuple{NodalBasis{PolynomialBases.Line}}"><code>PolynomialBases.degree</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">degree(basis::NodalBasis{Line})</code></pre><p>Return the polynomial degree used by <code>basis</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.gauss_jacobi_nodes_and_weights" href="#PolynomialBases.gauss_jacobi_nodes_and_weights"><code>PolynomialBases.gauss_jacobi_nodes_and_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gauss_jacobi_nodes_and_weights(p, α, β, T=Float64::Type, tol=4*eps(T), maxit=100)</code></pre><p>Compute the Gauss-Jacobi nodes and weights for polynomials of degree <code>p</code> with parameters <code>α</code>, <code>β</code> using the scalar type <code>T</code>, tolerance <code>tol</code> and maximal number of Newton iterations <code>maxit</code> [Karniadakis and Sherwin, Spectral/hp Element Methods for CFD, Appendix B].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.gauss_legendre_nodes_and_weights" href="#PolynomialBases.gauss_legendre_nodes_and_weights"><code>PolynomialBases.gauss_legendre_nodes_and_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gauss_legendre_nodes_and_weights(p, T=Float64::Type, tol=4*eps(T), maxit=100)</code></pre><p>Compute the Gauss-Legendre nodes and weights for polynomials of degree <code>p</code> using the scalar type <code>T</code>, tolerance <code>tol</code> and maximal number of Newton iterations <code>maxit</code> [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 23].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.jacobi_and_derivative-Tuple{Any,Integer,Any,Any}" href="#PolynomialBases.jacobi_and_derivative-Tuple{Any,Integer,Any,Any}"><code>PolynomialBases.jacobi_and_derivative</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">jacobi_and_derivative(x, p::Integer, α, β)</code></pre><p>Evaluate the Jacobi polynomial with parameters <code>α</code>, <code>β</code> of degree <code>p</code> and its derivative at <code>x</code> using the three term recursion [Karniadakis and Sherwin, Spectral/hp Element Methods for CFD, Appendix A].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.legendre_and_derivative-Tuple{Any,Integer}" href="#PolynomialBases.legendre_and_derivative-Tuple{Any,Integer}"><code>PolynomialBases.legendre_and_derivative</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">legendre_and_derivative(x, p::Integer)</code></pre><p>Evaluate the Legendre polynomial of degree <code>p</code> and its derivative at <code>x</code> using the three term recursion [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 22].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolynomialBases.lobatto_legendre_nodes_and_weights" href="#PolynomialBases.lobatto_legendre_nodes_and_weights"><code>PolynomialBases.lobatto_legendre_nodes_and_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lobatto_legendre_nodes_and_weights(p, T=Float64::Type, tol=4*eps(T), maxit=100)</code></pre><p>Compute the Lobatto-Legendre nodes and weights for polynomials of degree <code>p</code> using the scalar type <code>T</code>, tolerance <code>tol</code> and maximal number of Newton iterations <code>maxit</code> [Kopriva, Implementing Spectral Methods for PDEs, Algorithm 25].</p></div></div></section><footer><hr/></footer></article></body></html>
