<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · JLD2.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JLD2.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.jldopen" href="#JLD2.jldopen"><code>JLD2.jldopen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jldopen(fname::AbstractString, mode::AbstractString)</code></pre><p>Opens a JLD file at path <code>fname</code>.</p><p><code>&quot;r&quot;</code>: Open for reading only, failing if no file exists <code>&quot;r+&quot;</code>: Open for reading and writing, failing if no file exists <code>&quot;w&quot;</code>/<code>&quot;w+&quot;</code>: Open for reading and writing, overwriting the file if it already exists <code>&quot;a&quot;</code>/<code>&quot;a+&quot;</code>: Open for reading and writing, creating a new file if none exists, but               preserving the existing file if one is present</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.CustomSerialization" href="#JLD2.CustomSerialization"><code>JLD2.CustomSerialization</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CustomSerialization{T,S}</code></pre><p>On-disk representation for data that is written as if it were of Julia type <code>T</code>, but is read as type <code>S</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.GlobalHeap" href="#JLD2.GlobalHeap"><code>JLD2.GlobalHeap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GlobalHeap</code></pre><p>Represents an HDF5 global heap structure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.Group" href="#JLD2.Group"><code>JLD2.Group</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Group{T}</code></pre><p>JLD group object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.Group-Tuple{JLD2.JLDFile,AbstractString}" href="#JLD2.Group-Tuple{JLD2.JLDFile,AbstractString}"><code>JLD2.Group</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Group(f::JLDFile, name::AbstractString)</code></pre><p>Construct an empty group named <code>name</code> at the top level of <code>JLDFile</code> <code>f</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.Group-Union{Tuple{T}, Tuple{Group{T},AbstractString}} where T" href="#JLD2.Group-Union{Tuple{T}, Tuple{Group{T},AbstractString}} where T"><code>JLD2.Group</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Group(g::Group, name::AbstractString)</code></pre><p>Construct a group named <code>name</code> as a child of group <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.H5Datatype" href="#JLD2.H5Datatype"><code>JLD2.H5Datatype</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">H5Datatype</code></pre><p>Supertype of all HDF5 datatypes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.IndirectPointer" href="#JLD2.IndirectPointer"><code>JLD2.IndirectPointer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IndirectPointer</code></pre><p>When writing data, we may need to enlarge the memory mapping, which would invalidate any memory addresses arising from the old <code>mmap</code> pointer. <code>IndirectPointer</code> holds a pointer to the <code>startptr</code> field of an MmapIO, and the offset relative to that pointer. It defers computing a memory address until converted to a Ptr{T}, so the memory mapping can be enlarged and addresses will remain valid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.JLDFile" href="#JLD2.JLDFile"><code>JLD2.JLDFile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">JLDFile{T&lt;:IO}</code></pre><p>JLD file object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.JLDWriteSession" href="#JLD2.JLDWriteSession"><code>JLD2.JLDWriteSession</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">JLDWriteSession{T}</code></pre><p>A JLDWriteSession keeps track of references to serialized objects. If <code>T</code> is a Dict, <code>h5offset</code> maps an object ID (returned by calling <code>objectid</code>) to th <code>RelOffset</code> of the written dataset. If it is <code>Union{}</code>, then references are not tracked, and objects referenced multiple times are written multiple times.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.ReadRepresentation" href="#JLD2.ReadRepresentation"><code>JLD2.ReadRepresentation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ReadRepresentation{T,ODR}</code></pre><p>A type encoding both the Julia type <code>T</code> and the on-disk (HDF5) representation <code>ODR</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.RelOffset" href="#JLD2.RelOffset"><code>JLD2.RelOffset</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RelOffset</code></pre><p>Represents an HDF5 relative offset. This differs from a file offset (used elsewhere) in that it is relative to the superblock base address. In practice, this means that <code>FILE_HEADER_LENGTH</code>has been subtracted. <code>fileoffset</code> and <code>h5offset</code> convert between <code>RelOffsets</code> and file offsets.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.TypeMappingException" href="#JLD2.TypeMappingException"><code>JLD2.TypeMappingException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>constructrr(f::JLDFile, T::DataType, dt::CompoundType, attrs::Vector{ReadAttribute},             hard_failure::Bool=false)</p><p>Constructs a ReadRepresentation for a given type. This is the generic method for all types not specially handled below.</p><p>If hard_failure is true, then throw a TypeMappingException instead of attempting reconstruction. This helps in cases where we can&#39;t know if reconstructed parametric types will have a matching memory layout without first inspecting the memory layout.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.behead-Tuple{UnionAll}" href="#JLD2.behead-Tuple{UnionAll}"><code>JLD2.behead</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">behead(T)</code></pre><p>Given a UnionAll type, recursively eliminates the <code>where</code> clauses</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.construct_array-Union{Tuple{T}, Tuple{IO,Type{T},Int64}} where T" href="#JLD2.construct_array-Union{Tuple{T}, Tuple{IO,Type{T},Int64}} where T"><code>JLD2.construct_array</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">construct_array{T}(io::IO, ::Type{T}, ndims::Int)</code></pre><p>Construct array by reading <code>ndims</code> dimensions from <code>io</code>. Assumes <code>io</code> has already been seeked to the correct position.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.fileoffset-Tuple{JLD2.JLDFile,JLD2.RelOffset}" href="#JLD2.fileoffset-Tuple{JLD2.JLDFile,JLD2.RelOffset}"><code>JLD2.fileoffset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fileoffset(f::JLDFile, x::RelOffset)</code></pre><p>Converts an offset <code>x</code> relative to the superblock of file <code>f</code> to an absolute offset.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.group_payload_size-Tuple{Any}" href="#JLD2.group_payload_size-Tuple{Any}"><code>JLD2.group_payload_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">group_payload_size(pairs)</code></pre><p>Returns the size of a group payload, including link info, group info, and link messages, but not the object header. <code>pairs</code> is an iterator of <code>String =&gt; RelOffset</code> pairs. Provides space after the last object message for a continuation message.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.h5offset-Tuple{JLD2.JLDFile,Int64}" href="#JLD2.h5offset-Tuple{JLD2.JLDFile,Int64}"><code>JLD2.h5offset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">h5offset(f::JLDFile, x::RelOffset)</code></pre><p>Converts an absolute file offset <code>x</code> to an offset relative to the superblock of file <code>f</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.jld_finalizer-Tuple{JLD2.JLDFile{JLD2.MmapIO}}" href="#JLD2.jld_finalizer-Tuple{JLD2.JLDFile{JLD2.MmapIO}}"><code>JLD2.jld_finalizer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">jld_finalizer(f::JLDFile)</code></pre><p>When a JLDFile is finalized, it is possible that the <code>MmapIO</code> has been munmapped, since Julia does not guarantee finalizer order. This means that the underlying file may be closed before we get a chance to write to it.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.link_size-Tuple{String}" href="#JLD2.link_size-Tuple{String}"><code>JLD2.link_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">link_size(name::String)</code></pre><p>Returns the size of a link message, including message header.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.links_size-Tuple{Any}" href="#JLD2.links_size-Tuple{Any}"><code>JLD2.links_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">links_size(pairs)</code></pre><p>Returns the size of several link messages. <code>pairs</code> is an iterator of <code>String =&gt; RelOffset</code> pairs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.load_datatypes-Tuple{JLD2.JLDFile}" href="#JLD2.load_datatypes-Tuple{JLD2.JLDFile}"><code>JLD2.load_datatypes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">load_datatypes(f::JLDFile)</code></pre><p>Populate f.datatypes and f.jlh5types with all of the committed datatypes from a file. We need to do this before writing to make sure we reuse written datatypes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.lookup_offset-Tuple{JLD2.Group,AbstractString}" href="#JLD2.lookup_offset-Tuple{JLD2.Group,AbstractString}"><code>JLD2.lookup_offset</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lookup_offset(g::Group, name::AbstractString) -&gt; RelOffset</code></pre><p>Lookup the offset of a dataset in a group. Returns <code>UNDEFINED_ADDRESS</code> if the dataset is not present. Does not inspect <code>unwritten_child_groups</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.pathize-Tuple{JLD2.Group,AbstractString,Bool}" href="#JLD2.pathize-Tuple{JLD2.Group,AbstractString,Bool}"><code>JLD2.pathize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pathize(g::Group, name::AbstractString, create::Bool) -&gt; Tuple{Group,String}</code></pre><p>Converts a path to a group and name object. If <code>create</code> is true, any intermediate groups will be created, and the dataset name will be checked for uniqueness with existing names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.prewrite-Tuple{JLD2.JLDFile}" href="#JLD2.prewrite-Tuple{JLD2.JLDFile}"><code>JLD2.prewrite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prewrite(f::JLDFile)</code></pre><p>Check that a JLD file is actually writable, and throw an error if not. Sets the <code>written</code> flag on the file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.read_array!" href="#JLD2.read_array!"><code>JLD2.read_array!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read_array!(v::Array, f::JLDFile, rr)</code></pre><p>Fill the array <code>v</code> with the contents of JLDFile <code>f</code> at the current position, assuming a ReadRepresentation <code>rr</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.read_attr_data-Tuple{JLD2.JLDFile,JLD2.ReadAttribute,JLD2.H5Datatype,JLD2.ReadRepresentation}" href="#JLD2.read_attr_data-Tuple{JLD2.JLDFile,JLD2.ReadAttribute,JLD2.H5Datatype,JLD2.ReadRepresentation}"><code>JLD2.read_attr_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">read_attr_data(f::JLDFile, attr::ReadAttribute, expected_datatype::H5Datatype,
               rr::ReadRepresentation)</code></pre><p>Read data from an attribute, assuming a specific HDF5 datatype and ReadRepresentation. If the HDF5 datatype does not match, throws an <code>UnsupportedFeatureException</code>. This allows better type stability while simultaneously validating the data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.read_attr_data-Tuple{JLD2.JLDFile,JLD2.ReadAttribute}" href="#JLD2.read_attr_data-Tuple{JLD2.JLDFile,JLD2.ReadAttribute}"><code>JLD2.read_attr_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">read_attr_data(f::JLDFile, attr::ReadAttribute)</code></pre><p>Read data from an attribute.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.read_compressed_array!" href="#JLD2.read_compressed_array!"><code>JLD2.read_compressed_array!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read_compressed_array!(v::Array, f::JLDFile, rr, data_length::Int)</code></pre><p>Fill the array <code>v</code> with the compressed contents of JLDFile <code>f</code> at the current position, assuming a ReadRepresentation <code>rr</code> and that the compressed data has length <code>data_length</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.read_data" href="#JLD2.read_data"><code>JLD2.read_data</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read_data(f::JLDFile, dataspace::ReadDataspace, datatype_class::UInt8,
          datatype_offset::Int64, data_offset::Int64[, filter_id::UInt16,
          header_offset::RelOffset, attributes::Vector{ReadAttribute}])</code></pre><p>Read data from a file. If <code>datatype_class</code> is typemax(UInt8), the datatype is assumed to be committed, and <code>datatype_offset</code> points to the offset of the committed datatype&#39;s header. Otherwise, datatype_offset points to the offset of the datatype attribute.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.read_scalar" href="#JLD2.read_scalar"><code>JLD2.read_scalar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read_scalar(f::JLDFile, rr, header_offset::RelOffset)</code></pre><p>Read raw data representing a scalar with read representation <code>rr</code> from the current position of JLDFile <code>f</code>. <code>header_offset</code> is the RelOffset of the object header, used to resolve cycles.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.read_size-Tuple{IO,UInt8}" href="#JLD2.read_size-Tuple{IO,UInt8}"><code>JLD2.read_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">read_size(io::IO, flags::UInt8)</code></pre><p>Loads a variable-length size according to flags Expects that the first two bits of flags mean: 0   The size of the Length of Link Name field is 1 byte. 1   The size of the Length of Link Name field is 2 bytes. 2   The size of the Length of Link Name field is 4 bytes. 3   The size of the Length of Link Name field is 8 bytes. Returns the size as an Int</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.save_group-Tuple{JLD2.Group}" href="#JLD2.save_group-Tuple{JLD2.Group}"><code>JLD2.save_group</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">save_group(g::Group) -&gt; RelOffset</code></pre><p>Stores a group to a file, updating it if it has already been saved. Returns UNDEFINED_ADDRESS if the group was already stored, or the offset of the new group otherwise.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JLD2.symbol_length-Tuple{Symbol}" href="#JLD2.symbol_length-Tuple{Symbol}"><code>JLD2.symbol_length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symbol_length(x::Symbol)</code></pre><p>Returns the length of the string represented by <code>x</code>.</p></div></div></section><footer><hr/></footer></article></body></html>
