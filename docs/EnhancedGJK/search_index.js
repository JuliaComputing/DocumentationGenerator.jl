var documenterSearchIndex = {"docs": [

{
    "location": "#EnhancedGJK.NeighborMesh",
    "page": "Home",
    "title": "EnhancedGJK.NeighborMesh",
    "category": "type",
    "text": "The NeighborMesh is what actually makes EnhancedGJK \"enhanced\". It consists of a mesh and a pre-computed set of neighbors for each vertex. These neighbors will be searched when the GJK simplex is refined. Searching over just the neighbors of a particular vertex allows us to avoid repeatedly searching over every vertex in the mesh.\n\nNote that constructing a new NeighborMesh is expensive (and unoptimized). We recommend constructing the NeighborMesh for each of your meshes ahead of time.\n\n\n\n\n\n"
},

{
    "location": "#EnhancedGJK.Tagged",
    "page": "Home",
    "title": "EnhancedGJK.Tagged",
    "category": "type",
    "text": "The enhanced GJK algorithm relies on a pre-computed set of neighbors for each vertex in the mesh. In order to use those neighbors, we have to know from which vertex to start. Specifically, we need to know the index of the vertex corresponding to the point in the GJK simplex which we are trying to improve. To do that, we introduce the notion of a Tagged point. A tagged point is just a point and some arbitrary additional data field. All of the any_inside and support_vector_max functions in this package return tagged points. For most geometries, that tag is empty (nothing). But for our NeighborMesh type, the tag is the linear index into the vertices of the mesh, which lets us look up that mesh\'s neighbors faster later on.\n\n\n\n\n\n"
},

{
    "location": "#EnhancedGJK.johnson_subsets-Tuple{Integer}",
    "page": "Home",
    "title": "EnhancedGJK.johnson_subsets",
    "category": "method",
    "text": "Compute all subsets of the points in the simplex in a reliable order. The order is arbitrary, but was chosen to match the implemenation in S. Cameron, “Enhancing GJK: computing minimum and penetration distances between convex polyhedra,”. Specifically, subset i contains point j iff the binary representation of i has a one at the jth bit.\n\n\n\n\n\n"
},

{
    "location": "#EnhancedGJK.projection_weights-Union{Tuple{SArray{Tuple{M},SArray{Tuple{N},T,1,N},1,M}}, Tuple{T}, Tuple{N}, Tuple{M}} where T where N where M",
    "page": "Home",
    "title": "EnhancedGJK.projection_weights",
    "category": "method",
    "text": "weights = projection_weights(simplex)\n\nThis function implements Johnson\'s distance subalgorithm, as described in E. G. Gilbert, D. W. Johnson, and S. S. Keerthi, “A fast procedure for computing the distance between complex objects in three-dimensional space,”\n\nGiven a simplex (a length N+1 vector of points of dimension N), it\n\nreturns weights such that dot(weights, simplex) yields the point in the convex hull of the simplex which is closest to the origin.\n\nThis is the critical loop of the GJK algorithm, so it has been heavily optimized to precompute, inline, and unroll as much of the algorithm as possible. For a more readable (and much slower) implementation, see projectionweightsreference()\n\n\n\n\n\n"
},

{
    "location": "#EnhancedGJK.projection_weights_impl-Union{Tuple{Type{SArray{Tuple{M},SArray{Tuple{N},T,1,N},1,M}}}, Tuple{T}, Tuple{N}, Tuple{M}} where T where N where M",
    "page": "Home",
    "title": "EnhancedGJK.projection_weights_impl",
    "category": "method",
    "text": "This is the function which actually computes the weight values. It returns an expression to compute that result, with all loops unrolled and all indices pre-computed based on the size and dimension of the simplex. For a more readable version of the same function, check out projectionweightsreference().\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [EnhancedGJK]\nOrder = [:type, :function]"
},

]}
