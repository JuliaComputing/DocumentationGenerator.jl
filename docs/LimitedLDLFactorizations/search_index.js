var documenterSearchIndex = {"docs": [

{
    "location": "#LimitedLDLFactorizations.lldl-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti<:Integer where Tv<:Number",
    "page": "Home",
    "title": "LimitedLDLFactorizations.lldl",
    "category": "method",
    "text": "lldl(A)\n\nCompute the limited-memory LDLᵀ factorization of A without pivoting.\n\nArguments\n\nA::SparseMatrixCSC{Tv,Ti}: matrix to factorize (its strict lower triangle and                              diagonal will be extracted)\n\nKeyword arguments\n\nmemory::Int=0: extra amount of memory to allocate for the incomplete factor L.                  The total memory allocated is nnz(T) + n * memory, where                  T is the strict lower triangle of A and n is the size of A.\nα::Tv=Tv(0): initial value of the shift in case the incomplete LDLᵀ                factorization of A is found to not exist. The shift will be                gradually increased from this initial value until success.\ndroptol::Tv=Tv(0): to further sparsify L, all elements with magnitude smaller                      than droptol are dropped.\n\n\n\n\n\n"
},

{
    "location": "#LimitedLDLFactorizations.abspermute!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Array{Tv,1},AbstractArray{Ti,1},Ti}} where Ti<:Integer where Tv<:Number",
    "page": "Home",
    "title": "LimitedLDLFactorizations.abspermute!",
    "category": "method",
    "text": "Permute the elements of keys in place so that\n\nabs(x[keys[i]]) ≤ abs(x[keys[k]])  for i = 1, ..., k\nabs(x[keys[k]]) ≤ abs(x[keys[i]])  for i = k, ..., n,\n\nwhere n is the length of keys. The length of x should be at least n. Only keys is modified.\n\nFrom the MINPACK2 function dsel2 by Kastak, Lin and Moré.\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [LimitedLDLFactorizations]\nOrder = [:type, :function]"
},

]}
