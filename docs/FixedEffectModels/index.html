<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FixedEffectModels.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FixedEffectModels.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedEffectModels.partial_out-Tuple{DataFrames.AbstractDataFrame,Model}" href="#FixedEffectModels.partial_out-Tuple{DataFrames.AbstractDataFrame,Model}"><code>FixedEffectModels.partial_out</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Partial out variables in a Dataframe</p><p><strong>Arguments</strong></p><ul><li><code>df::AbstractDataFrame</code></li><li><code>model::Model</code>: A <code>Model</code> created using <code>@model</code>. See <code>@model</code>.</li><li><code>add_mean::Bool</code>: Should the initial mean added to the returned variable?</li><li><code>method::Symbol</code>: A symbol for the method. Default is :lsmr (akin to conjugate gradient descent). Other choices are :qr and :cholesky (factorization methods)</li><li><code>maxiter::Integer</code>: Maximum number of iterations</li><li><code>tol::Real</code>: Tolerance</li></ul><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code>: a dataframe with as many columns as there are dependent variables and as many rows as the original dataframe.</li><li><code>::Vector{Int}</code>: a vector of iterations for each column</li><li><code>::Vector{Bool}</code>: a vector of success for each column</li></ul><p><strong>Details</strong></p><p><code>partial_out</code> returns the residuals of a set of variables after regressing them on a set of regressors. The syntax is similar to <code>reg</code> - but it accepts multiple dependent variables. It returns a dataframe with as many columns as there are dependent variables and as many rows as the original dataframe. The regression model is estimated on only the rows where <em>none</em> of the dependent variables is missing. With the option <code>add_mean = true</code>, the mean of the initial variable is added to the residuals.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using  RDatasets, DataFrames, FixedEffectModels, Gadfly
df = dataset(&quot;datasets&quot;, &quot;iris&quot;)
df[:SpeciesC] =  categorical(df[:Species])
result = partial_out(df, @model(SepalWidth + SepalLength ~ 1, fe = SpeciesC), add_mean = true)
plot(layer(result[1], x=&quot;SepalWidth&quot;, y=&quot;SepalLength&quot;, Stat.binmean(n=10), Geom.point),
   layer(result[1], x=&quot;SepalWidth&quot;, y=&quot;SepalLength&quot;, Geom.smooth(method=:lm)))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FixedEffectModels.reg-Tuple{DataFrames.AbstractDataFrame,Model}" href="#FixedEffectModels.reg-Tuple{DataFrames.AbstractDataFrame,Model}"><code>FixedEffectModels.reg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Estimate a linear model with high dimensional categorical variables / instrumental variables</p><p><strong>Arguments</strong></p><ul><li><code>df::AbstractDataFrame</code></li><li><code>model::Model</code>: A model created using <a href="@ref"><code>@model</code></a></li><li><code>save::Union{Bool, Symbol} = false</code>: Should residuals and eventual estimated fixed effects saved in a dataframe? Use <code>save = :residuals</code> to only save residuals. Use <code>save = :fe</code> to only save fixed effects.</li><li><code>method::Symbol = :lsmr</code>: Method to deman regressors. <code>:lsmr</code> is akin to conjugate gradient descent.  With parallel use <code>:lsmr_parallel</code>. To use multi threaded use <code>lsmr_threads</code>. Other choices are <code>:qr</code> and <code>:cholesky</code> (factorization methods)</li><li><code>contrasts::Dict = Dict()</code> An optional Dict of contrast codings for each categorical variable in the <code>formula</code>.  Any unspecified variables will have <code>DummyCoding</code>.</li><li><code>maxiter::Integer = 10000</code>: Maximum number of iterations</li><li><code>tol::Real =1e-8</code>: Tolerance</li></ul><p><strong>Details</strong></p><p>Models with instruments variables are estimated using 2SLS. <code>reg</code> tests for weak instruments by computing the Kleibergen-Paap rk Wald F statistic, a generalization of the Cragg-Donald Wald F statistic for non i.i.d. errors. The statistic is similar to the one returned by the Stata command <code>ivreg2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using DataFrames, RDatasets, FixedEffectModels
df = dataset(&quot;plm&quot;, &quot;Cigar&quot;)
df[:StateC] =  categorical(df[:State])
df[:YearC] =  categorical(df[:Year])
reg(df, @model(Sales ~ Price, fe = StateC + YearC))
reg(df, @model(Sales ~ NDI, fe = StateC + StateC&amp;Year))
reg(df, @model(Sales ~ NDI, fe = StateC*Year))
reg(df, @model(Sales ~ (Price ~ Pimin)))
reg(df, @model(Sales ~ Price, weights = Pop))
reg(df, @model(Sales ~ NDI, subset = State .&lt; 30))
reg(df, @model(Sales ~ NDI, vcov = robust))
reg(df, @model(Sales ~ NDI, vcov = cluster(StateC)))
reg(df, @model(Sales ~ NDI, vcov = cluster(StateC + YearC)))
reg(df, @model(Sales ~ YearC), contrasts = Dict(:YearC =&gt; DummyCoding(base = 80)))</code></pre></div></div></section><footer><hr/></footer></article></body></html>
