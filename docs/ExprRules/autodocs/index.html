<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · ExprRules.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ExprRules.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.ExpressionIterator" href="#ExprRules.ExpressionIterator"><code>ExprRules.ExpressionIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ExpressionIterator(grammar::Grammar, max_depth::Int, sym::Symbol)</code></pre><p>An iterator over all possible expressions of a grammar up to max_depth with start symbol sym.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.Grammar" href="#ExprRules.Grammar"><code>ExprRules.Grammar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Grammar</code></pre><p>Represents a grammar and its production rules. Use the @grammar macro to create a Grammar object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.Interpreter.SymbolTable" href="#ExprRules.Interpreter.SymbolTable"><code>ExprRules.Interpreter.SymbolTable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Interpreter.SymbolTable(grammar::Grammar, mod::Module=Main)</code></pre><p>Returns a symbol table populated with mapping from symbols in grammar to symbols in module mod or Main, if defined.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.NodeLoc" href="#ExprRules.NodeLoc"><code>ExprRules.NodeLoc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NodeLoc</code></pre><p>A helper struct that points to a node in the tree via its parent such that the child can be easily swapped out. If i is 0 the node pointed to is the root node and parent is the node itself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.NodeRecycler" href="#ExprRules.NodeRecycler"><code>ExprRules.NodeRecycler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Use a circular buffer to contain used RuleNodes to be recycled. First check the recycle bin to see if there are available RuleNodes, if not allocated a new one.  This helps minimize memory allocations and improves performance</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.RuleNode" href="#ExprRules.RuleNode"><code>ExprRules.RuleNode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RuleNode</code></pre><p>Type for representing nodes in an expression tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.child_types-Tuple{Grammar,Int64}" href="#ExprRules.child_types-Tuple{Grammar,Int64}"><code>ExprRules.child_types</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">child_types(grammar::Grammar, rule_index::Int)</code></pre><p>Returns the types of the children (nonterminals) of the production rule at rule_index.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.child_types-Tuple{Grammar,RuleNode}" href="#ExprRules.child_types-Tuple{Grammar,RuleNode}"><code>ExprRules.child_types</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">child_types(grammar::Grammar, node::RuleNode)</code></pre><p>Returns the list of child types in the production rule used by node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.contains_returntype" href="#ExprRules.contains_returntype"><code>ExprRules.contains_returntype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">contains_returntype(node::RuleNode, grammar::Grammar, sym::Symbol, maxdepth::Int=typemax(Int))</code></pre><p>Returns true if the tree rooted at node contains at least one node at depth less than maxdepth with the given return type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.count_expressions-Tuple{ExpressionIterator}" href="#ExprRules.count_expressions-Tuple{ExpressionIterator}"><code>ExprRules.count_expressions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_expressions(iter::ExpressionIterator)</code></pre><p>Count the number of possible expressions in the expression iterator.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.count_expressions-Tuple{Grammar,Int64,Symbol}" href="#ExprRules.count_expressions-Tuple{Grammar,Int64,Symbol}"><code>ExprRules.count_expressions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">count_expressions(grammar::Grammar, max_depth::Int, sym::Symbol)</code></pre><p>Count the number of possible expressions of a grammar up to max_depth with start symbol sym.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.depth-Tuple{RuleNode}" href="#ExprRules.depth-Tuple{RuleNode}"><code>ExprRules.depth</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">depth(root::RuleNode)</code></pre><p>Return the depth of the expression tree rooted at root.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.get_executable-Tuple{RuleNode,Grammar}" href="#ExprRules.get_executable-Tuple{RuleNode,Grammar}"><code>ExprRules.get_executable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_executable(rulenode::RuleNode, grammar::Grammar)</code></pre><p>Returns the executable julia expression represented in the expression tree with root rulenode.  The returned expression can be evaluated using eval().</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.iseval-Tuple{Any}" href="#ExprRules.iseval-Tuple{Any}"><code>ExprRules.iseval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">iseval(rule::Any)</code></pre><p>Returns true if the rule is the special evaluate immediately function, i.e., _()</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.iseval-Tuple{Grammar,Int64}" href="#ExprRules.iseval-Tuple{Grammar,Int64}"><code>ExprRules.iseval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">iseval(grammar::Grammar, rule_index::Int)</code></pre><p>Returns true if the production rule at rule_index contains the special _() eval function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.iseval-Tuple{Grammar}" href="#ExprRules.iseval-Tuple{Grammar}"><code>ExprRules.iseval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">iseval(grammar::Grammar)</code></pre><p>Returns true if any production rules in grammar contain the special _() eval function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.isterminal-Tuple{Any,AbstractArray{Symbol,1}}" href="#ExprRules.isterminal-Tuple{Any,AbstractArray{Symbol,1}}"><code>ExprRules.isterminal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isterminal(rule::Any, types::AbstractVector{Symbol})</code></pre><p>Returns true if the rule is terminal, ie does not contain any of the types in the provided vector. For example, :(x) is terminal, and :(1+1) is terminal, but :(Real + Real) is typically not.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.isterminal-Tuple{Grammar,Int64}" href="#ExprRules.isterminal-Tuple{Grammar,Int64}"><code>ExprRules.isterminal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isterminal(grammar::Grammar, rule_index::Int)</code></pre><p>Returns true if the production rule at rule_index is terminal, i.e., does not contain any nonterminal symbols.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.isterminal-Tuple{Grammar,RuleNode}" href="#ExprRules.isterminal-Tuple{Grammar,RuleNode}"><code>ExprRules.isterminal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isterminal(grammar::Grammar, node::RuleNode)</code></pre><p>Returns true if the production rule used by node is terminal, i.e., does not contain any nonterminal symbols.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.max_arity-Tuple{Grammar}" href="#ExprRules.max_arity-Tuple{Grammar}"><code>ExprRules.max_arity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">max_arity(grammar::Grammar)</code></pre><p>Returns the maximum arity (number of children) over all production rules in the grammar.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.mindepth-Tuple{Grammar,Symbol,AbstractArray{Int64,1}}" href="#ExprRules.mindepth-Tuple{Grammar,Symbol,AbstractArray{Int64,1}}"><code>ExprRules.mindepth</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mindepth(grammar::Grammar, typ::Symbol, dmap::AbstractVector{Int})</code></pre><p>Returns the minimum depth achievable for a given nonterminal symbol</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.mindepth_map-Tuple{Grammar}" href="#ExprRules.mindepth_map-Tuple{Grammar}"><code>ExprRules.mindepth_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mindepth_map(grammar::Grammar)</code></pre><p>Returns the minimum depth achievable for each production rule, dmap.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.nchildren-Tuple{Grammar,Int64}" href="#ExprRules.nchildren-Tuple{Grammar,Int64}"><code>ExprRules.nchildren</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nchildren(grammar::Grammar, rule_index::Int)</code></pre><p>Returns the number of children (nonterminals) of the production rule at rule_index.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.nchildren-Tuple{Grammar,RuleNode}" href="#ExprRules.nchildren-Tuple{Grammar,RuleNode}"><code>ExprRules.nchildren</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nchildren(grammar::Grammar, node::RuleNode)</code></pre><p>Returns the number of children in the production rule used by node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.node_depth-Tuple{RuleNode,RuleNode}" href="#ExprRules.node_depth-Tuple{RuleNode,RuleNode}"><code>ExprRules.node_depth</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">node_depth(root::RuleNode, node::RuleNode)</code></pre><p>Return the depth of node for an expression tree rooted at root.  Depth is 1 when root == node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.nonterminals-Tuple{Grammar}" href="#ExprRules.nonterminals-Tuple{Grammar}"><code>ExprRules.nonterminals</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nonterminals(grammar::Grammar)</code></pre><p>Returns a list of nonterminals in the grammar.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.return_type-Tuple{Grammar,Int64}" href="#ExprRules.return_type-Tuple{Grammar,Int64}"><code>ExprRules.return_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">return_type(grammar::Grammar, rule_index::Int)</code></pre><p>Returns the type of the production rule at rule_index.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.return_type-Tuple{Grammar,RuleNode}" href="#ExprRules.return_type-Tuple{Grammar,RuleNode}"><code>ExprRules.return_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">return_types(grammar::Grammar, node::RuleNode)</code></pre><p>Returns the return type in the production rule used by node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.root_node_loc-Tuple{RuleNode}" href="#ExprRules.root_node_loc-Tuple{RuleNode}"><code>ExprRules.root_node_loc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">root_node_loc(root::RuleNode)</code></pre><p>Returns a NodeLoc pointing to the root node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sample(root::RuleNode, typ::Symbol, grammar::Grammar,
                      maxdepth::Int=typemax(Int))</code></pre><p>Selects a uniformly random node of the given return type, typ, limited to maxdepth.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sample(root::RuleNode, typ::Symbol, grammar::Grammar, maxdepth::Int=typemax(Int))</code></pre><p>Selects a uniformly random node from the tree, limited to maxdepth.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sample(::Type{NodeLoc}, root::RuleNode, maxdepth::Int=typemax(Int))</code></pre><p>Selects a uniformly random node in the tree no deeper than maxdepth using reservoir sampling. Returns a NodeLoc that specifies the location using its parent so that the subtree can be replaced.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sample(::Type{NodeLoc}, root::RuleNode, typ::Symbol, grammar::Grammar)</code></pre><p>Selects a uniformly random node in the tree of a given type, specified using its parent such that the subtree can be replaced. Returns a NodeLoc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get-Tuple{RuleNode,NodeLoc}" href="#Base.get-Tuple{RuleNode,NodeLoc}"><code>Base.get</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get(root::RuleNode, loc::NodeLoc)</code></pre><p>Obtain the node pointed to by loc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.insert!-Tuple{RuleNode,NodeLoc,RuleNode}" href="#Base.insert!-Tuple{RuleNode,NodeLoc,RuleNode}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">insert!(loc::NodeLoc, rulenode::RuleNode)</code></pre><p>Replaces the subtree pointed to by loc with the given rulenode.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{RuleNode}" href="#Base.length-Tuple{RuleNode}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the number of vertices in the tree rooted at root.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rand(::Type{RuleNode}, grammar::Grammar, typ::Symbol, max_depth::Int=10)</code></pre><p>Generates a random RuleNode of return type typ and maximum depth max_depth.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rand(::Type{RuleNode}, grammar::Grammar, typ::Symbol, dmap::AbstractVector{Int}, max_depth::Int=10)</code></pre><p>Generates a random RuleNode of return type typ and maximum depth max_depth guided by a minimum depth map dmap.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.eval-Tuple{Dict{Symbol,Any},Any}" href="#Core.eval-Tuple{Dict{Symbol,Any},Any}"><code>Core.eval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Core.eval(tab::SymbolTable, ex::Expr)</code></pre><p>Evaluate the expression ex using symbol table tab </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.eval-Tuple{RuleNode,Grammar}" href="#Core.eval-Tuple{RuleNode,Grammar}"><code>Core.eval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Core.eval(rulenode::RuleNode, grammar::Grammar)</code></pre><p>Evaluate the expression tree with root rulenode.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ExprRules.get_childtypes-Tuple{Any,AbstractArray{Symbol,1}}" href="#ExprRules.get_childtypes-Tuple{Any,AbstractArray{Symbol,1}}"><code>ExprRules.get_childtypes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_childtypes(rule::Any, types::AbstractVector{Symbol})</code></pre><p>Returns the child types of a production rule.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
