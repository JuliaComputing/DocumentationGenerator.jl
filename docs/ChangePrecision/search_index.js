var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Readme",
    "title": "Readme",
    "category": "page",
    "text": ""
},

{
    "location": "#ChangePrecision-1",
    "page": "Readme",
    "title": "ChangePrecision",
    "category": "section",
    "text": "(Image: Build Status) (Image: Build status)This package makes it easy to change the \"default\" precision of a large body of Julia code, simply by prefixing it with the @changeprecision T expression macro, for example:@changeprecision Float32 begin\n    x = 7.3\n    y = 1/3\n    z = rand() .+ ones(3,4)\nendIn particular, floating-point literals like 7.3 are reinterpreted as the requested type Float32, operations like / that convert integer arguments to Float64 instead convert to Float32, and random-number or matrix constructors like rand and ones default to Float32 instead of Float64. Several other cases are handled as well: arithmetic with irrational constants like pi, linear-algebra functions (like inv) on integer matrices, etcetera.The @changeprecision transformations are applied recursively to any include(filename) call, so that you can simply do @changeprecision Float32 include(\"mycode.jl\") to run a whole script mycode.jl in Float32 default precision.Code that explicitly specifies a type, e.g. rand(Float64), is unaffected by @changeprecision.Note that only expressions that explicitly appear in the expression (or code inserted by include) are converted by @changeprecision.  Code hidden inside external functions that are called is not affected."
},

{
    "location": "autodocs/#",
    "page": "Docstrings",
    "title": "Docstrings",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [ChangePrecision]\nOrder = [:type, :function]"
},

]}
