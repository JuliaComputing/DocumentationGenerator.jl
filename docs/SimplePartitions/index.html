<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SimplePartitions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimplePartitions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.IntegerPartition" href="#SimplePartitions.IntegerPartition"><code>SimplePartitions.IntegerPartition</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An <code>IntegerPartition</code> is a decreasing list of positive integers. Construct in the following ways:</p><ul><li><code>IntegerParition([a,b,c,...])</code></li><li><code>IntegerPartition(a,b,c,...)</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.Partition" href="#SimplePartitions.Partition"><code>SimplePartitions.Partition</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>Partition</code> is a set of nonempty, pairwise disjoint sets. A new <code>Partition</code> is created by specifying the ground set <code>A</code> and calling <code>Partition(A)</code>. The set <code>A</code> may be either a <code>Set{T}</code> for some type <code>T</code> or an <code>BitSet</code>.</p><p>The parameter <code>A</code> may also be a list (one-dimensional array).</p><p>In addition, <code>Partition(n)</code> for a nonnegative integer <code>n</code> creates a partition of the set {1,2,...,n}.</p><p>The datatype <code>Partition</code> is, essentially, a wrapper around the <code>DataStructures.DisjointSets</code> type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.Partition-Tuple{Dict}" href="#SimplePartitions.Partition-Tuple{Dict}"><code>SimplePartitions.Partition</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Partition(d::Dict)</code> constructs a new partition whose elements are the keys of <code>d</code>. Two elements <code>a</code> and <code>b</code> are in the same part of the partition iff <code>d[a]==d[b]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.Partition-Tuple{Permutations.Permutation}" href="#SimplePartitions.Partition-Tuple{Permutations.Permutation}"><code>SimplePartitions.Partition</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Partition(p::Permutation)</code> constructs a new partition in which the parts are the cycles of the permutation <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractLattices.:∧-Tuple{SimplePartitions.Partition,SimplePartitions.Partition}" href="#AbstractLattices.:∧-Tuple{SimplePartitions.Partition,SimplePartitions.Partition}"><code>AbstractLattices.:∧</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>For partitions <code>P</code> and <code>Q</code>, <code>P∧Q</code> is their meet.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractLattices.:∨-Tuple{SimplePartitions.Partition,SimplePartitions.Partition}" href="#AbstractLattices.:∨-Tuple{SimplePartitions.Partition,SimplePartitions.Partition}"><code>AbstractLattices.:∨</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>For partitions <code>P</code> and <code>Q</code>, <code>P∨Q</code> is their join.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.Ferrers" href="#SimplePartitions.Ferrers"><code>SimplePartitions.Ferrers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>Ferrers(P::IntegerParition)</code> prints a graphical representation of the partition <code>P</code> in the form of a Ferrer&#39;s diagram.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.PartitionBuilder-Union{Tuple{Set{Set{T}}}, Tuple{T}, Tuple{Set{Set{T}},Bool}} where T" href="#SimplePartitions.PartitionBuilder-Union{Tuple{Set{Set{T}}}, Tuple{T}, Tuple{Set{Set{T}},Bool}} where T"><code>SimplePartitions.PartitionBuilder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>PartitionBuilder(A,check=true)</code> takes a set of nonempty, pairwise disjoint sets and creates the corresponding partition. It is the inverse operation to <code>parts(P)</code>. The optional parameter <code>check</code> causes sanity checks to be return on the input set of sets (throwing errors if it is invalid).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.all_partitions-Union{Tuple{Set{T}}, Tuple{T}} where T" href="#SimplePartitions.all_partitions-Union{Tuple{Set{T}}, Tuple{T}} where T"><code>SimplePartitions.all_partitions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>all_partitions(A::Set)</code> creates a <code>Set</code> containing all possible partitions of the set <code>A</code>.</p><p><code>all_partitions(n::Int)</code> creates the <code>Set</code> of all partitions of the set <code>{1,2,...,n}</code>.</p><p>Both of these take an optional second argument <code>k</code> to specify that only partitions with exactly <code>k</code> parts should be returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.find_part-Union{Tuple{T}, Tuple{Partition{T},T}} where T" href="#SimplePartitions.find_part-Union{Tuple{T}, Tuple{Partition{T},T}} where T"><code>SimplePartitions.find_part</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>find_part(P,a)</code> returns the part of <code>P</code> that contains <code>a</code> (or throws an error if <code>a</code> is not in the ground set).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.ground_set-Tuple{SimplePartitions.Partition}" href="#SimplePartitions.ground_set-Tuple{SimplePartitions.Partition}"><code>SimplePartitions.ground_set</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>elements(P)</code> returns (a copy of) the ground set of the partition <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.in_same_part-Union{Tuple{T}, Tuple{Partition{T},T,T}} where T" href="#SimplePartitions.in_same_part-Union{Tuple{T}, Tuple{Partition{T},T,T}} where T"><code>SimplePartitions.in_same_part</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>in_same_part(P,a,b)</code> returns <code>true</code> if <code>a</code> and <code>b</code> are in the same part of the partition <code>P</code>. An error is thrown if either is not in the ground set of <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.meet-Union{Tuple{T}, Tuple{Partition{T},Partition{T}}} where T" href="#SimplePartitions.meet-Union{Tuple{T}, Tuple{Partition{T},Partition{T}}} where T"><code>SimplePartitions.meet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>meet(P,Q)</code> computes the meet of the partitions. This may also be invoked as <code>P*Q</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.merge_parts!-Union{Tuple{T}, Tuple{Partition{T},Array{T,1}}} where T" href="#SimplePartitions.merge_parts!-Union{Tuple{T}, Tuple{Partition{T},Array{T,1}}} where T"><code>SimplePartitions.merge_parts!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>merge_parts!(P,elts)</code> merges all the elements in <code>elts</code> into a part. Thus <code>merge_parts!(P,[a,b])</code> is equivalent to <code>merge_parts!(P,a,b)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.merge_parts!-Union{Tuple{T}, Tuple{Partition{T},T,T}} where T" href="#SimplePartitions.merge_parts!-Union{Tuple{T}, Tuple{Partition{T},T,T}} where T"><code>SimplePartitions.merge_parts!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>merge_parts!(P,a,b)</code> updates <code>P</code> by merging the parts that contain elements <code>a</code> and <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.num_elements-Tuple{SimplePartitions.Partition}" href="#SimplePartitions.num_elements-Tuple{SimplePartitions.Partition}"><code>SimplePartitions.num_elements</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>num_elements(P)</code> gives the number of elements in the ground set of the partition <code>P</code>. This equals the sum of the sizes of the parts.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.num_parts-Tuple{SimplePartitions.Partition}" href="#SimplePartitions.num_parts-Tuple{SimplePartitions.Partition}"><code>SimplePartitions.num_parts</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>num_parts(P)</code> gives the number of parts in the partition <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.parts-Union{Tuple{Partition{T}}, Tuple{T}} where T" href="#SimplePartitions.parts-Union{Tuple{Partition{T}}, Tuple{T}} where T"><code>SimplePartitions.parts</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>parts(P)</code> returns a set containing the parts of the partition <code>P</code>. That is, we return a set of sets.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.refines-Union{Tuple{T}, Tuple{Partition{T},Partition{T}}} where T" href="#SimplePartitions.refines-Union{Tuple{T}, Tuple{Partition{T},Partition{T}}} where T"><code>SimplePartitions.refines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>refines(P,Q)</code> determines if <code>P</code> is a refinement of <code>Q</code>. That is, is every part of <code>P</code> a subset of a part of <code>Q</code>? The two partitions must have the same ground set of else an error is thrown.</p><p><code>refines(P,Q)</code> can be invoked as <code>P&lt;=Q</code>. The variants <code>P&lt;Q</code>, <code>P&gt;=Q</code>, and <code>P&gt;Q</code> operate as expected. Note that partitions are only partially ordered by refinement and one can easily construct partitions <code>P</code> and <code>Q</code> for which both <code>P&lt;=Q</code> and <code>Q&lt;=P</code> are false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.set_element_type-Union{Tuple{Set{T}}, Tuple{T}} where T" href="#SimplePartitions.set_element_type-Union{Tuple{Set{T}}, Tuple{T}} where T"><code>SimplePartitions.set_element_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>set_element_type(A)</code> gives the element type of a set <code>A</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{SimplePartitions.Partition,SimplePartitions.Partition}" href="#Base.:*-Tuple{SimplePartitions.Partition,SimplePartitions.Partition}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>For partitions <code>P</code> and <code>Q</code>, <code>P*Q</code> is their meet.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{IntegerPartition,IntegerPartition}" href="#Base.:+-Tuple{IntegerPartition,IntegerPartition}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The sum of <code>IntegerPartition</code>s is their concatenation (multiset union).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{SimplePartitions.Partition,SimplePartitions.Partition}" href="#Base.:+-Tuple{SimplePartitions.Partition,SimplePartitions.Partition}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>For partitions <code>P</code> and <code>Q</code>, <code>P+Q</code> is their join.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{Partition{T},Set{T}}} where T" href="#Base.:+-Union{Tuple{T}, Tuple{Partition{T},Set{T}}} where T"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>For a partition <code>P</code> and a set <code>A</code>, <code>P+A</code> creates a new partition with <code>A</code> as a new part. Note that <code>A</code> and the ground set of <code>P</code> must be disjoint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{Partition{T},T}} where T" href="#Base.:+-Union{Tuple{T}, Tuple{Partition{T},T}} where T"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>For a partition <code>P</code> and element <code>x</code>, <code>P+x</code> builds a new partition that adds <code>x</code> as a singleton element.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.collect-Tuple{SimplePartitions.Partition}" href="#Base.collect-Tuple{SimplePartitions.Partition}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>collect(P::Partition)</code> returns a list of the parts of the partition <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj-Tuple{IntegerPartition}" href="#Base.conj-Tuple{IntegerPartition}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>conj(P::IntegerPartition)</code> returns the Ferrer&#39;s conjugate of <code>P</code>. Also available as <code>P&#39;</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in-Union{Tuple{T}, Tuple{T,Partition{T}}} where T" href="#Base.in-Union{Tuple{T}, Tuple{T,Partition{T}}} where T"><code>Base.in</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>in(a,P)</code> checks if <code>a</code> is in the ground set of <code>P</code> and <code>in(A,P)</code> checks if <code>A</code> is a part of <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join-Union{Tuple{T}, Tuple{Partition{T},Partition{T}}} where T" href="#Base.join-Union{Tuple{T}, Tuple{Partition{T},Partition{T}}} where T"><code>Base.join</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>join(P,Q)</code> computes the join of the two partitions. This may also be invoked as <code>P+Q</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimplePartitions.kill_sos!-Union{Tuple{Partition{T}}, Tuple{T}} where T" href="#SimplePartitions.kill_sos!-Union{Tuple{Partition{T}}, Tuple{T}} where T"><code>SimplePartitions.kill_sos!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>kill_sos!(P)</code> wipes out the set-of-sets cache. Only used internally.</p></div></div></section><footer><hr/></footer></article></body></html>
