<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Counters.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Counters.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Counters.Counter" href="#Counters.Counter"><code>Counters.Counter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>Counter</code> is a device for keeping a count of how often we observe various objects. It is created by giving a type such as <code>c=Counter{String}()</code>.</p><p>Counts are retrieved with square brackets like a dictionary: <code>c[&quot;hello&quot;]</code>. It is safe to retrieve the count of an object never encountered, e.g., <code>c[&quot;goodbye&quot;]</code>; in this case <code>0</code> is returned.</p><p>Counts may be assigned with <code>c[key]=amount</code>, but the more likely use case is using <code>c[key]+=1</code> to count each time <code>key</code> is encountered.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Counters.clean!-Union{Tuple{Counter{T}}, Tuple{T}} where T" href="#Counters.clean!-Union{Tuple{Counter{T}}, Tuple{T}} where T"><code>Counters.clean!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>clean!(c)</code> removes all keys from <code>c</code> whose value is <code>0</code>. Generally, it&#39;s not necessary to invoke this unless one suspects that <code>c</code> contains <em>a lot</em> of keys associated with a zero value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Counters.counter-Tuple{AbstractArray}" href="#Counters.counter-Tuple{AbstractArray}"><code>Counters.counter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>counter(list)</code> creates a <code>Counter</code> whose elements are the members of <code>list</code> with the appropriate multiplicities. This may also be used if <code>list</code> is a <code>Set</code> or an <code>IntSet</code> (in which case multiplicities will all be 1).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Counters.csv_print-Tuple{Counter}" href="#Counters.csv_print-Tuple{Counter}"><code>Counters.csv_print</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>csv_print(C::Counter)</code> prints out <code>C</code> in a manner suitable for import into a spreadsheet.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Counters.incr!-Union{Tuple{T}, Tuple{Counter{T},T}} where T" href="#Counters.incr!-Union{Tuple{T}, Tuple{Counter{T},T}} where T"><code>Counters.incr!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>incr!(c,x)</code> increments the count for <code>x</code> by 1. This is equivalent to <code>c[x]+=1</code>.</p><p><code>incr!(c,items)</code> is more useful. Here <code>items</code> is an iterable collection of keys and we increment the count for each element in <code>items</code>.</p><p><code>incr!(c,d)</code> where <code>c</code> and <code>d</code> are counters will increment <code>c</code> by the amounts held in <code>d</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Counters.mean-Union{Tuple{Counter{T}}, Tuple{T}} where T&lt;:Number" href="#Counters.mean-Union{Tuple{Counter{T}}, Tuple{T}} where T&lt;:Number"><code>Counters.mean</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>mean(C::Counter)</code> computes the weighted average of the objects in <code>C</code>. Of course, the counted objects must be a <code>Number</code>; their multiplicity (weight) in the average is determined by their <code>C</code>-value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{Counter{T},Counter{T}}} where T" href="#Base.:+-Union{Tuple{T}, Tuple{Counter{T},Counter{T}}} where T"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If <code>c</code> and <code>d</code> are <code>Counter</code>s, then <code>c+d</code> creates a new <code>Counter</code> in which the count associated with an object <code>x</code> is <code>c[x]+d[x]</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.collect-Union{Tuple{Counter{T}}, Tuple{T}} where T" href="#Base.collect-Union{Tuple{Counter{T}}, Tuple{T}} where T"><code>Base.collect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>collect(C)</code> for a <code>Counter</code> returns an array containing the elements of <code>C</code> each repeated according to its multiplicty.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hash" href="#Base.hash"><code>Base.hash</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Performing <code>hash</code> on a <code>Counter</code> will first apply <code>clean!</code> to the <code>Counter</code> in order that equal <code>Counter</code> objects hash the same.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys-Tuple{Counter}" href="#Base.keys-Tuple{Counter}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>keys(c::Counter)</code> returns an interator for the things counted by <code>c</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{Counter}" href="#Base.length-Tuple{Counter}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>length(c::Counter)</code> gives the number of entries monitored by the Counter. Conceivably, some may have value <code>0</code>.</p><p>See also: <code>nnz</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sum-Tuple{Counter}" href="#Base.sum-Tuple{Counter}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>sum(c::Counter)</code> gives the total of the counts for all things in <code>c</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SparseArrays.nnz-Tuple{Counter}" href="#SparseArrays.nnz-Tuple{Counter}"><code>SparseArrays.nnz</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>nnz(c::Counter)</code> gives the number of keys in the <code>Counter</code> with nonzero value.</p><p>See also: <code>length</code>.</p></div></div></section><footer><hr/></footer></article></body></html>
