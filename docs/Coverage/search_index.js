var documenterSearchIndex = {"docs": [

{
    "location": "#Coverage.FileCoverage",
    "page": "Home",
    "title": "Coverage.FileCoverage",
    "category": "type",
    "text": "FileCoverage\n\nRepresents coverage info about a file, including the filename, the source code itself, and a Vector of run counts for each line. If the line was expected to be run the count will be an Int >= 0. Other lines such as comments will have a count of nothing.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.amend_coverage_from_src!-Tuple{Array{Union{Nothing, Int64},1},Any}",
    "page": "Home",
    "title": "Coverage.amend_coverage_from_src!",
    "category": "method",
    "text": "amend_coverage_from_src!(coverage::Vector{CovCount}, srcname)\n\nThe code coverage functionality in Julia can miss code lines, which will be incorrectly recorded as nothing but should instead be 0 This function takes a coverage count vector and a the filename for a Julia code file, and updates the coverage vector in place.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.clean_file-Tuple{AbstractString}",
    "page": "Home",
    "title": "Coverage.clean_file",
    "category": "method",
    "text": "clean_file(filename::AbstractString)\n\nCleans up all .cov files associated with a given source file. This only looks in the directory of the given file, i.e. the .cov files should be siblings of the source file.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.clean_folder-Tuple{AbstractString}",
    "page": "Home",
    "title": "Coverage.clean_folder",
    "category": "method",
    "text": "clean_folder(folder::AbstractString)\n\nCleans up all the .cov files in the given directory and subdirectories. Unlike process_folder this does not include a default value for the root folder, requiring the calling code to be more explicit about which files will be deleted.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.get_summary",
    "page": "Home",
    "title": "Coverage.get_summary",
    "category": "function",
    "text": "get_summary(fcs)\n\nSummarize results from a single FileCoverage instance or a Vector of them, returning a 2-tuple with the covered lines and total lines.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.merge_coverage_counts-Tuple{Array{Union{Nothing, Int64},1},Array{Union{Nothing, Int64},1}}",
    "page": "Home",
    "title": "Coverage.merge_coverage_counts",
    "category": "method",
    "text": "merge_coverage_counts(a1::Vector{CovCount}, a2::Vector{CovCount})\n\nGiven two vectors of line coverage counts, take the pairwise maximum of both vectors, preseving null counts if both are null.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.process_cov-Tuple{Any,Any}",
    "page": "Home",
    "title": "Coverage.process_cov",
    "category": "method",
    "text": "process_cov(filename, folder)\n\nGiven a filename for a Julia source file, produce an array of line coverage counts by reading in all matching .{pid}.cov files. On Julia 0.3 there was just a .cov file, but this code works fine.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.process_file",
    "page": "Home",
    "title": "Coverage.process_file",
    "category": "function",
    "text": "process_file(filename[, folder]) -> FileCoverage\n\nGiven a .jl file and its containing folder, produce a corresponding FileCoverage instance from the source and matching coverage files. If the folder is not given it is extracted from the filename.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.process_folder",
    "page": "Home",
    "title": "Coverage.process_folder",
    "category": "function",
    "text": "process_folder(folder=\"src\") -> Vector{FileCoverage}\n\nProcess the contents of a folder of Julia source code to collect coverage statistics for all the files contained within. Will recursively traverse child folders. Default folder is \"src\", which is useful for the primary case where Coverage is called from the root directory of a package.\n\n\n\n\n\n"
},

{
    "location": "#Coverage.analyze_malloc_files-Tuple{Any}",
    "page": "Home",
    "title": "Coverage.analyze_malloc_files",
    "category": "method",
    "text": "analyze_malloc_files(files) -> Vector{MallocInfo}\n\nIterates through the given list of filenames and return a Vector of MallocInfos with allocation information.\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [Coverage]\nOrder = [:type, :function]"
},

]}
