var documenterSearchIndex = {"docs": [

{
    "location": "#Distances.Bregman",
    "page": "Home",
    "title": "Distances.Bregman",
    "category": "type",
    "text": "Implements the Bregman divergence, a friendly introduction to which can be found here.  Bregman divergences are a minimal implementation of the \"mean-minimizer\" property. \n\nIt is assumed that the (convex differentiable) function F maps vectors (of any type or size) to real numbers.  The inner product used is Base.dot, but one can be passed in either by defining inner or by  passing in a keyword argument. If an analytic gradient isn\'t available, Julia offers a suite  of good automatic differentiation packages. \n\nfunction evaluate(dist::Bregman, p::AbstractVector, q::AbstractVector)\n\n\n\n\n\n"
},

{
    "location": "#Distances.Euclidean-Tuple{}",
    "page": "Home",
    "title": "Distances.Euclidean",
    "category": "method",
    "text": "Euclidean([thresh])\n\nCreate a euclidean metric.\n\nWhen computing distances among large numbers of points, it can be much more efficient to exploit the formula\n\n(x-y)^2 = x^2 - 2xy + y^2\n\nHowever, this can introduce roundoff error. thresh (which defaults to 0) specifies the relative square-distance tolerance on 2xy compared to x^2 + y^2 to force recalculation of the distance using the more precise direct (elementwise-subtraction) formula.\n\nExample:\n\njulia> x = reshape([0.1, 0.3, -0.1], 3, 1);\n\njulia> pairwise(Euclidean(), x, x)\n1×1 Array{Float64,2}:\n 7.45058e-9\n\njulia> pairwise(Euclidean(1e-12), x, x)\n1×1 Array{Float64,2}:\n 0.0\n\n\n\n\n\n"
},

{
    "location": "#Distances.Haversine",
    "page": "Home",
    "title": "Distances.Haversine",
    "category": "type",
    "text": "Haversine(radius)\n\nThe haversine distance between two locations on a sphere of given radius.\n\nLocations are described with longitude and latitude in degrees. The computed distance has the same units as that of the radius.\n\n\n\n\n\n"
},

{
    "location": "#Distances.RenyiDivergence",
    "page": "Home",
    "title": "Distances.RenyiDivergence",
    "category": "type",
    "text": "RenyiDivergence(α::Real)\nrenyi_divergence(P, Q, α::Real)\n\nCreate a Rényi premetric of order α.\n\nRényi defined a spectrum of divergence measures generalising the Kullback–Leibler divergence (see KLDivergence). The divergence is not a semimetric as it is not symmetric. It is parameterised by a parameter α, and is equal to Kullback–Leibler divergence at α = 1:\n\nAt α = 0, R_0(P  Q) = -log(sum_i p_i  0(q_i))\n\nAt α = 1, R_1(P  Q) = sum_i p_i  0(p_i log(p_i  q_i))\n\nAt α = ∞, R_(P  Q) = log(sup_i p_i  0(p_i  q_i))\n\nOtherwise R_α(P  Q) = log(sum_i p_i  0((p_i ^ α)  (q_i ^ (α - 1)))  (α - 1)\n\nExample:\n\njulia> x = reshape([0.1, 0.3, 0.4, 0.2], 2, 2);\n\njulia> pairwise(RenyiDivergence(0), x, x)\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\njulia> pairwise(Euclidean(2), x, x)\n2×2 Array{Float64,2}:\n 0.0       0.577315\n 0.655407  0.0\n\n\n\n\n\n"
},

{
    "location": "#Distances.SqEuclidean-Tuple{}",
    "page": "Home",
    "title": "Distances.SqEuclidean",
    "category": "method",
    "text": "SqEuclidean([thresh])\n\nCreate a squared-euclidean semi-metric. For the meaning of thresh, see Euclidean.\n\n\n\n\n\n"
},

{
    "location": "#Distances.renyi_divergence",
    "page": "Home",
    "title": "Distances.renyi_divergence",
    "category": "function",
    "text": "RenyiDivergence(α::Real)\nrenyi_divergence(P, Q, α::Real)\n\nCreate a Rényi premetric of order α.\n\nRényi defined a spectrum of divergence measures generalising the Kullback–Leibler divergence (see KLDivergence). The divergence is not a semimetric as it is not symmetric. It is parameterised by a parameter α, and is equal to Kullback–Leibler divergence at α = 1:\n\nAt α = 0, R_0(P  Q) = -log(sum_i p_i  0(q_i))\n\nAt α = 1, R_1(P  Q) = sum_i p_i  0(p_i log(p_i  q_i))\n\nAt α = ∞, R_(P  Q) = log(sup_i p_i  0(p_i  q_i))\n\nOtherwise R_α(P  Q) = log(sum_i p_i  0((p_i ^ α)  (q_i ^ (α - 1)))  (α - 1)\n\nExample:\n\njulia> x = reshape([0.1, 0.3, 0.4, 0.2], 2, 2);\n\njulia> pairwise(RenyiDivergence(0), x, x)\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\njulia> pairwise(Euclidean(2), x, x)\n2×2 Array{Float64,2}:\n 0.0       0.577315\n 0.655407  0.0\n\n\n\n\n\n\n\n"
},

{
    "location": "#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": "Package doesn\'t contain Documenter docs.Docs automatically generated by juliadocs.orgModules = [Distances]\nOrder = [:type, :function]"
},

]}
