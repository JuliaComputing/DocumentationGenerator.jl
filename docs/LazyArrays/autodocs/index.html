<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · LazyArrays.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LazyArrays.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><p>Package doesn&#39;t contain Documenter docs.</p><p>Docs automatically generated by juliadocs.org</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.Mul-Tuple" href="#LazyArrays.Mul-Tuple"><code>LazyArrays.Mul</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Mul(A1, A2, …, AN)</p><p>represents lazy multiplication A1<em>A2</em>…*AN. The factors must have compatible axes. If any argument is itself a Mul, it automatically gets flatten. That is, we assume associativity. Use Mul((A, B, C)) to stop flattening</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.cache-Tuple{AbstractArray}" href="#LazyArrays.cache-Tuple{AbstractArray}"><code>LazyArrays.cache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cache(array::AbstractArray)</code></pre><p>Caches the entries of an array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.AbstractStridedLayout" href="#LazyArrays.AbstractStridedLayout"><code>LazyArrays.AbstractStridedLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractStridedLayout</code></pre><p>is an abstract type whose subtypes are returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage laid out at regular offsets in memory, and which can therefore be passed to external C and Fortran functions expecting this memory layout.</p><p>Julia&#39;s internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is BLAS compatible and the element type is a <code>Float32</code>, <code>Float64</code>, <code>ComplexF32</code>, or <code>ComplexF64</code>. In this case, one must implement the strided array interface, which requires overrides of <code>strides(A::MyMatrix)</code> and <code>unknown_convert(::Type{Ptr{T}}, A::MyMatrix)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.Add-Tuple" href="#LazyArrays.Add-Tuple"><code>LazyArrays.Add</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Add(A1, A2, …, AN)</code></pre><p>A lazy representation of <code>A1 .+ A2 .+ … .+ AN</code>; i.e., a shorthand for <code>BroadcastArray(+, A1, A2, …, AN)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.BroadcastLayout" href="#LazyArrays.BroadcastLayout"><code>LazyArrays.BroadcastLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BroadcastLayout(f, layouts)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> is a <code>BroadcastArray</code>. <code>f</code> is a function that broadcast operation is applied and <code>layouts</code> is a tuple of <code>MemoryLayout</code> of the broadcasted arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.ColumnMajor" href="#LazyArrays.ColumnMajor"><code>LazyArrays.ColumnMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ColumnMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a column major array, so that <code>stride(A,1) == 1</code> and <code>stride(A,i) ≥ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>.</p><p>Arrays with <code>ColumnMajor</code> memory layout must conform to the <code>DenseArray</code> interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DecreasingStrides" href="#LazyArrays.DecreasingStrides"><code>LazyArrays.DecreasingStrides</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DecreasingStrides()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a strided array with decreasing strides, so that <code>stride(A,ndims(A)) ≥ 1</code> and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)<code>for</code>1 ≤ i ≤ ndims(A)-1`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DenseColumnMajor" href="#LazyArrays.DenseColumnMajor"><code>LazyArrays.DenseColumnMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DenseColumnMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory equivalent to an <code>Array</code>, so that <code>stride(A,1) == 1</code> and <code>stride(A,i) ≡ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>. In particular, if <code>A</code> is a matrix then <code>strides(A) ==</code>(1, size(A,1))`.</p><p>Arrays with <code>DenseColumnMajor</code> memory layout must conform to the <code>DenseArray</code> interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DenseRowMajor" href="#LazyArrays.DenseRowMajor"><code>LazyArrays.DenseRowMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DenseRowMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a row major array with dense entries, so that <code>stride(A,ndims(A)) == 1</code> and <code>stride(A,i) ≡ size(A,i+1) * stride(A,i+1)</code> for <code>1 ≤ i ≤ ndims(A)-1</code>. In particular, if <code>A</code> is a matrix then <code>strides(A) ==</code>(size(A,2), 1)`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.HermitianLayout" href="#LazyArrays.HermitianLayout"><code>LazyArrays.HermitianLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HermitianLayout(layout, uplo)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory as a hermitianized version of <code>layout</code>, where the entries used are dictated by the <code>uplo</code>, which can be <code>&#39;U&#39;</code> or <code>L&#39;</code>.</p><p>A matrix that has memory layout <code>HermitianLayout(layout, uplo)</code> must overrided <code>hermitiandata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] == B[k,j]</code> for <code>j ≥ k</code> if <code>uplo == &#39;U&#39;</code> (<code>j ≤ k</code> if <code>uplo == &#39;L&#39;</code>) and <code>A[k,j] == conj(B[j,k])</code> for <code>j &lt; k</code> if <code>uplo == &#39;U&#39;</code> (<code>j &gt; k</code> if <code>uplo == &#39;L&#39;</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.IncreasingStrides" href="#LazyArrays.IncreasingStrides"><code>LazyArrays.IncreasingStrides</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IncreasingStrides()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a strided array with  increasing strides, so that <code>stride(A,1) ≥ 1</code> and <code>stride(A,i) ≥ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.LowerTriangularLayout" href="#LazyArrays.LowerTriangularLayout"><code>LazyArrays.LowerTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LowerTriangularLayout(layout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>LowerTriangular(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == layout</code>.</p><p>A matrix that has memory layout <code>LowerTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &gt; k</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j ≤ k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UpperTriangularLayout</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.MemoryLayout-Tuple{Any}" href="#LazyArrays.MemoryLayout-Tuple{Any}"><code>LazyArrays.MemoryLayout</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">MemoryLayout(A)</code></pre><p>specifies the layout in memory for an array <code>A</code>. When you define a new <code>AbstractArray</code> type, you can choose to override <code>MemoryLayout</code> to indicate how an array is stored in memory. For example, if your matrix is column major with <code>stride(A,2) == size(A,1)</code>, then override as follows:</p><pre><code class="language-none">MemoryLayout(::MyMatrix) = DenseColumnMajor()</code></pre><p>The default is <code>UnknownLayout()</code> to indicate that the layout in memory is unknown.</p><p>Julia&#39;s internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is compatible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.RowMajor" href="#LazyArrays.RowMajor"><code>LazyArrays.RowMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RowMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a row major array, so that <code>stride(A,ndims(A)) == 1</code> and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)<code>for</code>1 ≤ i ≤ ndims(A)-1`.</p><p>If <code>A</code> is a matrix  with <code>RowMajor</code> memory layout, then <code>transpose(A)</code> should return a matrix whose layout is <code>ColumnMajor</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.ScalarLayout" href="#LazyArrays.ScalarLayout"><code>LazyArrays.ScalarLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ScalarLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if A is a scalar, which does not live in memory</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.StridedLayout" href="#LazyArrays.StridedLayout"><code>LazyArrays.StridedLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StridedLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage laid out at regular offsets in memory. <code>Array</code>s with <code>StridedLayout</code> must conform to the <code>DenseArray</code> interface.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.SymmetricLayout" href="#LazyArrays.SymmetricLayout"><code>LazyArrays.SymmetricLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SymmetricLayout(layout, uplo)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory as a symmetrized version of <code>layout</code>, where the entries used are dictated by the <code>uplo</code>, which can be <code>&#39;U&#39;</code> or <code>L&#39;</code>.</p><p>A matrix that has memory layout <code>SymmetricLayout(layout, uplo)</code> must overrided <code>symmetricdata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] == B[k,j]</code> for <code>j ≥ k</code> if <code>uplo == &#39;U&#39;</code> (<code>j ≤ k</code> if <code>uplo == &#39;L&#39;</code>) and <code>A[k,j] == B[j,k]</code> for <code>j &lt; k</code> if <code>uplo == &#39;U&#39;</code> (<code>j &gt; k</code> if <code>uplo == &#39;L&#39;</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnitLowerTriangularLayout" href="#LazyArrays.UnitLowerTriangularLayout"><code>LazyArrays.UnitLowerTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UnitLowerTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UnitLowerTriangular(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == layout</code>.</p><p>A matrix that has memory layout <code>UnitLowerTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &gt; k</code>, <code>A[k,j] ≡ one(eltype(A))</code> for <code>j == k</code>, <code>A[k,j] ≡ B[k,j]</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UnitUpperTriangularLayout</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnitUpperTriangularLayout" href="#LazyArrays.UnitUpperTriangularLayout"><code>LazyArrays.UnitUpperTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UnitUpperTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UpperTriangularLayout(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == ML</code>.</p><p>A matrix that has memory layout <code>UnitUpperTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j &gt; k</code>, <code>A[k,j] ≡ one(eltype(A))</code> for <code>j == k</code>, <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UnitLowerTriangularLayout</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnknownLayout" href="#LazyArrays.UnknownLayout"><code>LazyArrays.UnknownLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UnknownLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if it is unknown how the entries of an array <code>A</code> are stored in memory.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UpperTriangularLayout" href="#LazyArrays.UpperTriangularLayout"><code>LazyArrays.UpperTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UpperTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UpperTriangularLayout(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == ML</code>.</p><p>A matrix that has memory layout <code>UpperTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j ≥ k</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>LowerTriangularLayout</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.colsupport-Tuple{Any,Any}" href="#LazyArrays.colsupport-Tuple{Any,Any}"><code>LazyArrays.colsupport</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>&quot;     colsupport(A, j)</p><p>gives an iterator containing the possible non-zero entries in the j-th column of A.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.rowsupport-Tuple{Any,Any}" href="#LazyArrays.rowsupport-Tuple{Any,Any}"><code>LazyArrays.rowsupport</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>&quot;     rowsupport(A, k)</p><p>gives an iterator containing the possible non-zero entries in the k-th row of A.</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
